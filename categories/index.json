[{"content":" 这个系列是我看冴羽老师的博客的理解笔记\n博客原文\n 上篇说到，当javascript代码执行一段可执行代码(executable code)时，会创建对应的执行上下文(execution context)\n那对于每个执行上下文，都有三个重要属性：\n 变量对象(Variable object, VO) 作用域链(Scope chain) this  本文主要讲执行上下文中的作用域链，注意本章将会把之前的内容穿起来很重要\n在之前第2篇作用域和第4篇变量对象中有提到，\n当查到变量时首先从当前上下文的变量对象中查到，\n如果没有找到会从父级（词法静态层面上的）执行上下文的变量对象中查找，\n一直找到全局变量对象（全局对象）\n这样由多个执行上下文的变量对象构成的链表就叫做作用域链\n函数创建 在第2篇中提到js中函数的作用域在函数定义的时候就决定了\n这是因为函数有一个内部属性`[[scope]]``, 当函数创建的时候会把函数的父变量对象保存到其中，但不是完整的作用链\n如：\nfunction foo() { function bar() { ... } } 此时函数的各自作用域为：\nfoo.[[scope]] = [ globalContext.VO ]; bar.[[scope]] = [ fooContext.AO, globalContext.VO ]; 函数激活 当函数激活的时候，进入函数上下文，创建VO/AO后，就会将函数活动对象加到作用域的最前端，\nScope = [AO].concat([[scope]]) 此时作用域链创建完毕\n总结事例 例子：\nvar scope = 'global scope'; function checkscope() { var scope2 = 'local scope'; return scope2; } checkscope(); 函数执行上下文中作用域和变量对象创建过程如下：\n1.checkscope函数被创建，保存作用域到内部属性[[scope]]\ncheckscope.[[scope]] = [ globalContext.VO ] 2.执行checkscope函数，创建checkscope函数执行上下文，checkscope函数执行上下文压入执行上下栈\nECStack = [ checkscopeContext, globalContext ]; 3.checkscope函数进入准备阶段\n3.1 复制函数内部属性[[scope]]到函数执行上文中\ncheckscopeContext = { Scope: checkscope.[[scope]] } 3.2 用函数的arguments属性创建活动对象，随后初始化活动对象，加入形参、函数声明、变量声明\ncheckscopeContext = { AO: { arguments: { length: 0, }, scope2: undefined }, Scope: checkscope.[[scope]] } 3.3 将活动对象压入作用域顶端\ncheckscopeContext = { AO: { arguments: { length: 0, }, scope2: undefined }, Scope: [AO, [[scope]]] } 准备工作完毕\n4.开始执行checkscope函数，随着函数执行，修改AO的属性值\ncheckscopeContext = { AO: { arguments: { length: 0, }, scope2: 'local scope' }, Scope: [AO, [[scope]]] } 5.查找到scope2的值，返回后函数执行完毕，checkscope函数上下文从执行上下文中弹出\nECStack = [ globalContext ] ","description":"","id":0,"section":"restart-js","tags":["js基础","学习笔记"],"title":"从头学习js-5-作用域链","uri":"http://llane00.github.io/restart-js/5-%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE/"},{"content":" 这个系列是我看冴羽老师的博客的理解笔记\n博客原文\n 上篇说到，当javascript代码执行一段可执行代码(executable code)时，会创建对应的执行上下文(execution context)\n那对于每个执行上下文，都有三个重要属性：\n 变量对象(Variable object, VO) 作用域链(Scope chain) this  本文主要讲执行上下文中的变量对象\n变量对象 变量对象是与执行上下文相关的数据作用域，储存了在上下文中定义的变量和函数声明\n因为不同执行上下文的变量对象稍有不同，这里分全局上下文下的变量对象和函数上下文下的变量对象来讨论。\n全局上下文的变量对象就是全局对象，是全局变量的宿主。\n在浏览器中，全局中的this和window都指向全局变量\n函数上下文中的变量对象称为活动对象（activation object，AO）\n活动对象就是变量对象，只是函数上下文中的变量对象只有函数代码在执行到被激活时才能被访问到，\n活动对象就是在进入函数上下文时被创建的，它通过函数的arguments属性初始化。\n执行上下文生命周期：  创建执行上下文阶段\n创建变量对象，建立作用域，以及明确this的指向    变量对象包括：\n 函数所有形参   由名称和对应值组成的一个变量对象的属性被创建 没有实参，属性值设为undefined  函数声明（函数声明优先于变量声明）   由名称和对应值（函数对象（function-object））组成的一个变量对象的属性被创建 如果变量对象已经存在相同名称的属性，则完全替换这个属性  变量声明   由名称和对应值（undefined）组成的一个变量对象的属性被创建 如果变量名称和已经声明的形式参数或函数相同，则变量声明不会干扰已经存在的这类属性    执行代码阶段\n创建上下文后，开始执行代码，  例子：\nfunction foo(a) { var b = 2; function c() {} var d = function() {}; b = 3; } foo(1) 在进入执行上下文后，此时的AO为\nAO = { //AO通过函数的arguments初始化，是一个伪数组 arguments: { 0: 1, length: 1 }, //函数所有形参 由名称和对应值组成的一个变量对象的属性被创建 a: 1, //变量声明 名称和对应值（undefined）组成的一个变量对象的属性被创建 b: undefined, //函数声明 由名称和对应值（函数对象（function-object））组成的一个变量对象的属性被创建 c: reference to function c(){}, //同上变量声明 d: undefined } 函数执行后：\n按顺序执行代码，初始化变量和给变量赋值\nAO = { arguments: { 0: 1, length: 1 }, a: 1, b: 3, c: reference to function c() {}, d: reference to FunctionExpression \u0026quot;d\u0026quot; } 关于声明变量和函数时的补充: 这里认为声明变量和函数都有三个阶段：\n1.创建create\n2.初始化initialize（声明时首次初始化不同于第三步的assign）\n3.赋值assign\n关于声明语法的结论是：\nfunction 的「创建」「初始化」和「赋值」都被提升了。\nvar 的「创建」和「初始化」都被提升了。\nlet 的「创建」过程被提升了，但是初始化没有提升，拥有块级作用(暂时性死区)。\nconst 只有创建和初始化，没有「赋值」,「创建」过程被提升了，拥有块级作用(暂时性死区)\n通常认为const不可变是片面的，\n首先const必须初始化，且在栈中储存的值不可修改，\n但当const声明的是引用类型时，堆中的储存值可以改变\n如：\nconst obj = {name: 'Neo', age: 20} obj.age = 25 console.log(obj) //{name: 'Neo', age: 25} 如果不通过关键词var let等声明变量，AO中不会创建对应该变量的key-value\n但是当这个变量被赋值assign的时候会创建变量对象到VO中\nmore 参考资料：  关于let的变量提升？探究 https://zhuanlan.zhihu.com/p/28140450/  ","description":"","id":1,"section":"restart-js","tags":["js基础","学习笔记"],"title":"从头学习js-4-变量对象","uri":"http://llane00.github.io/restart-js/4-%E5%8F%98%E9%87%8F%E5%AF%B9%E8%B1%A1/"},{"content":" 这个系列是我看冴羽老师的博客的理解笔记\n博客原文\n 我们知道在js中有变量提升，\n所以js引擎在解析代码的时候不是一行一行去执行的，而是一段一段去分析\n（暂且以函数花括号来划分段）\n实际环境中的函数可能是一层套一层执行的，加上函数有各自的静态作用域\njavascript引擎创建了执行上下文栈（Execution context stack，ECS）来管理这些情况\n由于函数的执行是有顺序的，执行上下文栈是先进后出的栈结构\n我们这里用数组来模拟它\nECStack = [] 首先执行全局代码，此时在ECStack中压入一个 globalContext\nECStack = [ globalContext ] 然后我们执行下面的实例代码\nfunction a() { console.log(\u0026quot;run a\u0026quot;) b() } function b() { console.log(\u0026quot;run b\u0026quot;) } a() 首先执行a函数，在ECStack中压入函数a的执行上下文，\nECStack = [ \u0026lt;a\u0026gt; functionContext, globalContext ] 发现执行函数a中，需要执行b函数（此时a还没执行完，没有出栈），在ECStack中压入函数b的执行上下文\nECStack = [ \u0026lt;b\u0026gt; functionContext, \u0026lt;a\u0026gt; functionContext, globalContext ] 函数b执行完后，函数b的执行上下文出栈，ECStack.pop()\n然后函数a也执行完了，继续 ECStack.pop()\n就是这么一个执行栈\n另一个例子：\n代码A\nvar scope = \u0026quot;global scope\u0026quot;; function checkscope(){ var scope = \u0026quot;local scope\u0026quot;; function f(){ return scope; } return f(); } checkscope(); 代码B\nvar scope = \u0026quot;global scope\u0026quot;; function checkscope(){ var scope = \u0026quot;local scope\u0026quot;; function f(){ return scope; } return f; } checkscope()(); 首先代码A和代码B 都会打印 localscope，具体原因在上一篇作用域中有解释\n但不同的是A和B的执行上下文的顺序不同\n伪代码是这样的\n//代码A ECStack.push(\u0026lt;checkscope\u0026gt; functionContext) ECStack.push(\u0026lt;f\u0026gt; functionContext) ECStack.pop() //f 执行结束 ECStack.pop() //checkscope 执行结束 //代码B ECStack.push(\u0026lt;checkscope\u0026gt; functionContext) ECStack.pop() //checkcope 执行结束 ECStack.push(\u0026lt;f\u0026gt; functionContext) ECStack.pop() //f 执行结束 ","description":"","id":2,"section":"restart-js","tags":["js基础","学习笔记"],"title":"从头学习js-3-执行上下文栈","uri":"http://llane00.github.io/restart-js/3-%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E6%A0%88/"},{"content":" 这个系列是我看冴羽老师的博客的理解笔记\n博客原文\n 作用域是程序如何储存和获取变量的约定\njavascript采用了词法作用域（即静态作用域）\n静态作用域在函数创建的时候就记下了，会在函数代码的书写位置层级向上查找变量\n动态作用域在函数调用的时候才决定，会在函数调用栈中依次向上查找变量\nvar value = 1; function foo() { console.log(value); } function bar() { var value = 2; foo(); } bar(); 以上代码在静态作用域情况下会打印1\n在动态作用域情况下会打印2\n","description":"","id":3,"section":"restart-js","tags":["js基础","学习笔记"],"title":"从头学习js-2-作用域","uri":"http://llane00.github.io/restart-js/2-%E4%BD%9C%E7%94%A8%E5%9F%9F/"},{"content":"normal 模式\ninsert 模式\nvisual 模式\ncontrol + [ 从insert/visual回到normal\nesc 也是从insert/visual回到normal\nnormal 模式下 hjkl 移动光标左下上右\na 在光标后insert\ni 在光标前insert\nshift + a 在当前行结尾处insert\nshift + i 在当前行开头处insert\ngg 光标跳转到文档第一行\nshift + g 光标跳转到文档最后一行\n: + 行号 + 回车 光标跳转到文行特定的行\n数字 + j/k 光标上下移动指定行数\n数字 + w/b 光标左右移动指定的单词个数\n[[ 光标跳转到文档第一行\n]] 光标跳转到文档最后一行\nshift + { 光标跳转到下一个段落\nshift + } 光标跳转到上一个段落\ncontrol + u 向下翻页\ncontrol + d 向上翻页\n% 用于在 () {} 之间跳转\nzz 将当前行剧中到屏幕中\no 换行insert\nshift + o 在上一行空一行insert\n/ + 字符为搜索 （n 和 shift + n 可以继续上下选择）\nf + 字符 光标定位到字符上（;继续下一个 ,继续上一个）\nt + 字符 光标定位到字符前（;继续下一个 ,继续上一个）\nyy 复制当前行\ndd 剪切当前行（删除）\nshift + d 删除当前行光标后的内容\nshift + d 删除当前行光标后的内容 + insert\np 黏贴内容到当前行的下一行\nshift + p 黏贴内容到当前行的上一行\nu 撤销\nx 删除光标选中内容\ns 删除光标选中内容并insert\nshift + s 删除当前行并insert\ncw 等价于 dwi\nvisual 模式下 v 单个字选择模式\nshift + v 行选择模式\n需要选中缩进的时候，按v(或V)进入visual状态，选择多行，用\u0026gt;或\u0026lt;缩进或缩出\n使用v来选中删除\nv+d\nv+x\nv+s\nV+G 会选中当前行到最后一行的内容\ncontrol + v 可以进入visual block模式可以按块来选内容\n例子：\n批量删除每一行开头的-app-\ncontrol + v + GIf-d\n如果要批量插入，每一行开头加入-web-\ncontrol + v + GI-web-\n\u0026ndash;\n实用例子： part 1: dt) 删除)前的所有内容\nvf) 选中到)的所有内容包括右括号\nyt) 复制到)前的内容\nct; 删除到;前的所有内容并insert\nciw 删除当前光标所在的单词 change in word\nci\u0026quot; 删除当前光标最近的\u0026quot;\u0026ldquo;里的内容\npart 2: 四种删除if花括号内容的办法（初始光标在if下一行）：\nif { delete me haha wow ya } 1.shift + v 3j d\n2.d 4 d\n3.d i {\n4.d 2 i {\npart 3: \u0026ldquo;testdfat\u0026rdquo;\n假设光标停留在第一个t位置\ndi\u0026rdquo;：delete all content inside \u0026ldquo;，结果字符串为\u0026rdquo;\u0026quot;\ndta：delete all content to a，结果字符串为\u0026quot;at\u0026quot;\ndfa：delete all content from current location, until a is found，结果字符串为\u0026quot;t\u0026quot;\n在vim中的特殊处理（在vscode插件中无效）： 当在visual模式下选中内容按下:可以对选中的多个行做批处理\n比如选中后 :+normal A.png+回车\n会在每个选中行后加上.png的内容\n分享一下我的vimrc配置 https://github.com/Llane00/my-configs/blob/main/.vimrc\n在安装vim 插件时遇到的问题：\n1.you-complete-me无法安装，原因是其中一个依赖在google资源下，那么可以去官方github issue中查找，替换依赖路径\n2.还是ycm插件，首先需要去vim plugin目录下找到you-complete-me目录，找到install.py，手动去安装python3 install.py\n然后安装时发现缺少cmake，那么就另外brew install cmake\n3.完成安装后由于我的电脑上默认的vim版本太旧了，不支持最新的python3提示ycm有报错（没错还是这个插件），\n我重新用brew 安装了vim brew install vim, 下载完毕后需要在zshrc中加一个alias把vim和vi命令指向到brew新下载的vim下\n可以通过brew list vim去找vim下载的地址,这里只要vim和vi对应的地址\n在.zshrc中加入下面两行\nalias vim='/usr/local/xxx/xxx/vim' alias vi='/usr/local/xxx/xxx/vi' 保存并source zshrc后就可以生效使用新的vim了\nyou-complete-me不亏为最难安装的vim 插件\n","description":"","id":4,"section":"posts","tags":["学习笔记"],"title":"Vim使用笔记","uri":"http://llane00.github.io/posts/vim%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/"},{"content":" 这个系列是我看冴羽老师的博客的理解笔记\n博客原文\n function Person() {} let Neo = new Person() Person 是一个构造函数\nNeo是构造函数Person创建的一个实例\n首先所有的函数都有一个prototype属性\nPerson.prototype 代表的是调用Person构造函数创建的实例的原型\n（即Person.prototype是Neo的原型）\n而js中的对象也有指向原型的属性 __proto__\n所以 Person.prototype === Neo.__proto__\n另外原型也有属性constructor可以指向其对应的构造函数\nPerson.prototype.constructor === Person\n原型和原型链是js实现继承的基础\n原型也是一个js对象，所以原型也有__proto__属性\n原型对象其实是构造函数Object创建的一个实例，所以原型的__proto__指向的是Object.prototype\n当在调用一个对象的属性或方法时，如果该对象没有这个属性或方法，此时会去自动找他的原型是否有，如果还是没有则会继续向原型的原型去找，不断重复直到Object.prototype.__proto__，而Object.prototype.__proto__为null(即Object.prototype 没有原型)\n这个向上自动搜索父级原型的过程就是原型链的体现\n即如果Neo没有toString方法，通过原型链\nNeo.toString() 依然可以执行，因为Object有toString方法\n换言之通过原型链Neo可以“获得”Object的所有属性和方法\n我过去经常会困惑函数是个什么东西，它是怎么储存的\n从变量的类型看，分为基本类型和引用类型\n所以函数只能是以引用类型中的对象形式储存的\n那构造函数Person也是一个对象，\n它的__proto__指向了它的原型Function.prototype\n(所有构造函数的上一级原型都是Function.prototype)\n即：\nPerson.__proto__ === Function.prototype\nFunction.prototype.__proto__ === Object.prototype\n同时构造函数Object的上一级原型也是Function.prototype\n我们整理一下： 所有对象的最终原型都是 Object.prototype\n函数的原型是 -\u0026gt; Function.prototype 的原型是 -\u0026gt; Object.prototype 没有原型\n构造函数Object的原型是Function.prototype\nPerson.__proto__ === Function.prototype Function.prototype.__proto__ === Object.prototype Object.__proto__ === Function.prototype 之前看到过一个看上去很奇怪的事情，\nFunction.__proto__ === Function.prototype\n目前可以用上面的结论解释：所有（构造）函数的上一级原型都是Function.prototype\n","description":"","id":5,"section":"restart-js","tags":["js基础","学习笔记"],"title":"从头学习js-1-原型与原型链","uri":"http://llane00.github.io/restart-js/1-%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/"},{"content":"大招技能有冷却 == 节流（throttle） /** * 节流原理：在一定时间内，只能触发一次 * * @param {Function} func 要执行的回调函数 * @param {Number} wait 延时的时间 * @param {Boolean} immediate 是否立即执行 * @return null */ let timeout, flag; function throttle(func, wait = 500, immediate = true) { if (immediate) { if (!flag) { flag = true; // 如果是立即执行，则在wait毫秒内开始时执行 typeof func === 'function' \u0026amp;\u0026amp; func(); timeout = setTimeout(() =\u0026gt; { flag = false; }, wait); } } else { if (!flag) { flag = true // 如果是非立即执行，则在wait毫秒内的结束处执行 timeout = setTimeout(() =\u0026gt; { flag = false typeof func === 'function' \u0026amp;\u0026amp; func(); }, wait); } } }; export default throttle 吟唱技能防打断 == 防抖（debounce） /** * 防抖原理：一定时间内，只有最后一次操作，再过wait毫秒后才执行函数 * * @param {Function} func 要执行的回调函数 * @param {Number} wait 延时的时间 * @param {Boolean} immediate 是否立即执行 * @return null */ let timeout = null; function debounce(func, wait = 500, immediate = false) { // 清除定时器 if (timeout !== null) clearTimeout(timeout); // 立即执行，此类情况一般用不到 if (immediate) { var callNow = !timeout; timeout = setTimeout(() =\u0026gt; { timeout = null; }, wait); if (callNow) typeof func === 'function' \u0026amp;\u0026amp; func(); } else { // 设置定时器，当最后一次操作后，timeout不会再被清除，所以在延时wait毫秒后执行func回调方法 timeout = setTimeout(() =\u0026gt; { typeof func === 'function' \u0026amp;\u0026amp; func(); }, wait); } } export default debounce ","description":"","id":6,"section":"posts","tags":["js基础","学习笔记"],"title":"javascript实现节流和防抖","uri":"http://llane00.github.io/posts/js%E8%8A%82%E6%B5%81%E5%92%8C%E9%98%B2%E6%8A%96/"},{"content":"关于Js原型 // 例子 function Person() { } var person = new Person(); console.log(person.__proto__ == Person.prototype) // true console.log(Person.prototype.constructor == Person) // true // 顺便学习一个ES5的方法,可以获得对象的原型 console.log(Object.getPrototypeOf(person) === Person.prototype) // true 实例与原型 当读取实例的属性时，如果找不到，就会查找与对象关联的原型中的属性，如果还查不到，就去找原型的原型，一直找到最顶层为止。\n原型的原型 原型也是一个对象，原型对象就是通过 Object 构造函数生成的\n由于实例的 proto 指向构造函数的 prototype ，\n所以Person.prototype.proto == Object.prototype\n而再往上Object.prototype.proto == null\n补充   关于constructor: 当获取 person.constructor 时，其实 person 中并没有 constructor 属性,当不能读取到constructor 属性时，会从 person 的原型也就是 Person.prototype 中读取，正好原型中有该属性，所以：\nperson.constructor === Person.prototype.constructor\n  关于__proto__: 绝大部分浏览器都支持这个非标准的方法访问原型，然而它并不存在于 Person.prototype 中，实际上，它是来自于 Object.prototype ，与其说是一个属性，不如说是一个 getter/setter，当使用 obj.__proto__ 时，可以理解成返回了 Object.getPrototypeOf(obj)。\n  关于js的“继承”: 继承意味着复制操作，然而 JavaScript 默认并不会复制对象的属性，相反，JavaScript 只是在两个对象之间创建一个关联，这样，一个对象就可以通过委托访问另一个对象的属性和函数，所以与其叫继承，委托的说法反而更准确些。\n  所有的函数都是 Function 的实例\n  参考资料:  JavaScript深入之从原型到原型链  ","description":"","id":7,"section":"posts","tags":["js基础","学习笔记"],"title":"Js原型","uri":"http://llane00.github.io/posts/js%E5%8E%9F%E5%9E%8B/"},{"content":"常见的定位方案 普通流(normal flow) 在普通流中，元素按照其在HTML中的先后位置至上而下布局，在这个过程中，行内元素水平排列，直到一行被占满后换行，块级元素则会被渲染为完整的一个新行，除非另外指定，否则所有元素默认都是普通流定位。也可以说，普通流中元素的位置由该元素在HTML文档中的位置决定。\n浮动(float) 在浮动布局中，元素首先按照普通流的位置出现，然后根据浮动的方向尽可能的向左边或向右边偏移，其效果与印刷排版中的文本环绕相似。\n绝对定位(absolute position) 在绝对定位布局中，元素会整体脱离普通流，因此绝对定位元素不会对其兄弟元素造成影响，而元素具体的位置由绝对定位的坐标决定。\nBFC 概念 Formatting context（格式化上下文）是W3C CSS2.1 规范中的一个概念。它是页面中的一块渲染区域，并且有一套渲染规则，它决定了其子元素将如何定位，以及和其他元素的关系和相互作用。\nBFC 即 Block Formatting Contexts (块级格式化上下文)，它属于上述定位方案的普通流。\n具有 BFC 特性的元素可以看作是隔离了的独立容器，容器里面的元素不会在布局上影响到外面的元素，并且 BFC 具有普通容器所没有的一些特性。\n通俗一点来讲，可以把 BFC 理解为一个封闭的大箱子，箱子内部的元素无论如何翻江倒海，都不会影响到外部。\nBFC 的触发条件 只要元素满足下面任一条件即可触发 BFC 特性：\n body 根元素 浮动元素：float 除 none 以外的值 绝对定位元素：position (absolute、fixed) display 为 inline-block、table-cells、flex overflow 除了 visible 以外的值 (hidden、auto、scroll)  BFC 的应用  同一个 BFC 下外边距会发生折叠。如果想要避免外边距的重叠，可以将其放在不同的 BFC 容器中。 BFC 可以包含浮动的元素（清除浮动），防止浮动造成高度坍塌。 BFC 可以阻止元素被浮动元素覆盖  参考资料:  10 分钟理解 BFC 原理 CSS盒模型完整介绍  ","description":"","id":8,"section":"posts","tags":["css基础","学习笔记"],"title":"重新理解BFC","uri":"http://llane00.github.io/posts/%E9%87%8D%E6%96%B0%E7%90%86%E8%A7%A3bfc/"},{"content":"背景： 在 JavaScript 里面，数字均为双精度浮点类型，即一个介于±2−1023和±2+1024之间的数字，或约为±10−308到±10+308，数字精度为53位。整数数值仅在±(253 - 1)的范围内可以表示准确。\nJS 的最大和最小安全值可以这样获得:\nconsole.log(Number.MAX_SAFE_INTEGER); //9007199254740991 console.log(Number.MIN_SAFE_INTEGER); //-9007199254740991 通过下面的例子，你会明白为什么大于这个值的运算是不安全的:\nvar x = 9223372036854775807; console.log(x === x + 1);// output: true console.log(x === x + 1000); //output: true 用js实现正整数大数相加： //用字符串表示大数 let x = \u0026quot;9007199254740991\u0026quot;; //Number.MAX_SAFE_INTEGER let y = \u0026quot;99999999999999999999\u0026quot;; //20位大数 function bigNumberAdd(x, y) { //为了把两个数字从个位开始相加，需要补齐位数较小的数，让两个数的位数相等 let maxLength = Math.max(x.length, y.length); //用0补齐位数 x = x.padStart(maxLength, 0); y = y.padStart(maxLength, 0); let carryOver = 0; //进位 let resultStr = \u0026quot;\u0026quot;; //最终计算结果 for (let i = maxLength - 1; i \u0026gt;= 0; i--) { let digitSum = parseInt(x[i]) + parseInt(y[i]) + carryOver; let currentDigit = digitSum % 10; //取个位 carryOver = Math.floor(digitSum / 10); //取进位 resultStr = currentDigit + resultStr; } //如果进位还有1 if (carryOver == 1) { resultStr = \u0026quot;1\u0026quot; + resultStr; } return resultStr; } ","description":"","id":9,"section":"posts","tags":["js基础","学习笔记"],"title":"Js大数相加","uri":"http://llane00.github.io/posts/js%E5%A4%A7%E6%95%B0%E7%9B%B8%E5%8A%A0/"},{"content":"这次推荐的压缩工具是 optimizt\n稍微看了下，算是一个压缩图片的工具合集\n安装optimizt npm i -g @funboxteam/optimizt 也支持WebStorm, PhpStorm等插件\n also support External Tool in WebStorm, PhpStorm, etc\n DIY一下 optimizt 支持用find命令查找图片\noptimizt `find . -type f -name '*.jpg'` 于是我在.bash_profile（或者其他Shell配置文件）中添加别名 + 自定义的搜索方式\nalias yasuo='optimizt `find . -name \u0026quot;*.png\u0026quot; -o -name \u0026quot;*.jpg\u0026quot; -o -name \u0026quot;*.jpeg\u0026quot; -o -name \u0026quot;*.gif\u0026quot; -o -name \u0026quot;*.svg\u0026quot;`' 这个命令可以压缩当前目录下所有找到的jpg/jpeg/png/gif/svg后缀的图片（支持多层目录迭代查找）\n加入参数 -l 后lossless可无损压缩\nalias yasuo2='optimizt -l `find . -name \u0026quot;*.png\u0026quot; -o -name \u0026quot;*.jpg\u0026quot; -o -name \u0026quot;*.jpeg\u0026quot; -o -name \u0026quot;*.gif\u0026quot; -o -name \u0026quot;*.svg\u0026quot;`' more:\n最后推荐一波自制命令行查看天气工具 llane-weather\n效果如下：\n如果觉得有趣或者有帮助的可以点下github的star，觉得不好用的也可以直接留言告诉我。\n","description":"","id":10,"section":"posts","tags":["命令行"],"title":"使用命令行快速压缩图片","uri":"http://llane00.github.io/posts/%E4%BD%BF%E7%94%A8%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%BF%AB%E9%80%9F%E5%8E%8B%E7%BC%A9%E5%9B%BE%E7%89%87/"}]