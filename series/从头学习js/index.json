[{"content":"function Person() {} let Neo = new Person() Person 是一个构造函数\nNeo是构造函数Person创建的一个实例\n首先所有的函数都有一个prototype属性\nPerson.prototype 代表的是调用Person构造函数创建的实例的原型（在这里即Neo的原型）\n而js中的对象也有指向原型的属性 __proto__\n所以 Person.prototype === Neo.__proto__ (他们会指向同一个原型)\n另外原型也有属性constructor可以指向其对应的构造函数\nPerson.prototype.constructor === Person\n原型和原型链是js实现继承的基础\n原型也是一个js对象，所以原型也有__proto__属性\n原型对象其实是构造函数Object创建的，所以原型的__proto__指向的是Object.prototype\n当在调用一个对象的属性或方法时，如果该对象没有这个属性或方法，此时会去自动找他的原型是否有，如果还是没有则会继续向原型的原型去找，不断重复直到Object.prototype.__proto__，而Object.prototype.__proto__为null(即Object.prototype 没有原型)\n这个向上自动搜索父级原型的过程就是原型链的体现\n即如果Neo没有toString方法，通过原型链\nNeo.toString() 依然可以执行，因为Object有toString方法\n换言之通过原型链Neo可以“获得”Object的所有属性和方法\n我经常会困惑函数是个什么东西，它是怎么储存的\n从变量的类型看，分为基本类型和引用类型\n函数应该是以引用类型中的对象形式储存的\n所以构造函数Person也是一个对象，它的__proto__指向了它的原型Function.prototype(所有构造函数的上一级原型都是Function.prototype)\n即Person.__proto__ === Function.prototype\nFunction.prototype.__proto__ === Object.prototype\n同时构造函数Object的上一级原型也是Function.prototype\n我们整理一下： 对象的最终原型是 Object.prototype\n函数的原型是 -\u0026gt; Function.prototype 的原型是 -\u0026gt; Object.prototype 没有原型\n构造函数Object的原型是Function.prototype\nPerson.__proto__ === Function.prototype Function.prototype.__proto__ === Object.prototype Object.__proto__ === Function.prototype 之前看到过一个看上去很奇怪的事情，\nFunction.__proto__ === Function.prototype\n目前可以用上面的结论解释：所有函数的上一级原型都是Function.prototype\n参考资料:\nJavaScript深入之从原型到原型链\n","description":"","id":0,"section":"posts","tags":["js基础","学习笔记"],"title":"从头学习js-1-js原型与原型链","uri":"http://llane00.github.io/posts/restart_js_1_js%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/"},{"content":"大招技能有冷却 == 节流（throttle） /** * 节流原理：在一定时间内，只能触发一次 * * @param {Function} func 要执行的回调函数 * @param {Number} wait 延时的时间 * @param {Boolean} immediate 是否立即执行 * @return null */ let timeout, flag; function throttle(func, wait = 500, immediate = true) { if (immediate) { if (!flag) { flag = true; // 如果是立即执行，则在wait毫秒内开始时执行 typeof func === 'function' \u0026amp;\u0026amp; func(); timeout = setTimeout(() =\u0026gt; { flag = false; }, wait); } } else { if (!flag) { flag = true // 如果是非立即执行，则在wait毫秒内的结束处执行 timeout = setTimeout(() =\u0026gt; { flag = false typeof func === 'function' \u0026amp;\u0026amp; func(); }, wait); } } }; export default throttle 吟唱技能防打断 == 防抖（debounce） /** * 防抖原理：一定时间内，只有最后一次操作，再过wait毫秒后才执行函数 * * @param {Function} func 要执行的回调函数 * @param {Number} wait 延时的时间 * @param {Boolean} immediate 是否立即执行 * @return null */ let timeout = null; function debounce(func, wait = 500, immediate = false) { // 清除定时器 if (timeout !== null) clearTimeout(timeout); // 立即执行，此类情况一般用不到 if (immediate) { var callNow = !timeout; timeout = setTimeout(() =\u0026gt; { timeout = null; }, wait); if (callNow) typeof func === 'function' \u0026amp;\u0026amp; func(); } else { // 设置定时器，当最后一次操作后，timeout不会再被清除，所以在延时wait毫秒后执行func回调方法 timeout = setTimeout(() =\u0026gt; { typeof func === 'function' \u0026amp;\u0026amp; func(); }, wait); } } export default debounce ","description":"","id":1,"section":"posts","tags":["js基础","学习笔记"],"title":"javascript实现节流和防抖","uri":"http://llane00.github.io/posts/js%E8%8A%82%E6%B5%81%E5%92%8C%E9%98%B2%E6%8A%96/"},{"content":"关于Js原型 // 例子 function Person() { } var person = new Person(); console.log(person.__proto__ == Person.prototype) // true console.log(Person.prototype.constructor == Person) // true // 顺便学习一个ES5的方法,可以获得对象的原型 console.log(Object.getPrototypeOf(person) === Person.prototype) // true 实例与原型 当读取实例的属性时，如果找不到，就会查找与对象关联的原型中的属性，如果还查不到，就去找原型的原型，一直找到最顶层为止。\n原型的原型 原型也是一个对象，原型对象就是通过 Object 构造函数生成的\n由于实例的 proto 指向构造函数的 prototype ，\n所以Person.prototype.proto == Object.prototype\n而再往上Object.prototype.proto == null\n补充   关于constructor: 当获取 person.constructor 时，其实 person 中并没有 constructor 属性,当不能读取到constructor 属性时，会从 person 的原型也就是 Person.prototype 中读取，正好原型中有该属性，所以：\nperson.constructor === Person.prototype.constructor\n  关于__proto__: 绝大部分浏览器都支持这个非标准的方法访问原型，然而它并不存在于 Person.prototype 中，实际上，它是来自于 Object.prototype ，与其说是一个属性，不如说是一个 getter/setter，当使用 obj.__proto__ 时，可以理解成返回了 Object.getPrototypeOf(obj)。\n  关于js的“继承”: 继承意味着复制操作，然而 JavaScript 默认并不会复制对象的属性，相反，JavaScript 只是在两个对象之间创建一个关联，这样，一个对象就可以通过委托访问另一个对象的属性和函数，所以与其叫继承，委托的说法反而更准确些。\n  参考资料:\n JavaScript深入之从原型到原型链  ","description":"","id":2,"section":"posts","tags":["js基础","学习笔记"],"title":"Js原型","uri":"http://llane00.github.io/posts/js%E5%8E%9F%E5%9E%8B/"},{"content":"常见的定位方案 普通流(normal flow) 在普通流中，元素按照其在HTML中的先后位置至上而下布局，在这个过程中，行内元素水平排列，直到一行被占满后换行，块级元素则会被渲染为完整的一个新行，除非另外指定，否则所有元素默认都是普通流定位。也可以说，普通流中元素的位置由该元素在HTML文档中的位置决定。\n浮动(float) 在浮动布局中，元素首先按照普通流的位置出现，然后根据浮动的方向尽可能的向左边或向右边偏移，其效果与印刷排版中的文本环绕相似。\n绝对定位(absolute position) 在绝对定位布局中，元素会整体脱离普通流，因此绝对定位元素不会对其兄弟元素造成影响，而元素具体的位置由绝对定位的坐标决定。\nBFC 概念 Formatting context（格式化上下文）是W3C CSS2.1 规范中的一个概念。它是页面中的一块渲染区域，并且有一套渲染规则，它决定了其子元素将如何定位，以及和其他元素的关系和相互作用。\nBFC 即 Block Formatting Contexts (块级格式化上下文)，它属于上述定位方案的普通流。\n具有 BFC 特性的元素可以看作是隔离了的独立容器，容器里面的元素不会在布局上影响到外面的元素，并且 BFC 具有普通容器所没有的一些特性。\n通俗一点来讲，可以把 BFC 理解为一个封闭的大箱子，箱子内部的元素无论如何翻江倒海，都不会影响到外部。\nBFC 的触发条件 只要元素满足下面任一条件即可触发 BFC 特性：\n body 根元素 浮动元素：float 除 none 以外的值 绝对定位元素：position (absolute、fixed) display 为 inline-block、table-cells、flex overflow 除了 visible 以外的值 (hidden、auto、scroll)  BFC 的应用  同一个 BFC 下外边距会发生折叠。如果想要避免外边距的重叠，可以将其放在不同的 BFC 容器中。 BFC 可以包含浮动的元素（清除浮动），防止浮动造成高度坍塌。 BFC 可以阻止元素被浮动元素覆盖  内容参考:\n 10 分钟理解 BFC 原理 CSS盒模型完整介绍  ","description":"","id":3,"section":"posts","tags":["css基础","学习笔记"],"title":"重新理解BFC","uri":"http://llane00.github.io/posts/%E9%87%8D%E6%96%B0%E7%90%86%E8%A7%A3bfc/"},{"content":"背景： 在 JavaScript 里面，数字均为双精度浮点类型，即一个介于±2−1023和±2+1024之间的数字，或约为±10−308到±10+308，数字精度为53位。整数数值仅在±(253 - 1)的范围内可以表示准确。\nJS 的最大和最小安全值可以这样获得:\nconsole.log(Number.MAX_SAFE_INTEGER); //9007199254740991 console.log(Number.MIN_SAFE_INTEGER); //-9007199254740991 通过下面的例子，你会明白为什么大于这个值的运算是不安全的:\nvar x = 9223372036854775807; console.log(x === x + 1);// output: true console.log(x === x + 1000); //output: true 用js实现正整数大数相加： //用字符串表示大数 let x = \u0026quot;9007199254740991\u0026quot;; //Number.MAX_SAFE_INTEGER let y = \u0026quot;99999999999999999999\u0026quot;; //20位大数 function bigNumberAdd(x, y) { //为了把两个数字从个位开始相加，需要补齐位数较小的数，让两个数的位数相等 let maxLength = Math.max(x.length, y.length); //用0补齐位数 x = x.padStart(maxLength, 0); y = y.padStart(maxLength, 0); let carryOver = 0; //进位 let resultStr = \u0026quot;\u0026quot;; //最终计算结果 for (let i = maxLength - 1; i \u0026gt;= 0; i--) { let digitSum = parseInt(x[i]) + parseInt(y[i]) + carryOver; let currentDigit = digitSum % 10; //取个位 carryOver = Math.floor(digitSum / 10); //取进位 resultStr = currentDigit + resultStr; } //如果进位还有1 if (carryOver == 1) { resultStr = \u0026quot;1\u0026quot; + resultStr; } return resultStr; } ","description":"","id":4,"section":"posts","tags":["js基础","学习笔记"],"title":"Js大数相加","uri":"http://llane00.github.io/posts/js%E5%A4%A7%E6%95%B0%E7%9B%B8%E5%8A%A0/"},{"content":"这次推荐的压缩工具是 optimizt\n稍微看了下，算是一个压缩图片的工具合集\n安装optimizt npm i -g @funboxteam/optimizt 也支持WebStorm, PhpStorm等插件\n also support External Tool in WebStorm, PhpStorm, etc\n DIY一下 optimizt 支持用find命令查找图片\noptimizt `find . -type f -name '*.jpg'` 于是我在.bash_profile（或者其他Shell配置文件）中添加别名 + 自定义的搜索方式\nalias yasuo='optimizt `find . -name \u0026quot;*.png\u0026quot; -o -name \u0026quot;*.jpg\u0026quot; -o -name \u0026quot;*.jpeg\u0026quot; -o -name \u0026quot;*.gif\u0026quot; -o -name \u0026quot;*.svg\u0026quot;`' 这个命令可以压缩当前目录下所有找到的jpg/jpeg/png/gif/svg后缀的图片（支持多层目录迭代查找）\n加入参数 -l 后lossless可无损压缩\nalias yasuo2='optimizt -l `find . -name \u0026quot;*.png\u0026quot; -o -name \u0026quot;*.jpg\u0026quot; -o -name \u0026quot;*.jpeg\u0026quot; -o -name \u0026quot;*.gif\u0026quot; -o -name \u0026quot;*.svg\u0026quot;`' more:\n最后推荐一波自制命令行查看天气工具 llane-weather\n效果如下：\n如果觉得有趣或者有帮助的可以点下github的star，觉得不好用的也可以直接留言告诉我。\n","description":"","id":5,"section":"posts","tags":["命令行"],"title":"使用命令行快速压缩图片","uri":"http://llane00.github.io/posts/%E4%BD%BF%E7%94%A8%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%BF%AB%E9%80%9F%E5%8E%8B%E7%BC%A9%E5%9B%BE%E7%89%87/"}]