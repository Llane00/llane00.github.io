[{"content":" 我想知道这是为什么 \u0026ndash;费曼\n 从有序序列的尾部开始，逐个与目标元素比较，如果大于该元素，该元素需要后移\n核心是如何在有序序列里找到正确的插入位置\n缓存目标元素，从有序序列尾部开始逐个比较，\n如果当前序列的数字大于目标元素则把当前序列的数字后移到目标元素的位置上（目标元素的值已经缓存了，同时后移后当前序列数字的位置变为空），\n继续逐个比较，如果目标元素大于当前序列数字，当前序列数字就后移\n如果小于等于当前序列数字就把目标元素插入 上一次移动序列数字后的空位里\n1 2 3 4 5 6 7 8 9 10 11 12  function insertionSort(array) { for (let i = 0; i \u0026lt; array.lenth; i++) { let j = i; let target = array[j]; while(j\u0026gt;0 \u0026amp;\u0026amp; array[j-1] \u0026gt; target) { array[j] = array[j-1]; j--; } array[j] = target; } return array; }   我创建了一个集合jest可以测试算法的靶场项目：\nhttps://github.com/Llane00/algorithm-range-tests\n后续的文章将同步代码到这个项目下\n使用vscode的读者可以安装拓展插件jest，这个插件可以自动检测test文件自动运行，非常方便。\n感谢老姚的文章 原文：手写算法并记住它：插入排序\n","description":"","id":0,"section":"algorithm","tags":["算法基础","学习笔记"],"title":"菜鸟学算法-4-插入排序","uri":"http://llane00.github.io/algorithm/4-%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/"},{"content":" 这个系列是我读冴羽老师博客的感悟，\n加入了个人的解读和练习题的解答\n 本文会介绍不同创建对象的方法，来探究不同解决方案的优缺点\n1.工厂模式 创建一个全新的对象，然后给它加上属性和方法，最后返回这个对象\n1 2 3 4 5 6 7 8  function createPerson(name){ var obj = new Object(); obj.name = name; obj.getName = function () { console.log(this.name) }; return obj }   优点：简单直接\n缺点：对象无法识别，所有实例的原型全都直接指向Object.prototype\n2.构造函数模式 创建一个构造函数，然后利用new来创建其实例\n1 2 3 4 5 6 7 8  function Person(name) { this.name = name; this.getName = function (){ console.log(this.name); } } let Neo2 = new Person(\u0026#34;Neo\u0026#34;);   优点：所有实例能归类为一个特定的原型了\n缺点：每次创建实例时，每个方法都要被创建一次，而实际上每个实例用的方法是一样的，这造成了不必要的数据重复\n2.1构造函数模式优化 我们尝试解决2中的缺点，很容易想到去把构造函数里的方法抽出来，然后只要把构造函数的方法指向抽出的方法就好了\n1 2 3 4 5 6 7 8 9 10  function getName() { console.log(this.name) } function Person(name) { this.name = name; this.getName = getName; } let Neo2 = new Person(\u0026#34;Neo\u0026#34;)   优点：不用额外生成重复的方法对象了，方法可以抽出去了\n缺点：因为方法被抽出去了，失去了封装性\n3.原型模式 尝试把属性和方法都加到构造函数的原型上去，再利用new 构造函数来批量创建对象\n1 2 3 4 5 6 7 8  function Person(name){} Person.prototype.name = \u0026#34;Neo\u0026#34;; Person.prototype.getName = function(){ console.log(this.name) // } let Neo3 = new Person()   优点：解决了在创建多个对象的时候不会创建重复的方法对象\n缺点：构造函数不能接受实例初始化参数name，且所有在原型上的属性和方法都会被共享（没有封装性）\n3.1原型模式优化 1 2 3 4 5 6 7 8 9 10  function Person(name){} Person.prototype = { name: \u0026#34;Neo\u0026#34;, getName: function(){ console.log(this.name) } } let Neo3 = new Person()   优点：把对原型的赋值过程封装化了\n缺点：直接赋值构造函数的原型，使得原型的constructor属性丢失\n3.2原型模式再优化 1 2 3 4 5 6 7 8 9 10 11  function Person(name) {} Person.prototype = { constructor: Person, name: \u0026#34;Neo\u0026#34;, getName: function() { console.log(this.name) } } let Neo3 = new Person()   优点：这次可以补全丢失了constructor属性了\n缺点：依旧不能初始化参数，对new出来的实例也没有解决必须共享所有属性和方法问题\n4.组合模式 结合构造模式和原型模式的优点\n1 2 3 4 5 6 7 8 9 10 11 12  function Person(name) { this.name = name; } Person.prototype = { constructor: Person, getName: function() { console.log(this.name) } } let Neo4 = new Person(\u0026#34;Neo\u0026#34;)   优点：可以初始化，不用重复生成相同的函数对象\n缺点：结构上必须分为两个部分\n4.1动态原型模式 1 2 3 4 5 6 7 8 9 10  function Person(name){ this.name = name; if(typeof this.getName != \u0026#34;function\u0026#34;) { Person.prototype.getName = fucntion() { console.log(this.name) } } } var person1 = new Person(\u0026#34;Neo\u0026#34;);   注意：使用动态原型模式时，不能用对象字面量重写原型\n如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  function Person(name) { this.name = name; if (typeof this.getName != \u0026#34;function\u0026#34;) { //此处直接用用对象字面量重写原型，将会引发错误  Person.prototype = { constructor: Person, getName: function () { console.log(this.name); } } } } var person1 = new Person(\u0026#39;kevin\u0026#39;); var person2 = new Person(\u0026#39;daisy\u0026#39;); // 报错 并没有该方法 person1.getName(); // 注释掉上面的代码，这句是可以执行的。 person2.getName();   我们来一步步分析原因，\nnew Person(\u0026lsquo;kevin\u0026rsquo;)后发生的事：\n1.创建一个新对象\n2.把对象的原型指向Person.prototype\n3.执行 Person.apply(obj)\n4.返回对象\n其中第3步，Person.apply(obj),\n将会执行obj.Person\n由于首次时obj.getName不是function，于是执行if语句 此时obj.prototype存的是Person.prototype的地址指针x（第2步的执行结果） 把Person.prototype重新赋值意味着Person.prototype重新赋值了一个新对象的地址y\n动态原型模式为什么不能直接赋值\u0026ndash;示例demo：\n1 2 3 4 5 6 7 8 9 10 11 12 13  let obj = { name: \u0026#34;obj\u0026#34; }; let per = obj; //这里per存的是对象obj的地址  //obj重新赋值为一个新对象的地址 obj = { age: 20 }; // obj { age:20 } //新对象的地址 // per { name:\u0026#34;obj\u0026#34; } //还是指向旧obj的地址   结果：\nobj.prototype 还是指向旧原型的地址，没有getName\nPerson.prototype 指向新的对象，有getName方法\n// 报错 person1的原型指向旧原型，并没有getName方法\nperson1.getName();\n// person2的原型指向新原型对象，有getName方法\nperson2.getName();\n那可以修改代码为\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  function Person(name) { this.name = name; if (typeof this.getName != \u0026#34;function\u0026#34;) { Person.prototype = { constructor: Person, getName: function() { console.log(this.name) } } } //用最新的Person.property再次生成对象返回，构造函数如果返回到是对象，直接返回这个对象  return new Person(name); }   5.1 寄生构造函数模式 先看代码\n1 2 3 4 5 6 7 8 9 10 11 12 13  function Person(name) { var o = new object(); o.name = name; o.getName = function() { console.log(this.name) }; return o; //构造函数如果返回到是对象，直接返回这个对象，o是object的一个实例和Person类没有关系，https://www.cnblogs.com/kenanyah/p/13246934.html } var person1 = new Person(\u0026#34;Neo\u0026#34;) console.log(person1 instanceOf Person) // false 实例无法指向构造函数 console.log(Person1 instanceOf Object) //true   创建出来的实例对象无法指向构造函数，只是寄生在构造函数里的工厂模式，和工厂模式不同的是它可以调用new来创建实例\n5.2 稳妥构造函数模式 1 2 3 4 5 6 7 8 9 10 11 12 13  function person(name) { var o = new Object(); o.getName = function() { console.log(name); } return o; } var person1 = person(\u0026#34;Neo\u0026#34;) person1.getName(); //Neo person1.name = \u0026#34;Llane\u0026#34;; person1.getName(); //Neo console.log(person1.name); //Llane   所谓稳妥对象，指的是没有公共属性，其方法也不引用this的对象\n与寄生构造函数模式有两点不同：\n1.新创建的实例方法不引用this\n2.不使用new操作符调用构造函数\n稳妥对象适合在一些安全的环境中，\n稳妥构造函数和工厂模式一样，无法识别实例对象所属类型\n","description":"","id":1,"section":"restart-js","tags":["js基础","学习笔记"],"title":"从头学习js-14-创建对象","uri":"http://llane00.github.io/restart-js/14-%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1/"},{"content":"我们可以在React官网-React哲学这里找到React对自己的定义：\n 我们认为，React 是用 JavaScript 构建快速响应的大型 Web 应用程序的首选方式。\n 关键词：快速、大型，\n阻碍快速响应的主要是：CPU的瓶颈与IO的瓶颈\nReact想到的解决办法是用并发的更新(视图)模式来代替现在的同步更新模式\nReact Fiber 架构推出，因为旧的架构没法实现并发更新\n","description":"","id":2,"section":"Reactjs","tags":["React"],"title":"3-React-哲学","uri":"http://llane00.github.io/reactjs/3-react-%E5%93%B2%E5%AD%A6/"},{"content":"从函数的角度来理解hooks的概念 React理念：UI = f(data)\n视图UI会根据自变量变化\n自变量： useState 定义自变量\nuseReducer(复杂版的useState，为了方便操作更多自变量)\nuseContext 为了跨组件操作自变量\n因变量： 定义无副作用的因变量（因变量依赖自变量变化）\nuseMemo 缓存一个因变量(由自变量计算得到的变量)+定义依赖\nuseCallBack 缓存一个函数类型的因变量(实际情况下可能是一个点击响应事件，事件触发后由自变量计算得到因变量)+定义依赖\n定义有副作用的因变量（副作用指的是会导致视图在相同自变量的情况下却出现了不同视图的操作）\nuseEffect 因变量\n标记变量： useRef 标记变量 为了让组件的逻辑更灵活\nmore：\n9分钟掌握React Hooks正确认知\n","description":"","id":3,"section":"Reactjs","tags":["React"],"title":"学习React_hooks_2","uri":"http://llane00.github.io/reactjs/2-react-hooks/"},{"content":" 我想知道这是为什么 \u0026ndash;费曼\n 选择排序，是每次遍历都选最小的一个数交换到已经排好的序列的后面\n5 4 3 2 1\n第一次遍历发现最小的是1\n把5和1交换\n1 4 3 2 5\n第二次遍历从4开始（1已经是排好的序列了）开始发现在（4 3 2 5）里最小的是2\n把4和2交换\n1 2 3 4 5\n第三次遍历从3开始在（3 4 5）里3已经是最小的了，这次不交换\n第四次遍历从4开始，同上发现4也已经是最小的了\n第五次最后这次遍历不用做了，在前面都是从小到大排好序的，最后这个数字就是最大的\n我们开始写代码：\n1 2 3 4 5 6 7 8  //先看在一次遍历里做了什么  let minNumberIndex = 0; for(let i=0; i\u0026lt;array.length; i++){ if(array[i] \u0026lt; array[minNumberIndex]) { minNumberIndex = i; } }   1 2 3 4 5 6 7 8 9 10 11 12 13 14  function selectionSort(array) { for(var j=0; j\u0026lt;array.length - 1; j++) { let minNumberIndex = j; for(let i=j; i\u0026lt;array.length; i++) { if(array[i] \u0026lt; array[minNumberIndex]) { minNumberIndex = i } } if (minNumberIndex !== j) { [array[i], array[minNumberIndex]] = [array[minNumberIndex], array[i]] } } return array; }   选择排序和冒泡排序很类似都是在每一次遍历的时候去找最大或者最小的值，然后把找到的值去（通过交换）排好序列，\n下一次的遍历从余下的数字里进行\n总结：\n选择排序不需要额外空间，是本地排序，相等元素是不会交换前后顺序，因而也是稳定排序，时间复杂度为O(n^2)，适用于少量数据排序，但实际中用得不多\n非常感谢老姚的文章：\n原文：手写算法并记住它：选择排序\n","description":"","id":4,"section":"algorithm","tags":["算法基础","学习笔记"],"title":"菜鸟学算法-3-选择排序","uri":"http://llane00.github.io/algorithm/3-%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/"},{"content":"由于我目前还是用vscode居多，vscode的插件和环境配置对前端开发更加友好，我打算还是在vscode上开发，辅助用vscode+vim的快捷键来搭配使用\n这里推荐一些vscode上的插件：\n1.Vim 记得按照插件文档输入命令然后在vscode的settings中加入默认的一些按键配置，\n不得不说这个jj退出insert模式的快捷键比ESC或者command+c或者command+[ 都要好用\n2.TabOut 可以在insert模式下用tab按键来跳出括号和花括号，实测好用，我居然才知道\nvim对中文输入其实是不太友好的，normal模式下如果此时是拼音输入会很麻烦\ninsert模式下想按jj到normal结果发现现在是拼音模式又得删除jj\n尽管我已经尝试安装了im-select依然还是觉得不便, 可以参考这个知乎上的问题 https://www.zhihu.com/question/303850876\n后续我会尝试把.vimrc 的一些实用快捷键配置结合到vscode中的settings.json\nto be continued \u0026hellip;\n","description":"","id":5,"section":"posts","tags":["学习笔记"],"title":"Vim使用笔记2","uri":"http://llane00.github.io/posts/vim%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B02/"},{"content":" 这个系列是我读冴羽老师博客的感悟，\n加入了个人的解读和练习题的解答\n 类数组 在之前模拟实现apply和bind时我们其实已经遇见过arguments这样的类数组文件了\n1 2 3 4 5 6 7  var array = [\u0026#39;A\u0026#39;, \u0026#39;B\u0026#39;, \u0026#39;C\u0026#39;] var arrayLike = { 0: \u0026#39;A\u0026#39;, 1: \u0026#39;B\u0026#39;, 2: \u0026#39;C\u0026#39;, lenght: 3 }   类数组文件的读取，遍历方式和数组一样\n1 2 3 4 5 6 7 8  array[0] arrayLike[0] array.length arrayLike.length for(var i=0; i\u0026lt;array.length; i++){} for(var i=0; i\u0026lt;arrayLike.length; i++){}   但是类数组终究不是数组不能调用数组的原型方法，比如push、splice、slice\n常用的做法是Array.prototype.splice.call(arrayLike, 2)\n利用call在直接调用Array原型方法的时候把this指向arrayLike对象\n另外经常需要把类数组对象转为数组，方法如下：\n1 2 3 4 5  Array.prototype.slice.call(arrayLike) //slice 用于截取数组从start到end，省略end时默认到数组末尾 Array.prototype.splice.call(arrayLike, 0) //splice 可以插入删除，参数index, deleteNumber, item1,...,itemX Array.prototype.concat.call([], arrayLike) Array.from(arrayLike) //es6 Array.from [...arguments] //es6 拓展运算符   Aruguments对象 在函数体中arguments指代函数的Arguments对象\nAruguments的length，指的是实参的长度\nArguments的callee通过它可以调用函数本身\n1 2 3 4 5 6 7 8 9 10 11 12 13  //用callee来解决之前第8篇中的for循环无法保存i到函数内部的问题  var data = [] for (var i = 0; i\u0026lt; 3; i++) { (data[i] = function(){ console.log(arguments.callee.i) ).i = i } data[0](); //0 data[1](); //1 data[2](); //2   乍一看在for循环中的那部分有点奇怪，我们拆开看\nxxx.i = i 是在xxx的属性i赋值为i\n括号内:\ndata[i] = 某个东西\n(data[i] = 赋值内容).i = i 其实就是\ndata[i].i = i\n接下来看赋值的内容\n是一个函数对象，函数对象在创建的时候不会执行内部的代码\nargument.callee 指的就是 data[i]\nargument.callee.i 自然就是data[i].i\n那因为纯的赋值 = xx 会在for循环里立即执行，所有i的每个状态都会存在对应的data[x]里\narguments 和对应参数的绑定\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  function foo(name, age, sex, hobbit) { console.log(name, arguments[0]); // name name  // 改变形参  name = \u0026#39;new name\u0026#39;; console.log(name, arguments[0]); // new name new name  // 改变arguments  arguments[1] = \u0026#39;new age\u0026#39;; console.log(age, arguments[1]); // new age new age  // 测试未传入的是否会绑定  console.log(sex); // undefined  sex = \u0026#39;new sex\u0026#39;; console.log(sex, arguments[2]); // new sex undefined  arguments[3] = \u0026#39;new hobbit\u0026#39;; console.log(hobbit, arguments[3]); // undefined new hobbit  } foo(\u0026#39;name\u0026#39;, \u0026#39;age\u0026#39;)   传入参数时，实参和arguments的值会共享，没有传入参数时，实参和arguments的值不会共享\n在严格模式下都不会共享\n传递参数\n将参数从一个函数传递到另一个函数\n1 2 3 4 5 6 7 8 9  //利用apply的第二个参数可以直接传一个数组 function foo(){ bar.apply(this, [...arguments]) } function bar(){ console.log(a, b, c) } foo(1, 2, 3)   ","description":"","id":6,"section":"restart-js","tags":["js基础","学习笔记"],"title":"从头学习js-13-类数组对象与arguments","uri":"http://llane00.github.io/restart-js/13-%E7%B1%BB%E6%95%B0%E7%BB%84%E5%AF%B9%E8%B1%A1%E4%B8%8Earguments/"},{"content":" 我想知道这是为什么 \u0026ndash;费曼\n 冒泡排序我想是大部分人接触的第一个排序算法，原理也很形象，\n每一次轮询都会将最大（小）的数字通过一个个相邻比较和交换位置，最后归到数组的后面\n先来看一次轮询的操作，把最大值放到最后\n1 2 3 4 5 6  let array = [5,4,3,2,1] for (let i=0; i\u0026lt;array.length - 1; i++) { if (array[i] \u0026gt; array[i+1]) { [array[i+1], array[i]] = [array[i], array[i+1]]; //swap  } }   array有n个元素，就要做n次轮询的操作\n1 2 3 4 5 6 7 8  let array = [5,4,3,2,1] for (let j=0; j\u0026lt;array.length; j++) { for (let i=0; i\u0026lt;array.length - 1; i++) { if (array[i] \u0026gt; array[i+1]) { [array[i+1], array[i]] = [array[i], array[i+1]]; //swap  } } }   这里还能优化一下，我们可以发现：\n第一次 j==0时\ni==3时就把最大值交换到最后了\n第二次 j==1时\ni==2时就把最大值交换到最后了\n第三次 j==2时\ni==1时就把最大值交换到最后了\n第四次 j==3时\ni==0时就把最大值交换到最后了\n也就是每次开始新的轮询时，length都比上一次少1\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  let array = [5,4,3,2,1] function bubbleSort(array) { for (let j=0; j\u0026lt;array.length; j++) { for (let i=0; i\u0026lt;array.length - 1 - j; i++) { if (array[i] \u0026gt; array[i+1]) { [array[i+1], array[i]] = [array[i], array[i+1]]; //swap  } } } return array } console.log(bubbleSort(array))   总结：\n冒泡排序不需要额外空间，是本地排序，相等元素是不会交换前后顺序，因而也是稳定排序，时间复杂度为O(n^2)，适用于少量数据排序，但实际中用得不多\n非常感谢老姚的文章：\n原文：手写算法并记住它：冒泡排序\n","description":"","id":7,"section":"algorithm","tags":["算法基础","学习笔记"],"title":"菜鸟学算法-2-冒泡排序","uri":"http://llane00.github.io/algorithm/2-%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/"},{"content":" 这个系列是我读冴羽老师博客的感悟，\n加入了个人的解读和练习题的解答\n 我们先分析一下new做了什么，\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  function Person(name, age) { this.name = name; this.age = age; } Person.prototype.runSpeed = 10; // 10km/h  Person.prototype.run = function() { console.log(\u0026#34;running\u0026#34;); } var theOne = new Person(\u0026#39;Neo\u0026#39;, 20); console.log(theOne.name) //Neo console.log(theOne.age) //20 console.log(theOne.runSpeed) //10  theOne.run() //running    js中的关键词new 可以创建一个新对象，这个新对象的原型是new后面跟的构造函数的原型，\n在上面这个例子中，实例theOne的原型是Person，实例theOne可以：\n1.访问到构造函数Person的属性\n2.访问到构造函数Person的原型的属性\n尝试模拟：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  function objectFactory() { // 创造一个空对象  var obj = Object({}); //函数的第一个参数是obj的构造函数，使得obj可以访问构造函数的原型的属性  Constructor = [].shift.call(arguments); //空对象的原型是构造函数的原型  obj.__proto__ = Constructor.prototype; //重新指向this为obj后，执行构造函数，使得obj可以访问构造函数的内部属性  Constructor.apply(obj, arguments); return obj; }   还有一种情况需要考虑，就是构造函数有返回值时，\nobj访问构造函数内部的属性就有了限制，为了实现封装\n比如：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  function Person(name, age) { this.name = name; this.age = age; return { name: name, sex: \u0026#39;male\u0026#39; } } var theOne = new Person(\u0026#39;Neo\u0026#39;, 20); //实例theOne只能返回构造函数返回的对象中的属性 console.log(theOne.name) //Neo console.log(theOne.age) //undefined console.log(theOne.sex) //male   而如果构造函数返回的不是对象\n1 2 3 4 5 6 7 8 9 10 11 12  function Person(name, age) { this.name = name; this.age = age; return \u0026#34;warning: no access\u0026#34; } var theOne = new Person(\u0026#39;Neo\u0026#39;, 20); //相当于没有返回值进行处理 console.log(theOne.name) //undefined console.log(theOne.age) //undefined   好的，我们来完善一下objectFactory方法：\n1 2 3 4 5 6 7  function objectFactory() { var obj = Object({}) Constructor = [].shift.call(arguments) obj.__proto__ = Constructor.prototype var result = Constructor.apply(obj, arguments) return typeof result === \u0026#39;object\u0026#39;? result : obj; }   ","description":"","id":8,"section":"restart-js","tags":["js基础","学习笔记"],"title":"从头学习js-12-模拟实现new","uri":"http://llane00.github.io/restart-js/12-%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0new/"},{"content":" 这个系列是我读冴羽老师博客的感悟，\n加入了个人的解读和练习题的解答\n MDN对bing的定义 bind()方法会创建一个新函数。当这个函数被调用时，bind()的第一个参数将作为它运行时的this，之后的一序列参数将会在传递的实参前传入作为它的参数\nbind 函数的两个特点：\n1.返回一个函数\n2.可以传入参数\n例子1:\n1 2 3 4 5 6 7 8 9 10  var foo = { value: 1 } function bar(){ console.log(this.value) } var bindFoo = bar.bind(foo) bindFoo() //1   第一版 1 2 3 4 5 6  function myBind(context) { var self = this; return function() { return self.apply(context) } }   刚才的定义中提到bind还支持传参数来看个例子：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  var foo = { value: 1 }; function bar(name, age) { console.log(this.value); console.log(name); console.log(age); } var bindFoo = bar.bind(foo, \u0026#39;daisy\u0026#39;); bindFoo(\u0026#39;18\u0026#39;); // 1 // daisy // 18   第二版 1 2 3 4 5 6 7 8 9  function myBind(context) { var self = this; var args = Array.prototype.slice.call(arguments, 1) return function() { var bindArgs = Array.prototype.slice.call(arguments) return self.apply(context, args.concat(bindArgs)) } }   此时到了最难的部分，bind还有一个特性：\n一个绑定函数也能使用new操作符创建对象：这种行为就像把原函数当成构造器。提供的 this 值被忽略，同时调用时的参数被提供给模拟函数。\n来看例子：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  var value = 2; var foo = { value: 1 }; function bar(name, age) { this.habit = \u0026#39;shopping\u0026#39;; console.log(this.value); console.log(name); console.log(age); } bar.prototype.friend = \u0026#39;kevin\u0026#39;; var bindFoo = bar.bind(foo, \u0026#39;daisy\u0026#39;); var obj = new bindFoo(\u0026#39;18\u0026#39;); // undefined 提供的this值被忽略 // daisy 调用bind时的参数被一起提供了 // 18 console.log(obj.habit); console.log(obj.friend); // shopping // kevin   第三版 1 2 3 4 5 6 7 8 9 10  function myBind(context) { var self = this; var args = Array.prototype.slice.call(arguments, 1) var fBound = function(){ var bindArgs = Array.prototype.slice.call(arguments) return self.apply(this instanceOf fBound? this : context, args.concat(bindArgs)) } fBound.prototype = this.prototype; return fBound; }   但是在这个写法中，我们直接将 fBound.prototype = this.prototype，\n我们直接修改 fBound.prototype 的时候，也会直接修改绑定函数的 prototype。\n这个时候，我们可以通过一个空函数来进行中转：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  function myBind(context) { var self = this; var args = Array.prototype.slice.call(arguments, 1) var fNop = function(){} var fBound = function(){ var bindArgs = Array.prototype.slice.call(arguments) return self.apply(this instanceOf fNop? this : context, args.concat(bindArgs)) } fNop.prototype = this.prototype; fBound.prototype = new fNop() return fBound; }   以后要在生产环境中使用时，我们再补上对参数和函数名字的判断\n第四版 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  Function.prototype.bind = Function.prototype.bind || function(context) { if (typeof this !== \u0026#34;function\u0026#34;) { throw new Error(this + \u0026#34;.bind is not a function!\u0026#34;) } var self = this; var args = Array.prototype.slice.call(arguments, 1); var fNop = function(){} var fBound = function() { var bindArgs = Array.prototype.slice.call(arguments) return self.apply(this instanceOf fNop? this : context, args.concat(bindArgs)) } fNop.prototype = this.prototype; fBound.prototype = new fNop(); return fBound; }   ","description":"","id":9,"section":"restart-js","tags":["js基础","学习笔记"],"title":"从头学习js-11-模拟实现bind","uri":"http://llane00.github.io/restart-js/11-%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0bind/"},{"content":" 这个系列是我读冴羽老师博客的感悟，\n加入了个人的解读和练习题的解答\n call使用的例子：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  var foo = { value: 1 }; function bar(name, age) { console.log(name) console.log(age) console.log(this.value); } bar.call(foo, \u0026#39;kevin\u0026#39;, 18); // kevin // 18 // 1   用js模拟call：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  Function.prototype.myCall = function (newContext) { var context = Object(newContext) || window; //如果传的对象是null，默认指向window  context.fn = this; //将当前方法作为对象的一个属性  //梳理一下参数，从第二个参数开始(下标为1)  var args = []; for(var i = 1, len = arguments.length; i \u0026lt; len; i++) { args.push(\u0026#39;arguments[\u0026#39; + i + \u0026#39;]\u0026#39;); } //执行方法  var result = eval(\u0026#39;context.fn(\u0026#39; + args + \u0026#39;)\u0026#39;); delete context.fn; //删除临时属性方法  return result; }   apply和call非常类似，两者的区别只是接受的参数形式不同：\nbar.call(foo, \u0026lsquo;kevin\u0026rsquo;, 18)\nbar.apply(foo, [\u0026lsquo;kevin\u0026rsquo;, 18])\n用js模拟apply:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  Function.prototype.myApply = function (newContext, arr) { var context = Object(newContext) || window; //如果传的对象是null，默认指向window  context.fn = this; //将当前方法作为对象的一个属性  //梳理参数，这次从下标0开始，并执行方法  var result; if (!arr) { result = context.fn() } else { var args = []; for(var i = 0, len = arr.length; i \u0026lt; len; i++) { args.push(\u0026#39;arr[\u0026#39; + i + \u0026#39;]\u0026#39;) } result = eval(\u0026#39;context.fn(\u0026#39; + args + \u0026#39;)\u0026#39;); } delete context.fn; //删除临时属性方法  return result; }   ","description":"","id":10,"section":"restart-js","tags":["js基础","学习笔记"],"title":"从头学习js-10-模拟实现call和apply","uri":"http://llane00.github.io/restart-js/10-%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0call%E5%92%8Capply/"},{"content":" 我想知道这是为什么 \u0026ndash;费曼\n 快速排序从形式上为归分算法 1.分的核心是把数组按分界点一分为三\n1 2 3  let pivot = array[array.length-1] let left = array.filter((item, index) =\u0026gt; item \u0026lt;= pivot \u0026amp;\u0026amp; index != array.length-1) let right = array.filter((item, index) =\u0026gt; item \u0026gt; pivot)   2.归需要合并三个部分为一个数组\n1  let result = [...left, pivot, ...right]   3.最后利用递归的思想，完成算法\n递归步骤：\n1.数组分为3部分，left pivot right，left\u0026lt;=pivot\u0026lt;right\n2.递归处理左边的部分\n3.递归处理右边的部分\n4.合并三者的结果\n1 2 3 4 5 6  function quickSort(array) { let pivot = array[array.length - 1] let left = array.filter((item, index) =\u0026gt; item \u0026lt;= pivot \u0026amp;\u0026amp; index != array.length-1) let right = array.filter((item, index) =\u0026gt; item \u0026gt; pivot) return [...left, pivot, ...right] }   递归是调用自身，不能无限次调用下去，因此需要有递归的出口（初始条件）\n当数组元素长度小于2时，就已经是排好序了，不用再递归了，我们完善下代码\n1 2 3 4 5 6 7  function quickSort(array) { if (array.length \u0026lt; 2) return array let pivot = array[array.length-1] let left = array.filter((item, index) =\u0026gt; item \u0026lt;= pivot \u0026amp;\u0026amp; index != array.length -1) let right = array.filter((item, index) =\u0026gt; item \u0026gt;pivot) return [...left, pivot, ...right] }   时间复杂度 我之前一直对时间复杂度的log感觉很模糊，看了下面这句话才恍然大悟\n 时间复杂度，2的64次方个有序数据二分查找也顶多循环64次\n 此版本的快速排序每一次递归调用，需要额外空间，复杂度为O(n)，不是本地排序。\n说起空间复杂度，递归也需要空间（相当于手动维护一个调用栈），因此总体空间复杂度是O(nlogn)。相等元素是不会交换前后顺序，因而是稳定排序（这与我们选择最后一个元素为分界点有关）。\n时间复杂度为O(nlogn)。\n非常感谢老姚的文章：\n原文：手写算法并记住它：快速排序（5行代码简单版）\n","description":"","id":11,"section":"algorithm","tags":["算法基础","学习笔记"],"title":"菜鸟学算法-1-简单版快速排序","uri":"http://llane00.github.io/algorithm/1-%E7%AE%80%E5%8D%95%E7%89%88%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"},{"content":" 这个系列是我读冴羽老师博客的感悟，\n加入了个人的解读和练习题的解答\n 在《JavaScript高级程序设计》第三版 4.1.3，讲到传递参数：\n ECMAScript中所有函数的参数都是按值传递的。\n 那么js中的参数分为基本类型和引用类型\n在内存中有栈和堆两个区域，栈用于储存基本类型的数据，而堆用于存放引用类型的数据\n（后续还有常量区先不讲）\n1 2  let a = 1; let b = {name: \u0026#39;Neo\u0026#39;, age: 25};   以上的代码会在内存中储存数据形式大致如下：\n在栈中有：\na(值为1)\nb(值为一个指针，一个指向堆中对象数据的地址假设为1000)\n在堆中有：\n{name: \u0026lsquo;Neo\u0026rsquo;, age: 25}\n其中指针1000指向{name: \u0026lsquo;Neo\u0026rsquo;, age: 25}\n  栈内存堆内存   a1   b指针地址1000{name: 'Neo', age: 25}    例子1：\n1 2 3 4 5 6 7  var value = 1; function foo(v) { v = 2; console.log(v); //2 } foo(value); console.log(value) // 1   例子1会打印\n2\n1\nfoo(value) 函数开始执行时，初始化AO，然后加入形参\n执行了像var v = value这样的一个操作，把value赋值给了函数内的参数v\n  栈内存堆内存   value1   v1    再执行v = 2，重新赋值v\n  栈内存堆内存   value1   v2    例子2:\n1 2 3 4 5 6 7 8 9  var obj = { value: 1 }; function foo(o) { o.value = 2; console.log(o.value); //2 } foo(obj); console.log(obj.value) // 2   foo(obj) 函数开始执行时，初始化AO，然后加入形参\nvar o = obj，把obj值的引用赋值给了o\n 栈内存堆内存   obj，o指针地址{value: 1}   此时o.value = 2会沿着引用找到obj指向的值并修改\n 栈内存堆内存   obj，o指针地址{value: 2}   例子3:\n1 2 3 4 5 6 7 8 9  var obj = { value: 1 }; function foo(o) { o = 2; console.log(o); //2 } foo(obj); console.log(obj.value) // 1   foo(o) 函数开始执行时，初始化AO，然后加入形参\nvar o = obj，把obj值的引用赋值给了o\n 栈内存堆内存   obj，o指针地址{value: 1}   此时o = 2会赋值o把指针的值覆盖修改为2\n 栈内存堆内存   obj指针地址{value: 1}   o2  ","description":"","id":12,"section":"restart-js","tags":["js基础","学习笔记"],"title":"从头学习js-9-函数的参数传递","uri":"http://llane00.github.io/restart-js/9-%E5%87%BD%E6%95%B0%E7%9A%84%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92/"},{"content":" 这个系列是我读冴羽老师博客的感悟，\n加入了个人的解读和练习题的解答\n 在MDN广泛定义中闭包指的是能访问自由变量的函数（自由变量指的是即不是这个函数的参数也不是这个函数的内部变量）\n由于函数都有作用域链，所有函数都可以访问到全局上下文中的变量那所有函数其实都是闭包\n在实际场景中，对闭包的定义更加具体，在第7篇的第二个例子中其实遇到了闭包的经典例子\n闭包需要满足：\n1.即使创建它的上下文已经销毁，它仍然存在（比如，内部函数从父函数中返回）\n2.在代码中引用了自由变量\n分析一个例子：\n1 2 3 4 5 6 7 8 9 10 11  var scope = \u0026#34;global scope\u0026#34;; function checkscope(){ var scope = \u0026#34;local scope\u0026#34;; function f(){ return scope; } return f; } var foo = checkscope(); foo(); //这里会打印local scope   例子中的函数f在父函数checkScope中，\n由于父函数会return f且在之后赋值给foo调用了，所以即使父函数checkScope执行结束，函数f也存在\n函数f中引用了父函数中的变量scope所以函数f符合闭包的定义\n通过之前的文章，我们其实知道更深的原因了，就是函数f在创建的时候就根据上下文保存了一个作用域链\n在函数f初始化执行上下文的时候复制了这个作用域链\n1 2 3 4  f.[[scope]] = [checkscopeContext.AO, globalContext.VO] fContext = { scope: [AO, checkscopeContext.AO, globalContext.VO] }   在沿着作用域链查找scope变量时，AO中没有，而继续查checkscopeContext.AO时找到了scope变量（值为local scope）\n例子2:\n1 2 3 4 5 6 7 8 9 10 11  var data = []; for (var i = 0; i \u0026lt; 3; i++) { data[i] = function () { console.log(i); }; } data[0](); data[1](); data[2]();   这道题是非常经典的闭包问题，当时作为初学者的我无法理解真正的原因最后只能硬记下结论\n现在我们用作用域链和执行上下文的知识点就可以拨开云雾了\n首先for不是函数for 中var声明的i其实是全局变量，\nfor循环执行完后的情况是这样的\n1 2 3 4 5 6 7 8 9 10  globalContext = { VO: { data: [ 0: reference to function(){console.log(i)}, //这个匿名函数的内部属性[[scope]]=[globalContext.VO]  1: reference to function(){console.log(i)}, //这个匿名函数的内部属性[[scope]]=[globalContext.VO]  2: reference to function(){console.log(i)}, //这个匿名函数的内部属性[[scope]]=[globalContext.VO]  ], i: 3 } }   函数的内部代码如果只是创建是不会去执行的，匿名函数内部还是变量i的指向状态，\n在之后真正开始执行的时候data0,开始创建AO，完善执行上下文的作用域链scope=[AO, globalContext.VO]\nAO中没有i，就找到了globalContext中的i，而此时globalContext中的i已经是3了，\n所以三个匿名函数最后都会打印3\n通常要解决这个问题会用一个新的匿名函数形成闭包或者用let\n我们想在data[0]的执行上下文作用域链接里塞上真正期望的i，scope=[AO, xContext.AO, globalContext.VO]\nxContext.AO中存有不同的i\n1 2 3 4 5 6 7 8 9 10 11 12 13  var data = [] for (var i = 0; i \u0026lt; 3; i++) { data[i] = (function(i){ return function(){ console.log(i) } })(i); } data[0](); data[1](); data[2]();   (functionx(i){})(i)相当于\nfunction x(i){}\nx(i)\n这个匿名函数会在data[0]的执行上下文的作用域中插入，\n此时data[0]在执行时，作用域变为\n1 2 3 4 5 6 7 8 9 10 11 12 13  data[0]Context = { scope: [AO, 匿名函数Context.AO, globalContext.VO] } 匿名函数Context = { AO: { arguments: { 0:0, length: 1 }, i: 0 } }   data[0]Context.AO中没有i值，沿着作用域找到了匿名函数Context中的i\n在for循环的时候匿名函数立即执行了才在AO中保留了不同的i，如果没有立即执行也只是保留了一个指向i的值\n","description":"","id":13,"section":"restart-js","tags":["js基础","学习笔记"],"title":"从头学习js-8-闭包","uri":"http://llane00.github.io/restart-js/8-%E9%97%AD%E5%8C%85/"},{"content":" 这个系列是我读冴羽老师博客的感悟，\n加入了个人的解读和练习题的解答\n 本篇是3、4、5、6篇的汇总，会用两个例子来详细说明执行上下文的运行流程\n例子1 1 2 3 4 5 6 7 8 9  var scope = \u0026#34;global scope\u0026#34;; function checkscope(){ var scope = \u0026#34;local scope\u0026#34;; function f(){ return scope; } return f(); } checkscope();   1.执行全局代码，创建全局上下文，全局上下文压入执行上下栈\n1 2 3  ECStack = [ globalContext ]   2.初始化全局上下文\n1 2 3 4 5  globalContext = { VO: [global], scope: [globalContext.VO], this: globalContext.VO }   2.初始化的同时，创建checkScope函数，checkscope函数保存作用域链到函数内部属性\n1  checkscope.[[scope]] = [globalContext.VO];   3.执行checkscope函数，创建checkScope执行上下文，压入执行上下文栈\n1 2 3 4  ECStack = [ checkscopeContext, globalContext ]   4.初始化checkScope执行上下文，\n4.1复制checkscope函数的内部属性[[scope]]创建作用域链\n4.2用arguments创建AO活动对象，\n4.3初始化活动对象，即加入函数形参，函数声明，变量声明\n4.4将活动对象压入checkscope的作用域顶端\n1 2 3 4 5 6 7 8 9 10 11  checkscopeContext = { AO: { arguments: { length: 0 }, scope: undefined, f: reference to fucntion f(){} }, scope: [AO, globalContext.VO], this: undefined }   同时f函数被创建，保存作用域链到f函数内部属性[[scope]]\n1  f.[[scope]] = [checkscopeContext.AO, globalContext.VO];   5.执行f函数，创建f函数执行上下文，将其压入执行上下文栈\n1 2 3 4 5  ECStack = [ fContext, checkscopeContext, globalContext ]   6.f函数执行上下文初始化，\n6.1复制函数[[scope]]属性创建作用域链\n6.2用arguments创建活动对象\n6.3舒适化活动对象，即加入形参，函数声明，变量声明\n6.4将活动对象压入f作用域顶端\n1 2 3 4 5 6 7 8 9  fContext = { AO: { arguments: { length: 0 }, }, scope: [AO, checkScopeContext.AO, globalContext.VO], this: undefined }   7.执行函数f，沿着作用域链找到scope的值，返回scope的值\n8.函数f执行完毕后，在ECStack中出栈\n1 2 3 4 5  ECStack.pop() ECStack = [ checkscopeContext, globalContext ]   9.函数checkScope执行完毕后在ECStack出栈，\n1 2 3 4  ECStack.pop() ECStack = [ globalContext ]   例子2 例子2和例子很相似\n1 2 3 4 5 6 7 8 9  var scope = \u0026#34;global scope\u0026#34;; function checkscope(){ var scope = \u0026#34;local scope\u0026#34;; function f(){ return scope; } return f; } checkscope()();   1.开始执行全局代码，创建全局上下文，并将其压入上下文执行栈\n1 2 3  ECStack = [ globalContext ]   2.初始化全局上下文\n1 2 3 4 5  globalContext = { VO: [global], scope: globalContext.VO, this: globalContext.VO }   2.初始化的同时创建函数checkscope，函数checkScope保存作用域链到其内部属性[[scope]]\n1  checkscope.[[scope]] = [globalContext.VO];   3.执行函数checkScope，创建checkScope函数的执行上下文，并将其压入上下文执行栈\n1 2 3 4  ECStack = [ checkScopeContext, globalContext ]   4.初始化checkScope执行上下文，\n4.1保存函数的内部属性[[scope]]到执行上下文的作用域链\n4.2根据函数的arguments创建活动对象AO\n4.3初始化活动对象，即加入函数形参，函数声明，变量声明\n4.4将活动对象压入checkscope作用域的顶端\n1 2 3 4 5 6 7 8 9 10 11  checkScopeContext = { AO: { arguments: { length: 0 }, scope: undefined, f: reference to fucntion f(){} }, scope: [AO, globalContext], this: undefined }   4.同时创建函数f，保存作用域链到f函数内部属性[[scope]]\n1  f.[[scope]] = [checkscopeContext.AO, globalContext.VO];   5.沿着作用域找到函数f的指向，返回函数f的指向，函数checkScope执行完毕后在ECStack出栈\n1 2 3 4  ECStack.pop() ECStack = [ globalContext ]   6.执行checkScope返回的函数f，创建函数f的执行上下文，将其压入执行上下文栈\n1 2 3 4  ECStack = [ fContext, globalContext ]   7.初始化f的执行上下文fContext\n7.1复制函数内部属性scope到函数上下文的作用域链\n7.2根据函数的arguments创建活动对象AO\n7.3初始化活动对象，即加入函数形参，函数声明，变量声明\n7.4将活动对象压入函数上下文作用域链的顶端\n1 2 3 4 5 6 7 8 9  fContext = { AO: { arguments: { length: 0 } } scope: [AO, checkScopeContext.AO, globalContext] this: undefined }   8.执行函数f，沿着作用域链找到scope的值（这里是在checkScopeContext.AO里找到scope的，即便checkScopeContext.AO已经在ECStack中出栈，这就是闭包的原理），返回scope的值\n7.函数f执行完毕后，f的执行上下文从执行上下文栈中弹出\n1 2 3 4  ECStack.pop() ECStack = [ globalContext ]   ","description":"","id":14,"section":"restart-js","tags":["js基础","学习笔记"],"title":"从头学习js-7-执行上下文汇总篇","uri":"http://llane00.github.io/restart-js/7-%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E6%B1%87%E6%80%BB%E7%AF%87/"},{"content":" 这个系列是我读冴羽老师博客的感悟，\n加入了个人的解读和练习题的解答\n this一直都是学习js的时候很头疼的东西，\n继续接着上篇说，当javascript代码执行一段可执行代码(executable code)时，会创建对应的执行上下文(execution context)\n那对于每个执行上下文，都有三个重要属性：\n 变量对象(Variable object, VO) 作用域链(Scope chain) this  本文主要讲执行上下文中的this\n首先了解ECMAScript规范 我们根据ECMAScript规范来解读this\nECMAScript 5.1 规范地址：\n英文版：http://es5.github.io/#x15.1\n中文版：http://yanhaijing.com/es5/#115\njavascript 有8种数据类型，Undefined,Null,Boolean,Number,String,Object,Symbol,Bigint\n这是我们在编程时可以直接操作使用的数据类型，\n在javascript的底层逻辑中还有一些只存在于规范里的抽象类型：\nReference，\nList，\nCompletion，\nProperty，\nDescriptor，\nProperty Identifier，\nLexical Environment，\nEnvironment Record\n这些规范类型是用算法描述ECMAScript语言结构和语言类型的，\n其中与this的指向有关的是Reference类型\nReference由三个部分组成：\n1.base value (属性所在的对象或者是EnvironmentRecord，所以它的值只能是undefined, an Object, a Boolean, a String, a, Number or an environment record)\n2.reference name (属性名称)\n3.strict reference\n举个例子：\n1 2 3 4 5 6 7 8  var foo = 1; //foo对应的Reference是 var fooReference = { base: EnvironmentRecoed, name: \u0026#39;foo\u0026#39;, strict: false }   1 2 3 4 5 6 7 8 9 10 11 12 13 14  var foo = { bar: function() { return this; } } foo.bar(); //bar对应的Reference是 var barReference = { base: foo, propertyName: \u0026#39;bar\u0026#39;, strict: false };   Reference涉及到的方法有：\n1.GetBase 返回base value\n2.isProperty 判断base value是不是一个对象\n3.GetVlaue 从Reference处返回一个真正的值（具体的值，不是Reference）\n按步骤确定this的指向 规范中确定this的值，有明确的步骤判断：\n1.计算MemberExpression的结果赋值给ref\n2.判断ref是不是一个Reference类型\n2.1 如果ref是Reference，并且base value值是一个对象（isProperty(ref)为true），那么this的值就是base value（用getBase获得）\n2.2 如果ref是Reference，并且base value值是Environment Record，那么this的值是ImplicitThisValue(ref)\n2.3 如果ref不是Reference，那么this的值是undefined\n步骤1中 MemberExpression分别有：\nPrimaryExpression //原始表达式\nFunctionExpression //函数表达式\nMemberExpression [Expression] //属性[]访问表达式\nMemberExpression.IdentifierName //属性.访问表达式\nnew MemberExpression Arguments //对象创建表达式\n例子：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  function foo() { console.log(this) } foo(); //MemberExpression是foo  function foo() { return function () { console.log(this) } } foo()(); //MemberExpression是foo()  var foo = { bar: function() { return this } } foo.bar(); //MemberExpression是foo.bar   可以简单判断MemberExpression是()左边的部分\n步骤2中判断ref是不是一个Reference类型\n例子：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  var value = 1; var foo = { value: 2, bar: function() { return this.value; } } //example1 console.log(foo.bar()) //example2 console.log((foo.bar)()) //example3 console.log((foo.bar = foo.bar)()) //example4 console.log((false || foo.bar)()) //example5 console.log((foo.bar, foo.bar)())   example1\nMemberExpression为foo.bar属于规范11.2中提到的属性访问，他会返回一个值类型的引用\n所以foo.bar会返回一个Reference类型\n1 2 3 4 5  var Reference = { base: foo, name: \u0026#39;bar\u0026#39;, strict: false }   符合确定this的步骤中2.1，IsPropertyReference(ref) 为 true，且base value为foo\n所以this指向foo\nconsole.log打印1\nexample2\n(foo.bar)是规范11.1.6中提到的分组表达式，会返回一个Reference类型，\n后面的步骤和example1一样所以this指向foo\nconsole.log打印1\nexample3\n(foo.bar = foo.bar)是规范11.13.1中提到的简单赋值会返回一个rval不是一个Reference，\n对照this判断步骤的2.3，this的值就是undefined（非严格模式下会隐式转换为全局变量，浏览器中就是window）\nconsole.log打印2\nexample4\n(false || foo.bar)是规范11.11中提到的二元逻辑运算符会返回GetValue(rref)不是一个Reference，\n对照this判断步骤2.3，this的值就是undefined\nconsole.log打印2\nexample5\n(foo.bar, foo.bar)是规范11.14中提到的逗号运算符会返回GetValue(rref)不是一个Reference，\n对照this判断步骤2.3，this的值是undefined\nconsole.log打印2\n看一个最常见的情况\n1 2 3 4 5 6  //example6 function foo() { console.log(this) } foo()   MemberExpression是foo，是规范10.3.1中提到的标识符解析会返回一个引用对象Reference，\n1 2 3 4 5  var fooReference = { base: Environment, name: \u0026#39;foo\u0026#39;, strict: false }   对照this判断步骤2.2, this的值为 ImplicitThisValue(ref)\n在规范10.2.1.1.6中对ImplicitThisValue的解释他始终返回undefined\n所以this指向undefined\n不管怎么样按照规范去解读this指向从步骤和逻辑上是更为清晰的\n","description":"","id":15,"section":"restart-js","tags":["js基础","学习笔记"],"title":"从头学习js-6-This","uri":"http://llane00.github.io/restart-js/6-this/"},{"content":"React理念：UI = f(data)\n纯函数在加载不同数据后产生了不同的UI\nuseState 1 2 3 4  const [n, setN] = useState(0); console.log(n) //读 onClick = () =\u0026gt; (setN(n+1)) //写 onClick2 = () =\u0026gt; (setN(i =\u0026gt; i + 1)) //也支持传入一个匿名函数   随着组件更新render，useState会产生多个n，但每次get的n是最新的n\n组件每次重新渲染，组件里的函数都会重新执行，\n对应的所有state都会出现重复分身\n如果你不希望出现重复分身的变量\n可以用useRef/useContext等\n如：\n1 2 3  const nRef = useRef(0); console.log(nRef.current); onClick = () =\u0026gt; (nRef.current += 1)   useState 不能局部更新\nuseState 如果数据地址没变那么react就不会重新render更新\n如果useState的对象生成复杂建议把初始值写成一个匿名函数，不然每次重新渲染时都要做多余的计算开销\nuseState(() =\u0026gt; ({ name: ’neo' }))\nsetState会合并多个同级别的对n的操作，\n如：\n1 2 3 4  setN(n+1) setN(n+1) setN(n+1) //这段代码只会执行会后一行的setN(n+1)   1 2 3 4  setN(n+1) setN(n+2) setN(n+3) //同上也只会执行最后的setN(n+3)   所以setState 建议传入一个匿名函数方法，可以防止上面的合并操作，也可以防止代码出现过时的闭包，\n比如: setN(i =\u0026gt; i + 1)\nuseReducer useReducer 是一个把对state的所有操作都聚拢在内的useState\n用来践行flux思想，具体过程如下：\n1.创建初始值 initialState\n2.创建所有操作 reducer(state, action)\n3.传给useReducer，得到读和写api\n4.调用时写 ({ type: ‘操作类型' })\nredux主要做到了：\n1.集中管理全局状态和对状态的操作\n2.提供所有子组件可以在上下文中读写全局状态\nuseContext 现在可以用useState/useReducer和useContext来代替redux\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31  const AppContext = React.createContext(null) //可以用useState生成读写 const [name, setName] = useState(\u0026#39;the_one\u0026#39;); //也可以用useReducer来生成读写 const initialState = {age:0, sex:\u0026#39;male\u0026#39;} const reducer = (prevState, action) =\u0026gt; { swicth (action.type) { case \u0026#39;age\u0026#39;: return { ...prevState, age: action.payload } case \u0026#39;sex\u0026#39;: return { ...prevState, sex: action.payload } default: throw new Error(\u0026#39;error action type\u0026#39;) break; } } const [ personInfo, dispatch ] = useReducer(reducer, initialState) //用AppContext.Provider来包裹，在value中传入要全局使用的读写name操作 \u0026lt;AppContext.Provider value={{name, setName, personInfo, dispatch}}\u0026gt; \u0026lt;CompontentA/\u0026gt; \u0026lt;CompontentB/\u0026gt; \u0026lt;/AppContext.Provider\u0026gt;   1 2 3 4 5 6  //在组件A和组件B中就可以获取context中的vaule //const {name, setName, personInfo, dispatch} = useContext(AppContext)  setName(\u0026#39;Neo\u0026#39;) dispatch({ type: \u0026#39;age\u0026#39;, payload: \u0026#39;25\u0026#39; }) console.log(name, personInfo)   useEffect useEffect（定义：执行在render后的副作用）\n依赖参数中数组里的值的变化来决定是否要执行函数\nApp() -\u0026gt; 执行 -\u0026gt; VDOM(VNode)\n-\u0026gt; DOM -\u0026gt;useLayoutEffect -\u0026gt; 浏览器改变外观 -\u0026gt; useEffect\nuseEffect在浏览器渲染完成后执行\nuseLayoutEffect 在浏览器渲染前执行\nuseLayoutEffect总是比useEffect先执行，\nuseLayoutEffect里的任务最好是影响了useEffect\nuseMemo \u0026amp;\u0026amp; useCallBack useMemo 可以实现函数的重用，防止在多次render的时候做不必要的重复创建和执行函数\n第一个参数是 ()=\u0026gt;value\n第二个参数是依赖 [m,n]\n只有当依赖不变时，才会计算新的value，\n如果依赖不变，那么就重用之前的value\n（vue2 computed？）\n如果value是一个函数，那么要写成\n()=\u0026gt; ((x)=\u0026gt; console.log(x))\n可以用useCallBack简化\nuseCallback(x=\u0026gt;log(x), [m]) 等价于\nuseMemo(() =\u0026gt; x =\u0026gt; log(x), [m])\nuseRef useRef的目的：在组件不断render时，需要一个值保持不变，比如可以累积计算之类的\nuseRef 原理：用对象的形式来存变量，在对象里可以做到改变对象的值，而不变对象的地址\n为了保证值不变，所以使用引用\n初始化：const count = useRef(0)\n读取：count.current\n汇总 App() 重复 rendering…\n每次变 useState/useRender，setN会触发重新render\n有条件时变 useMemo/useCallBack，防止函数有多余的render\n不变 useRef ，改变值不会触发重新render\n（vue3 ref值有变化会自动render）\nReact.forwardRef 我们可以给一个函数组件一个ref来方便引用一个组件（就可以不用getElementById了），\n但是函数式组件不能直接用useRef产生的ref（class组件可以直接用），因为函数式组件的props里不包含ref\n此时需要用React.forwardRef包裹一下函数组件来获得ref\n1 2 3 4 5 6 7 8 9 10 11 12  function App() { const buttonRef = useRef(null); return ( \u0026lt;div className=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;Button2 ref={buttonRef}\u0026gt;按钮\u0026lt;/Button2\u0026gt; \u0026lt;/div\u0026gt; ) } const Button2 = React.forward((props, ref) =\u0026gt; { return \u0026lt;button className=\u0026#34;red\u0026#34; ref={ref} {…props} /\u0026gt; })   useImpreativeHandle useImpreativeHandle 可以以ref为参数返回一个自定义的ref对象\n自定义hooks 自定义hooks是 对已有的基础react hooks互相组合的封装\n","description":"","id":16,"section":"Reactjs","tags":["React"],"title":"学习React_hooks_1","uri":"http://llane00.github.io/reactjs/1-react-hooks/"},{"content":" 这个系列是我读冴羽老师博客的感悟，\n加入了个人的解读和练习题的解答\n 上篇说到，当javascript代码执行一段可执行代码(executable code)时，会创建对应的执行上下文(execution context)\n那对于每个执行上下文，都有三个重要属性：\n 变量对象(Variable object, VO) 作用域链(Scope chain) this  本文主要讲执行上下文中的作用域链，注意本章将会把之前的内容穿起来很重要\n在之前第2篇作用域和第4篇变量对象中有提到，\n当查到变量时首先从当前上下文的变量对象中查到，\n如果没有找到会从父级（词法静态层面上的）执行上下文的变量对象中查找，\n一直找到全局变量对象（全局对象）\n这样由多个执行上下文的变量对象构成的链表就叫做作用域链\n函数创建 在第2篇中提到js中函数的作用域在函数定义的时候就决定了\n这是因为函数有一个内部属性`[[scope]]``, 当函数创建的时候会把函数的父变量对象保存到其中，但不是完整的作用链\n如：\n1 2 3 4 5  function foo() { function bar() { ... } }   此时函数的各自作用域为：\n1 2 3 4 5 6 7  foo.[[scope]] = [ globalContext.VO ]; bar.[[scope]] = [ fooContext.AO, globalContext.VO ];   函数激活 当函数激活的时候，进入函数上下文，创建VO/AO后，就会将函数活动对象加到作用域的最前端，\n1  Scope = [AO].concat([[scope]])   此时作用域链创建完毕\n总结事例 例子：\n1 2 3 4 5 6  var scope = \u0026#39;global scope\u0026#39;; function checkscope() { var scope2 = \u0026#39;local scope\u0026#39;; return scope2; } checkscope();   函数执行上下文中作用域和变量对象创建过程如下：\n1.checkscope函数被创建，保存作用域到内部属性[[scope]]\n1 2 3  checkscope.[[scope]] = [ globalContext.VO ]   2.执行checkscope函数，创建checkscope函数执行上下文，checkscope函数执行上下文压入执行上下栈\n1 2 3 4  ECStack = [ checkscopeContext, globalContext ];   3.checkscope函数进入准备阶段\n3.1 复制函数内部属性[[scope]]到函数执行上文中\n1 2 3  checkscopeContext = { Scope: checkscope.[[scope]] }   3.2 用函数的arguments属性创建活动对象，随后初始化活动对象，加入形参、函数声明、变量声明\n1 2 3 4 5 6 7 8 9  checkscopeContext = { AO: { arguments: { length: 0, }, scope2: undefined }, Scope: checkscope.[[scope]] }   3.3 将活动对象压入作用域顶端\n1 2 3 4 5 6 7 8 9  checkscopeContext = { AO: { arguments: { length: 0, }, scope2: undefined }, Scope: [AO, [[scope]]] }   准备工作完毕\n4.开始执行checkscope函数，随着函数执行，修改AO的属性值\n1 2 3 4 5 6 7 8 9  checkscopeContext = { AO: { arguments: { length: 0, }, scope2: \u0026#39;local scope\u0026#39; }, Scope: [AO, [[scope]]] }   5.查找到scope2的值，返回后函数执行完毕，checkscope函数上下文从执行上下文中弹出\n1 2 3  ECStack = [ globalContext ]   ","description":"","id":17,"section":"restart-js","tags":["js基础","学习笔记"],"title":"从头学习js-5-作用域链","uri":"http://llane00.github.io/restart-js/5-%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE/"},{"content":" 这个系列是我读冴羽老师博客的感悟，\n加入了个人的解读和练习题的解答\n 上篇说到，当javascript代码执行一段可执行代码(executable code)时，会创建对应的执行上下文(execution context)\n那对于每个执行上下文，都有三个重要属性：\n 变量对象(Variable object, VO) 作用域链(Scope chain) this  本文主要讲执行上下文中的变量对象\n变量对象 变量对象是与执行上下文相关的数据作用域，储存了在上下文中定义的变量和函数声明\n因为不同执行上下文的变量对象稍有不同，这里分全局上下文下的变量对象和函数上下文下的变量对象来讨论。\n全局上下文的变量对象就是全局对象，是全局变量的宿主。\n在浏览器中，全局中的this和window都指向全局变量\n函数上下文中的变量对象称为活动对象（activation object，AO）\n活动对象就是变量对象，只是函数上下文中的变量对象只有函数代码在执行到被激活时才能被访问到，\n活动对象就是在进入函数上下文时被创建的，它通过函数的arguments属性初始化。\n执行上下文生命周期：  创建执行上下文阶段\n创建变量对象，建立作用域，以及明确this的指向    变量对象包括：\n 函数所有形参   由名称和对应值组成的一个变量对象的属性被创建 没有实参，属性值设为undefined  函数声明（函数声明优先于变量声明）   由名称和对应值（函数对象（function-object））组成的一个变量对象的属性被创建 如果变量对象已经存在相同名称的属性，则完全替换这个属性  变量声明   由名称和对应值（undefined）组成的一个变量对象的属性被创建 如果变量名称和已经声明的形式参数或函数相同，则变量声明不会干扰已经存在的这类属性    执行代码阶段\n创建上下文后，开始执行代码，  例子：\n1 2 3 4 5 6 7 8 9  function foo(a) { var b = 2; function c() {} var d = function() {}; b = 3; } foo(1)   在进入执行上下文后，此时的AO为\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  AO = { //AO通过函数的arguments初始化，是一个伪数组  arguments: { 0: 1, length: 1 }, //函数所有形参 由名称和对应值组成的一个变量对象的属性被创建  a: 1, //变量声明 名称和对应值（undefined）组成的一个变量对象的属性被创建  b: undefined, //函数声明 由名称和对应值（函数对象（function-object））组成的一个变量对象的属性被创建  c: reference to function c(){}, //同上变量声明  d: undefined }   函数执行后：\n按顺序执行代码，初始化变量和给变量赋值\n1 2 3 4 5 6 7 8 9 10  AO = { arguments: { 0: 1, length: 1 }, a: 1, b: 3, c: reference to function c() {}, d: reference to FunctionExpression \u0026#34;d\u0026#34; }   关于声明变量和函数时的补充: 这里认为声明变量和函数都有三个阶段：\n1.创建create\n2.初始化initialize（声明时首次初始化不同于第三步的assign）\n3.赋值assign\n关于声明语法的结论是：\nfunction 的「创建」「初始化」和「赋值」都被提升了。\nvar 的「创建」和「初始化」都被提升了。\nlet 的「创建」过程被提升了，但是初始化没有提升，拥有块级作用(暂时性死区)。\nconst 只有创建和初始化，没有「赋值」,「创建」过程被提升了，拥有块级作用(暂时性死区)\n通常认为const不可变是片面的，\n首先const必须初始化，且在栈中储存的值不可修改，\n但当const声明的是引用类型时，堆中的储存值可以改变\n如：\n1 2 3  const obj = {name: \u0026#39;Neo\u0026#39;, age: 20} obj.age = 25 console.log(obj) //{name: \u0026#39;Neo\u0026#39;, age: 25}   如果不通过关键词var let等声明变量，AO中不会创建对应该变量的key-value\n但是当这个变量被赋值assign的时候会创建变量对象到VO中\nmore 参考资料：  关于let的变量提升？探究 https://zhuanlan.zhihu.com/p/28140450/  ","description":"","id":18,"section":"restart-js","tags":["js基础","学习笔记"],"title":"从头学习js-4-变量对象","uri":"http://llane00.github.io/restart-js/4-%E5%8F%98%E9%87%8F%E5%AF%B9%E8%B1%A1/"},{"content":" 这个系列是我读冴羽老师博客的感悟，\n加入了个人的解读和练习题的解答\n 我们知道在js中有变量提升，\n所以js引擎在解析代码的时候不是一行一行去执行的，而是一段一段去分析\n（暂且以函数花括号来划分段）\n实际环境中的函数可能是一层套一层执行的，加上函数有各自的静态作用域\njavascript引擎创建了执行上下文栈（Execution context stack，ECS）来管理这些情况\n由于函数的执行是有顺序的，执行上下文栈是先进后出的栈结构\n我们这里用数组来模拟它\n1  ECStack = []   首先执行全局代码，此时在ECStack中压入一个 globalContext\n1 2 3  ECStack = [ globalContext ]   然后我们执行下面的实例代码\n1 2 3 4 5 6 7 8 9 10  function a() { console.log(\u0026#34;run a\u0026#34;) b() } function b() { console.log(\u0026#34;run b\u0026#34;) } a()   首先执行a函数，在ECStack中压入函数a的执行上下文，\n1 2 3 4  ECStack = [ \u0026lt;a\u0026gt; functionContext, globalContext ]   发现执行函数a中，需要执行b函数（此时a还没执行完，没有出栈），在ECStack中压入函数b的执行上下文\n1 2 3 4 5  ECStack = [ \u0026lt;b\u0026gt; functionContext, \u0026lt;a\u0026gt; functionContext, globalContext ]   函数b执行完后，函数b的执行上下文出栈，ECStack.pop()\n然后函数a也执行完了，继续 ECStack.pop()\n就是这么一个执行栈\n另一个例子：\n代码A\n1 2 3 4 5 6 7 8 9  var scope = \u0026#34;global scope\u0026#34;; function checkscope(){ var scope = \u0026#34;local scope\u0026#34;; function f(){ return scope; } return f(); } checkscope();   代码B\n1 2 3 4 5 6 7 8 9  var scope = \u0026#34;global scope\u0026#34;; function checkscope(){ var scope = \u0026#34;local scope\u0026#34;; function f(){ return scope; } return f; } checkscope()();   首先代码A和代码B 都会打印 localscope，具体原因在上一篇作用域中有解释\n但不同的是A和B的执行上下文的顺序不同\n伪代码是这样的\n1 2 3 4 5  //代码A ECStack.push(\u0026lt;checkscope\u0026gt; functionContext) ECStack.push(\u0026lt;f\u0026gt; functionContext) ECStack.pop() //f 执行结束 ECStack.pop() //checkscope 执行结束   1 2 3 4 5  //代码B ECStack.push(\u0026lt;checkscope\u0026gt; functionContext) ECStack.pop() //checkcope 执行结束 ECStack.push(\u0026lt;f\u0026gt; functionContext) ECStack.pop() //f 执行结束   ","description":"","id":19,"section":"restart-js","tags":["js基础","学习笔记"],"title":"从头学习js-3-执行上下文栈","uri":"http://llane00.github.io/restart-js/3-%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E6%A0%88/"},{"content":" 这个系列是我读冴羽老师博客的感悟，\n加入了个人的解读和练习题的解答\n 作用域是程序如何储存和获取变量的约定\njavascript采用了词法作用域（即静态作用域）\n静态作用域在函数创建的时候就记下了，会在函数代码的书写位置层级向上查找变量\n动态作用域在函数调用的时候才决定，会在函数调用栈中依次向上查找变量\n1 2 3 4 5 6 7 8 9 10 11 12 13  var value = 1; function foo() { console.log(value); } function bar() { var value = 2; foo(); } bar();   以上代码在静态作用域情况下会打印1\n在动态作用域情况下会打印2\n","description":"","id":20,"section":"restart-js","tags":["js基础","学习笔记"],"title":"从头学习js-2-作用域","uri":"http://llane00.github.io/restart-js/2-%E4%BD%9C%E7%94%A8%E5%9F%9F/"},{"content":"normal 模式\ninsert 模式\nvisual 模式\ncontrol + [ 从insert/visual回到normal\nesc 也是从insert/visual回到normal\nnormal 模式下 hjkl 移动光标左下上右\na 在光标后insert\ni 在光标前insert\nshift + a 在当前行结尾处insert\nshift + i 在当前行开头处insert\ngg 光标跳转到文档第一行\nshift + g 光标跳转到文档最后一行\n: + 行号 + 回车 光标跳转到文行特定的行\n数字 + j/k 光标上下移动指定行数\n数字 + w/b 光标左右移动指定的单词个数\n[[ 光标跳转到文档第一行\n]] 光标跳转到文档最后一行\nshift + { 光标跳转到下一个段落\nshift + } 光标跳转到上一个段落\ncontrol + u 向下翻页\ncontrol + d 向上翻页\n% 用于在 () {} 之间跳转\nzz 将当前行剧中到屏幕中\no 换行insert\nshift + o 在上一行空一行insert\n/ + 字符为搜索 （n 和 shift + n 可以继续上下选择）\nf + 字符 光标定位到字符上（;继续下一个 ,继续上一个）\nt + 字符 光标定位到字符前（;继续下一个 ,继续上一个）\nyy 复制当前行\ndd 剪切当前行（删除）\nshift + d 删除当前行光标后的内容\nshift + d 删除当前行光标后的内容 + insert\np 黏贴内容到当前行的下一行\nshift + p 黏贴内容到当前行的上一行\nu 撤销\nx 删除光标选中内容\ns 删除光标选中内容并insert\nshift + s 删除当前行并insert\ncw 等价于 dwi\nvisual 模式下 v 单个字选择模式\nshift + v 行选择模式\n需要选中缩进的时候，按v(或V)进入visual状态，选择多行，用\u0026gt;或\u0026lt;缩进或缩出\n使用v来选中删除\nv+d\nv+x\nv+s\nV+G 会选中当前行到最后一行的内容\ncontrol + v 可以进入visual block模式可以按块来选内容\n例子：\n批量删除每一行开头的-app-\ncontrol + v + GIf-d\n如果要批量插入，每一行开头加入-web-\ncontrol + v + GI-web-\n\u0026ndash;\n实用例子： part 1: dt) 删除)前的所有内容\nvf) 选中到)的所有内容包括右括号\nyt) 复制到)前的内容\nct; 删除到;前的所有内容并insert\nciw 删除当前光标所在的单词 change in word\nci\u0026quot; 删除当前光标最近的\u0026quot;\u0026ldquo;里的内容\npart 2: 四种删除if花括号内容的办法（初始光标在if下一行）：\nif { delete me haha wow ya } 1.shift + v 3j d\n2.d 4 d\n3.d i {\n4.d 2 i {\npart 3: \u0026ldquo;testdfat\u0026rdquo;\n假设光标停留在第一个t位置\ndi\u0026rdquo;：delete all content inside \u0026ldquo;，结果字符串为\u0026rdquo;\u0026quot;\ndta：delete all content to a，结果字符串为\u0026quot;at\u0026quot;\ndfa：delete all content from current location, until a is found，结果字符串为\u0026quot;t\u0026quot;\n在vim中的特殊处理（在vscode插件中无效）： 当在visual模式下选中内容按下:可以对选中的多个行做批处理\n比如选中后 :+normal A.png+回车\n会在每个选中行后加上.png的内容\n分享一下我的vimrc配置 https://github.com/Llane00/my-configs/blob/main/.vimrc\n在安装vim 插件时遇到的问题：\n1.you-complete-me无法安装，原因是其中一个依赖在google资源下，那么可以去官方github issue中查找，替换依赖路径\n2.还是ycm插件，首先需要去vim plugin目录下找到you-complete-me目录，找到install.py，手动去安装python3 install.py\n然后安装时发现缺少cmake，那么就另外brew install cmake\n3.完成安装后由于我的电脑上默认的vim版本太旧了，不支持最新的python3提示ycm有报错（没错还是这个插件），\n我重新用brew 安装了vim brew install vim, 下载完毕后需要在zshrc中加一个alias把vim和vi命令指向到brew新下载的vim下\n可以通过brew list vim去找vim下载的地址,这里只要vim和vi对应的地址\n在.zshrc中加入下面两行\nalias vim='/usr/local/xxx/xxx/vim' alias vi='/usr/local/xxx/xxx/vi' 保存并source zshrc后就可以生效使用新的vim了\nyou-complete-me不亏为最难安装的vim 插件\n","description":"","id":21,"section":"posts","tags":["学习笔记"],"title":"Vim使用笔记","uri":"http://llane00.github.io/posts/vim%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/"},{"content":" 这个系列是我读冴羽老师博客的感悟，\n加入了个人的解读和练习题的解答\n 1 2  function Person() {} let Neo = new Person()   Person 是一个构造函数\nNeo是构造函数Person创建的一个实例\n首先所有的函数都有一个prototype属性\nPerson.prototype 代表的是调用Person构造函数创建的实例的原型\n（即Person.prototype是Neo的原型）\n而js中的对象也有指向原型的属性 __proto__\n所以 Person.prototype === Neo.__proto__\n另外原型也有属性constructor可以指向其对应的构造函数\nPerson.prototype.constructor === Person\n原型和原型链是js实现继承的基础\n原型也是一个js对象，所以原型也有__proto__属性\n原型对象其实是构造函数Object创建的一个实例，所以原型的__proto__指向的是Object.prototype\n当在调用一个对象的属性或方法时，如果该对象没有这个属性或方法，此时会去自动找他的原型是否有，如果还是没有则会继续向原型的原型去找，不断重复直到Object.prototype.__proto__，而Object.prototype.__proto__为null(即Object.prototype 没有原型)\n这个向上自动搜索父级原型的过程就是原型链的体现\n即如果Neo没有toString方法，通过原型链\nNeo.toString() 依然可以执行，因为Object有toString方法\n换言之通过原型链Neo可以“获得”Object的所有属性和方法\n我过去经常会困惑函数是个什么东西，它是怎么储存的\n从变量的类型看，分为基本类型和引用类型\n所以函数只能是以引用类型中的对象形式储存的\n那构造函数Person也是一个对象，\n它的__proto__指向了它的原型Function.prototype\n(所有构造函数的上一级原型都是Function.prototype)\n即：\nPerson.__proto__ === Function.prototype\nFunction.prototype.__proto__ === Object.prototype\n同时构造函数Object的上一级原型也是Function.prototype\n我们整理一下： 所有对象的最终原型都是 Object.prototype\n函数的原型是 -\u0026gt; Function.prototype 的原型是 -\u0026gt; Object.prototype 没有原型\n构造函数Object的原型是Function.prototype\n1 2 3  Person.__proto__ === Function.prototype Function.prototype.__proto__ === Object.prototype Object.__proto__ === Function.prototype   之前看到过一个看上去很奇怪的事情，\nFunction.__proto__ === Function.prototype\n目前可以用上面的结论解释：所有（构造）函数的上一级原型都是Function.prototype\n","description":"","id":22,"section":"restart-js","tags":["js基础","学习笔记"],"title":"从头学习js-1-原型与原型链","uri":"http://llane00.github.io/restart-js/1-%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/"},{"content":"大招技能有冷却 == 节流（throttle） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33  /** * 节流原理：在一定时间内，只能触发一次 * * @param {Function} func 要执行的回调函数 * @param {Number} wait 延时的时间 * @param {Boolean} immediate 是否立即执行 * @return null */ let timeout, flag; function throttle(func, wait = 500, immediate = true) { if (immediate) { if (!flag) { flag = true; // 如果是立即执行，则在wait毫秒内开始时执行 \ttypeof func === \u0026#39;function\u0026#39; \u0026amp;\u0026amp; func(); timeout = setTimeout(() =\u0026gt; { flag = false; }, wait); } } else { if (!flag) { flag = true // 如果是非立即执行，则在wait毫秒内的结束处执行 \ttimeout = setTimeout(() =\u0026gt; { flag = false typeof func === \u0026#39;function\u0026#39; \u0026amp;\u0026amp; func(); }, wait); } } }; export default throttle   吟唱技能防打断 == 防抖（debounce） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  /** * 防抖原理：一定时间内，只有最后一次操作，再过wait毫秒后才执行函数 * * @param {Function} func 要执行的回调函数 * @param {Number} wait 延时的时间 * @param {Boolean} immediate 是否立即执行 * @return null */ let timeout = null; function debounce(func, wait = 500, immediate = false) { // 清除定时器 \tif (timeout !== null) clearTimeout(timeout); // 立即执行，此类情况一般用不到 \tif (immediate) { var callNow = !timeout; timeout = setTimeout(() =\u0026gt; { timeout = null; }, wait); if (callNow) typeof func === \u0026#39;function\u0026#39; \u0026amp;\u0026amp; func(); } else { // 设置定时器，当最后一次操作后，timeout不会再被清除，所以在延时wait毫秒后执行func回调方法 \ttimeout = setTimeout(() =\u0026gt; { typeof func === \u0026#39;function\u0026#39; \u0026amp;\u0026amp; func(); }, wait); } } export default debounce   ","description":"","id":23,"section":"posts","tags":["js基础","学习笔记"],"title":"javascript实现节流和防抖","uri":"http://llane00.github.io/posts/js%E8%8A%82%E6%B5%81%E5%92%8C%E9%98%B2%E6%8A%96/"},{"content":"关于Js原型 1 2 3 4 5 6 7 8 9 10 11  // 例子 function Person() { } var person = new Person(); console.log(person.__proto__ == Person.prototype) // true console.log(Person.prototype.constructor == Person) // true // 顺便学习一个ES5的方法,可以获得对象的原型 console.log(Object.getPrototypeOf(person) === Person.prototype) // true   实例与原型 当读取实例的属性时，如果找不到，就会查找与对象关联的原型中的属性，如果还查不到，就去找原型的原型，一直找到最顶层为止。\n原型的原型 原型也是一个对象，原型对象就是通过 Object 构造函数生成的\n由于实例的 proto 指向构造函数的 prototype ，\n所以Person.prototype.proto == Object.prototype\n而再往上Object.prototype.proto == null\n补充   关于constructor: 当获取 person.constructor 时，其实 person 中并没有 constructor 属性,当不能读取到constructor 属性时，会从 person 的原型也就是 Person.prototype 中读取，正好原型中有该属性，所以：\nperson.constructor === Person.prototype.constructor\n  关于__proto__: 绝大部分浏览器都支持这个非标准的方法访问原型，然而它并不存在于 Person.prototype 中，实际上，它是来自于 Object.prototype ，与其说是一个属性，不如说是一个 getter/setter，当使用 obj.__proto__ 时，可以理解成返回了 Object.getPrototypeOf(obj)。\n  关于js的“继承”: 继承意味着复制操作，然而 JavaScript 默认并不会复制对象的属性，相反，JavaScript 只是在两个对象之间创建一个关联，这样，一个对象就可以通过委托访问另一个对象的属性和函数，所以与其叫继承，委托的说法反而更准确些。\n  所有的函数都是 Function 的实例\n  参考资料:  JavaScript深入之从原型到原型链  ","description":"","id":24,"section":"posts","tags":["js基础","学习笔记"],"title":"Js原型","uri":"http://llane00.github.io/posts/js%E5%8E%9F%E5%9E%8B/"},{"content":"常见的定位方案 普通流(normal flow) 在普通流中，元素按照其在HTML中的先后位置至上而下布局，在这个过程中，行内元素水平排列，直到一行被占满后换行，块级元素则会被渲染为完整的一个新行，除非另外指定，否则所有元素默认都是普通流定位。也可以说，普通流中元素的位置由该元素在HTML文档中的位置决定。\n浮动(float) 在浮动布局中，元素首先按照普通流的位置出现，然后根据浮动的方向尽可能的向左边或向右边偏移，其效果与印刷排版中的文本环绕相似。\n绝对定位(absolute position) 在绝对定位布局中，元素会整体脱离普通流，因此绝对定位元素不会对其兄弟元素造成影响，而元素具体的位置由绝对定位的坐标决定。\nBFC 概念 Formatting context（格式化上下文）是W3C CSS2.1 规范中的一个概念。它是页面中的一块渲染区域，并且有一套渲染规则，它决定了其子元素将如何定位，以及和其他元素的关系和相互作用。\nBFC 即 Block Formatting Contexts (块级格式化上下文)，它属于上述定位方案的普通流。\n具有 BFC 特性的元素可以看作是隔离了的独立容器，容器里面的元素不会在布局上影响到外面的元素，并且 BFC 具有普通容器所没有的一些特性。\n通俗一点来讲，可以把 BFC 理解为一个封闭的大箱子，箱子内部的元素无论如何翻江倒海，都不会影响到外部。\nBFC 的触发条件 只要元素满足下面任一条件即可触发 BFC 特性：\n body 根元素 浮动元素：float 除 none 以外的值 绝对定位元素：position (absolute、fixed) display 为 inline-block、table-cells、flex overflow 除了 visible 以外的值 (hidden、auto、scroll)  BFC 的应用  同一个 BFC 下外边距会发生折叠。如果想要避免外边距的重叠，可以将其放在不同的 BFC 容器中。 BFC 可以包含浮动的元素（清除浮动），防止浮动造成高度坍塌。 BFC 可以阻止元素被浮动元素覆盖  参考资料:  10 分钟理解 BFC 原理 CSS盒模型完整介绍  ","description":"","id":25,"section":"posts","tags":["css基础","学习笔记"],"title":"重新理解BFC","uri":"http://llane00.github.io/posts/%E9%87%8D%E6%96%B0%E7%90%86%E8%A7%A3bfc/"},{"content":"背景： 在 JavaScript 里面，数字均为双精度浮点类型，即一个介于±2−1023和±2+1024之间的数字，或约为±10−308到±10+308，数字精度为53位。整数数值仅在±(253 - 1)的范围内可以表示准确。\nJS 的最大和最小安全值可以这样获得:\n1 2  console.log(Number.MAX_SAFE_INTEGER); //9007199254740991 console.log(Number.MIN_SAFE_INTEGER); //-9007199254740991   通过下面的例子，你会明白为什么大于这个值的运算是不安全的:\n1 2 3  var x = 9223372036854775807; console.log(x === x + 1);// output: true console.log(x === x + 1000); //output: true   用js实现正整数大数相加： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  //用字符串表示大数 let x = \u0026#34;9007199254740991\u0026#34;; //Number.MAX_SAFE_INTEGER let y = \u0026#34;99999999999999999999\u0026#34;; //20位大数  function bigNumberAdd(x, y) { //为了把两个数字从个位开始相加，需要补齐位数较小的数，让两个数的位数相等 \tlet maxLength = Math.max(x.length, y.length); //用0补齐位数 \tx = x.padStart(maxLength, 0); y = y.padStart(maxLength, 0); let carryOver = 0; //进位 \tlet resultStr = \u0026#34;\u0026#34;; //最终计算结果 \tfor (let i = maxLength - 1; i \u0026gt;= 0; i--) { let digitSum = parseInt(x[i]) + parseInt(y[i]) + carryOver; let currentDigit = digitSum % 10; //取个位 \tcarryOver = Math.floor(digitSum / 10); //取进位 \tresultStr = currentDigit + resultStr; } //如果进位还有1 \tif (carryOver == 1) { resultStr = \u0026#34;1\u0026#34; + resultStr; } return resultStr; }   ","description":"","id":26,"section":"posts","tags":["js基础","学习笔记"],"title":"Js大数相加","uri":"http://llane00.github.io/posts/js%E5%A4%A7%E6%95%B0%E7%9B%B8%E5%8A%A0/"},{"content":"这次推荐的压缩工具是 optimizt\n稍微看了下，算是一个压缩图片的工具合集\n安装optimizt 1  npm i -g @funboxteam/optimizt   也支持WebStorm, PhpStorm等插件\n also support External Tool in WebStorm, PhpStorm, etc\n DIY一下 optimizt 支持用find命令查找图片\n1  optimizt `find . -type f -name \u0026#39;*.jpg\u0026#39;`   于是我在.bash_profile（或者其他Shell配置文件）中添加别名 + 自定义的搜索方式\n1  alias yasuo=\u0026#39;optimizt `find . -name \u0026#34;*.png\u0026#34; -o -name \u0026#34;*.jpg\u0026#34; -o -name \u0026#34;*.jpeg\u0026#34; -o -name \u0026#34;*.gif\u0026#34; -o -name \u0026#34;*.svg\u0026#34;`\u0026#39;   这个命令可以压缩当前目录下所有找到的jpg/jpeg/png/gif/svg后缀的图片（支持多层目录迭代查找）\n加入参数 -l 后lossless可无损压缩\n1  alias yasuo2=\u0026#39;optimizt -l `find . -name \u0026#34;*.png\u0026#34; -o -name \u0026#34;*.jpg\u0026#34; -o -name \u0026#34;*.jpeg\u0026#34; -o -name \u0026#34;*.gif\u0026#34; -o -name \u0026#34;*.svg\u0026#34;`\u0026#39;   more:\n最后推荐一波自制命令行查看天气工具 llane-weather\n效果如下：\n如果觉得有趣或者有帮助的可以点下github的star，觉得不好用的也可以直接留言告诉我。\n","description":"","id":27,"section":"posts","tags":["命令行"],"title":"使用命令行快速压缩图片","uri":"http://llane00.github.io/posts/%E4%BD%BF%E7%94%A8%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%BF%AB%E9%80%9F%E5%8E%8B%E7%BC%A9%E5%9B%BE%E7%89%87/"}]