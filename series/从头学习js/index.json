[{"content":" 这个系列是我看冴羽老师的博客的理解笔记\n博客原文\n 在MDN广泛定义中闭包指的是能访问自由变量的函数（自由变量指的是即不是这个函数的参数也不是这个函数的内部变量）\n由于函数都有作用域链，所有函数都可以访问到全局上下文中的变量那所有函数其实都是闭包\n在实际场景中，对闭包的定义更加具体，在第7篇的第二个例子中其实遇到了闭包的经典例子\n闭包需要满足：\n1.即使创建它的上下文已经销毁，它仍然存在（比如，内部函数从父函数中返回）\n2.在代码中引用了自由变量\n分析一个例子：\nvar scope = \u0026quot;global scope\u0026quot;; function checkscope(){ var scope = \u0026quot;local scope\u0026quot;; function f(){ return scope; } return f; } var foo = checkscope(); foo(); //这里会打印local scope 例子中的函数f在父函数checkScope中，\n由于父函数会return f且在之后赋值给foo调用了，所以即使父函数checkScope执行结束，函数f也存在\n函数f中引用了父函数中的变量scope所以函数f符合闭包的定义\n通过之前的文章，我们其实知道更深的原因了，就是函数f在创建的时候就根据上下文保存了一个作用域链\n在函数f初始化执行上下文的时候复制了这个作用域链\nf.[[scope]] = [checkscopeContext.AO, globalContext.VO] fContext = { scope: [AO, checkscopeContext.AO, globalContext.VO] } 在沿着作用域链查找scope变量时，AO中没有，而继续查checkscopeContext.AO时找到了scope变量（值为local scope）\n例子2:\nvar data = []; for (var i = 0; i \u0026lt; 3; i++) { data[i] = function () { console.log(i); }; } data[0](); data[1](); data[2](); 这道题是非常经典的闭包问题，当时作为初学者的我无法理解真正的原因最后只能硬记下结论\n现在我们用作用域链和执行上下文的知识点就可以拨开云雾了\n首先for不是函数for 中var声明的i其实是全局变量，\nfor循环执行完后的情况是这样的\nglobalContext = { VO: { data: [ 0: reference to function(){console.log(i)}, //这个匿名函数的内部属性[[scope]]=[globalContext.VO] 1: reference to function(){console.log(i)}, //这个匿名函数的内部属性[[scope]]=[globalContext.VO] 2: reference to function(){console.log(i)}, //这个匿名函数的内部属性[[scope]]=[globalContext.VO] ], i: 3 } } 函数的内部代码如果只是创建是不会去执行的，匿名函数内部还是变量i的指向状态，\n在之后真正开始执行的时候data0,开始创建AO，完善执行上下文的作用域链scope=[AO, globalContext.VO]\nAO中没有i，就找到了globalContext中的i，而此时globalContext中的i已经是3了，\n所以三个匿名函数最后都会打印3\n通常要解决这个问题会用一个新的匿名函数形成闭包或者用let\n我们想在data[0]的执行上下文作用域链接里塞上真正期望的i，scope=[AO, xContext.AO, globalContext.VO]\nxContext.AO中存有不同的i\nvar data = [] for (var i = 0; i \u0026lt; 3; i++) { data[i] = (function(i){ return function(){ console.log(i) } })(i); } data[0](); data[1](); data[2](); (functionx(i){})(i)相当于\nfunction x(i){}\nx(i)\n这个匿名函数会在data[0]的执行上下文的作用域中插入，\n此时data[0]在执行时，作用域变为\ndata[0]Context = { scope: [AO, 匿名函数Context.AO, globalContext.VO] } 匿名函数Context = { AO: { arguments: { 0:0, length: 1 }, i: 0 } } data[0]Context.AO中没有i值，沿着作用域找到了匿名函数Context中的i\n在for循环的时候匿名函数立即执行了才在AO中保留了不同的i，如果没有立即执行也只是保留了一个指向i的值\n","description":"","id":0,"section":"restart-js","tags":["js基础","学习笔记"],"title":"从头学习js-8-闭包","uri":"http://llane00.github.io/restart-js/8-%E9%97%AD%E5%8C%85/"},{"content":" 这个系列是我看冴羽老师的博客的理解笔记\n博客原文\n 本篇是3、4、5、6篇的汇总，会用两个例子来详细说明执行上下文的运行流程\n例子1 var scope = \u0026quot;global scope\u0026quot;; function checkscope(){ var scope = \u0026quot;local scope\u0026quot;; function f(){ return scope; } return f(); } checkscope(); 1.执行全局代码，创建全局上下文，全局上下文压入执行上下栈\nECStack = [ globalContext ] 2.初始化全局上下文\nglobalContext = { VO: [global], scope: [globalContext.VO], this: globalContext.VO } 2.初始化的同时，创建checkScope函数，checkscope函数保存作用域链到函数内部属性\ncheckscope.[[scope]] = [globalContext.VO]; 3.执行checkscope函数，创建checkScope执行上下文，压入执行上下文栈\nECStack = [ checkscopeContext, globalContext ] 4.初始化checkScope执行上下文，\n4.1复制checkscope函数的内部属性[[scope]]创建作用域链\n4.2用arguments创建AO活动对象，\n4.3初始化活动对象，即加入函数形参，函数声明，变量声明\n4.4将活动对象压入checkscope的作用域顶端\ncheckscopeContext = { AO: { arguments: { length: 0 }, scope: undefined, f: reference to fucntion f(){} }, scope: [AO, globalContext.VO], this: undefined } 同时f函数被创建，保存作用域链到f函数内部属性[[scope]]\nf.[[scope]] = [checkscopeContext.AO, globalContext.VO]; 5.执行f函数，创建f函数执行上下文，将其压入执行上下文栈\nECStack = [ fContext, checkscopeContext, globalContext ] 6.f函数执行上下文初始化，\n6.1复制函数[[scope]]属性创建作用域链\n6.2用arguments创建活动对象\n6.3舒适化活动对象，即加入形参，函数声明，变量声明\n6.4将活动对象压入f作用域顶端\nfContext = { AO: { arguments: { length: 0 }, }, scope: [AO, checkScopeContext.AO, globalContext.VO], this: undefined } 7.执行函数f，沿着作用域链找到scope的值，返回scope的值\n8.函数f执行完毕后，在ECStack中出栈\nECStack.pop() ECStack = [ checkscopeContext, globalContext ] 9.函数checkScope执行完毕后在ECStack出栈，\nECStack.pop() ECStack = [ globalContext ] 例子2 例子2和例子很相似\nvar scope = \u0026quot;global scope\u0026quot;; function checkscope(){ var scope = \u0026quot;local scope\u0026quot;; function f(){ return scope; } return f; } checkscope()(); 1.开始执行全局代码，创建全局上下文，并将其压入上下文执行栈\nECStack = [ globalContext ] 2.初始化全局上下文\nglobalContext = { VO: [global], scope: globalContext.VO, this: globalContext.VO } 2.初始化的同时创建函数checkscope，函数checkScope保存作用域链到其内部属性[[scope]]\ncheckscope.[[scope]] = [globalContext.VO]; 3.执行函数checkScope，创建checkScope函数的执行上下文，并将其压入上下文执行栈\nECStack = [ checkScopeContext, globalContext ] 4.初始化checkScope执行上下文，\n4.1保存函数的内部属性[[scope]]到执行上下文的作用域链\n4.2根据函数的arguments创建活动对象AO\n4.3初始化活动对象，即加入函数形参，函数声明，变量声明\n4.4将活动对象压入checkscope作用域的顶端\ncheckScopeContext = { AO: { arguments: { length: 0 }, scope: undefined, f: reference to fucntion f(){} }, scope: [AO, globalContext], this: undefined } 4.同时创建函数f，保存作用域链到f函数内部属性[[scope]]\nf.[[scope]] = [checkscopeContext.AO, globalContext.VO]; 5.沿着作用域找到函数f的指向，返回函数f的指向，函数checkScope执行完毕后在ECStack出栈\nECStack.pop() ECStack = [ globalContext ] 6.执行checkScope返回的函数f，创建函数f的执行上下文，将其压入执行上下文栈\nECStack = [ fContext, globalContext ] 7.初始化f的执行上下文fContext\n7.1复制函数内部属性scope到函数上下文的作用域链\n7.2根据函数的arguments创建活动对象AO\n7.3初始化活动对象，即加入函数形参，函数声明，变量声明\n7.4将活动对象压入函数上下文作用域链的顶端\nfContext = { AO: { arguments: { length: 0 } } scope: [AO, checkScopeContext.AO, globalContext] this: undefined } 8.执行函数f，沿着作用域链找到scope的值（这里是在checkScopeContext.AO里找到scope的，即便checkScopeContext.AO已经在ECStack中出栈，这就是闭包的原理），返回scope的值\n7.函数f执行完毕后，f的执行上下文从执行上下文栈中弹出\nECStack.pop() ECStack = [ globalContext ] ","description":"","id":1,"section":"restart-js","tags":["js基础","学习笔记"],"title":"从头学习js-7-执行上下文汇总篇","uri":"http://llane00.github.io/restart-js/7-%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E6%B1%87%E6%80%BB%E7%AF%87/"},{"content":" 这个系列是我看冴羽老师的博客的理解笔记\n博客原文\n this一直都是学习js的时候很头疼的东西，\n继续接着上篇说，当javascript代码执行一段可执行代码(executable code)时，会创建对应的执行上下文(execution context)\n那对于每个执行上下文，都有三个重要属性：\n 变量对象(Variable object, VO) 作用域链(Scope chain) this  本文主要讲执行上下文中的this\n首先了解ECMAScript规范 我们根据ECMAScript规范来解读this\nECMAScript 5.1 规范地址：\n英文版：http://es5.github.io/#x15.1\n中文版：http://yanhaijing.com/es5/#115\njavascript 有8种数据类型，Undefined,Null,Boolean,Number,String,Object,Symbol,Bigint\n这是我们在编程时可以直接操作使用的数据类型，\n在javascript的底层逻辑中还有一些只存在于规范里的抽象类型：\nReference，\nList，\nCompletion，\nProperty，\nDescriptor，\nProperty Identifier，\nLexical Environment，\nEnvironment Record\n这些规范类型是用算法描述ECMAScript语言结构和语言类型的，\n其中与this的指向有关的是Reference类型\nReference由三个部分组成：\n1.base value (属性所在的对象或者是EnvironmentRecord，所以它的值只能是undefined, an Object, a Boolean, a String, a, Number or an environment record)\n2.reference name (属性名称)\n3.strict reference\n举个例子：\nvar foo = 1; //foo对应的Reference是 var fooReference = { base: EnvironmentRecoed, name: 'foo', strict: false } var foo = { bar: function() { return this; } } foo.bar(); //bar对应的Reference是 var barReference = { base: foo, propertyName: 'bar', strict: false }; Reference涉及到的方法有：\n1.GetBase 返回base value\n2.isProperty 判断base value是不是一个对象\n3.GetVlaue 从Reference处返回一个真正的值（具体的值，不是Reference）\n按步骤确定this的指向 规范中确定this的值，有明确的步骤判断：\n1.计算MemberExpression的结果赋值给ref\n2.判断ref是不是一个Reference类型\n2.1 如果ref是Reference，并且base value值是一个对象（isProperty(ref)为true），那么this的值就是base value（用getBase获得）\n2.2 如果ref是Reference，并且base value值是Environment Record，那么this的值是ImplicitThisValue(ref)\n2.3 如果ref不是Reference，那么this的值是undefined\n步骤1中 MemberExpression分别有：\nPrimaryExpression //原始表达式\nFunctionExpression //函数表达式\nMemberExpression [Expression] //属性[]访问表达式\nMemberExpression.IdentifierName //属性.访问表达式\nnew MemberExpression Arguments //对象创建表达式\n例子：\nfunction foo() { console.log(this) } foo(); //MemberExpression是foo function foo() { return function () { console.log(this) } } foo()(); //MemberExpression是foo() var foo = { bar: function() { return this } } foo.bar(); //MemberExpression是foo.bar 可以简单判断MemberExpression是()左边的部分\n步骤2中判断ref是不是一个Reference类型\n例子：\nvar value = 1; var foo = { value: 2, bar: function() { return this.value; } } //example1 console.log(foo.bar()) //example2 console.log((foo.bar)()) //example3 console.log((foo.bar = foo.bar)()) //example4 console.log((false || foo.bar)()) //example5 console.log((foo.bar, foo.bar)()) example1\nMemberExpression为foo.bar属于规范11.2中提到的属性访问，他会返回一个值类型的引用\n所以foo.bar会返回一个Reference类型\nvar Reference = { base: foo, name: 'bar', strict: false } 符合确定this的步骤中2.1，IsPropertyReference(ref) 为 true，且base value为foo\n所以this指向foo\nconsole.log打印1\nexample2\n(foo.bar)是规范11.1.6中提到的分组表达式，会返回一个Reference类型，\n后面的步骤和example1一样所以this指向foo\nconsole.log打印1\nexample3\n(foo.bar = foo.bar)是规范11.13.1中提到的简单赋值会返回一个rval不是一个Reference，\n对照this判断步骤的2.3，this的值就是undefined（非严格模式下会隐式转换为全局变量，浏览器中就是window）\nconsole.log打印2\nexample4\n(false || foo.bar)是规范11.11中提到的二元逻辑运算符会返回GetValue(rref)不是一个Reference，\n对照this判断步骤2.3，this的值就是undefined\nconsole.log打印2\nexample5\n(foo.bar, foo.bar)是规范11.14中提到的逗号运算符会返回GetValue(rref)不是一个Reference，\n对照this判断步骤2.3，this的值是undefined\nconsole.log打印2\n看一个最常见的情况\n//example6 function foo() { console.log(this) } foo() MemberExpression是foo，是规范10.3.1中提到的标识符解析会返回一个引用对象Reference，\nvar fooReference = { base: Environment, name: 'foo', strict: false } 对照this判断步骤2.2, this的值为 ImplicitThisValue(ref)\n在规范10.2.1.1.6中对ImplicitThisValue的解释他始终返回undefined\n所以this指向undefined\n不管怎么样按照规范去解读this指向从步骤和逻辑上是更为清晰的\n","description":"","id":2,"section":"restart-js","tags":["js基础","学习笔记"],"title":"从头学习js-6-This","uri":"http://llane00.github.io/restart-js/6-this/"},{"content":"React理念：UI = f(data)\n纯函数在加载不同数据后产生了不同的UI\nuseState const [n, setN] = useState(0); console.log(n) //读 onClick = () =\u0026gt; (setN(n+1)) //写 onClick2 = () =\u0026gt; (setN(i =\u0026gt; i + 1)) //也支持传入一个匿名函数 随着组件更新render，useState会产生多个n，但每次get的n是最新的n\n组件每次重新渲染，组件里的函数都会重新执行，\n对应的所有state都会出现重复分身\n如果你不希望出现重复分身的变量\n可以用useRef/useContext等\n如：\nconst nRef = useRef(0); console.log(nRef.current); onClick = () =\u0026gt; (nRef.current += 1) useState 不能局部更新\nuseState 如果数据地址没变那么react就不会重新render更新\n如果useState的对象生成复杂建议把初始值写成一个匿名函数，不然每次重新渲染时都要做多余的计算开销\nuseState(() =\u0026gt; ({ name: ’neo' }))\nsetState会合并多个同级别的对n的操作，\n如：\nsetN(n+1) setN(n+1) setN(n+1) //这段代码只会执行会后一行的setN(n+1) setN(n+1) setN(n+2) setN(n+3) //同上也只会执行最后的setN(n+3) 所以setState 建议传入一个匿名函数方法，可以防止上面的合并操作，也可以防止代码出现过时的闭包，\n比如: setN(i =\u0026gt; i + 1)\nuseReducer useReducer 是一个把对state的所有操作都聚拢在内的useState\n用来践行flux思想，具体过程如下：\n1.创建初始值 initialState\n2.创建所有操作 reducer(state, action)\n3.传给useReducer，得到读和写api\n4.调用时写 ({ type: ‘操作类型' })\nredux主要做到了：\n1.集中管理全局状态和对状态的操作\n2.提供所有子组件可以在上下文中读写全局状态\nuseContext 现在可以用useState/useReducer和useContext来代替redux\nconst AppContext = React.createContext(null) //可以用useState生成读写 const [name, setName] = useState('the_one'); //也可以用useReducer来生成读写 const initialState = {age:0, sex:'male'} const reducer = (prevState, action) =\u0026gt; { swicth (action.type) { case 'age': return { ...prevState, age: action.payload } case 'sex': return { ...prevState, sex: action.payload } default: throw new Error('error action type') break; } } const [ personInfo, dispatch ] = useReducer(reducer, initialState) //用AppContext.Provider来包裹，在value中传入要全局使用的读写name操作 \u0026lt;AppContext.Provider value={{name, setName, personInfo, dispatch}}\u0026gt; \u0026lt;CompontentA/\u0026gt; \u0026lt;CompontentB/\u0026gt; \u0026lt;/AppContext.Provider\u0026gt; //在组件A和组件B中就可以获取context中的vaule //const {name, setName, personInfo, dispatch} = useContext(AppContext) setName('Neo') dispatch({ type: 'age', payload: '25' }) console.log(name, personInfo) useEffect useEffect（定义：执行在render后的副作用）\n依赖参数中数组里的值的变化来决定是否要执行函数\nApp() -\u0026gt; 执行 -\u0026gt; VDOM(VNode)\n-\u0026gt; DOM -\u0026gt;useLayoutEffect -\u0026gt; 浏览器改变外观 -\u0026gt; useEffect\nuseEffect在浏览器渲染完成后执行\nuseLayoutEffect 在浏览器渲染前执行\nuseLayoutEffect总是比useEffect先执行，\nuseLayoutEffect里的任务最好是影响了useEffect\nuseMemo \u0026amp;\u0026amp; useCallBack useMemo 可以实现函数的重用，防止在多次render的时候做不必要的重复创建和执行函数\n第一个参数是 ()=\u0026gt;value\n第二个参数是依赖 [m,n]\n只有当依赖不变时，才会计算新的value，\n如果依赖不变，那么就重用之前的value\n（vue2 computed？）\n如果value是一个函数，那么要写成\n()=\u0026gt; ((x)=\u0026gt; console.log(x))\n可以用useCallBack简化\nuseCallback(x=\u0026gt;log(x), [m]) 等价于\nuseMemo(() =\u0026gt; x =\u0026gt; log(x), [m])\nuseRef useRef的目的：在组件不断render时，需要一个值保持不变，比如可以累积计算之类的\nuseRef 原理：用对象的形式来存变量，在对象里可以做到改变对象的值，而不变对象的地址\n为了保证值不变，所以使用引用\n初始化：const count = useRef(0)\n读取：count.current\n汇总 App() 重复 rendering…\n每次变 useState/useRender，setN会触发重新render\n有条件时变 useMemo/useCallBack，防止函数有多余的render\n不变 useRef ，改变值不会触发重新render\n（vue3 ref值有变化会自动render）\nReact.forwardRef 我们可以给一个函数组件一个ref来方便引用一个组件（就可以不用getElementById了），\n但是函数式组件不能直接用useRef产生的ref（class组件可以直接用），因为函数式组件的props里不包含ref\n此时需要用React.forwardRef包裹一下函数组件来获得ref\nfunction App() { const buttonRef = useRef(null); return ( \u0026lt;div className=\u0026quot;app\u0026quot;\u0026gt; \u0026lt;Button2 ref={buttonRef}\u0026gt;按钮\u0026lt;/Button2\u0026gt; \u0026lt;/div\u0026gt; ) } const Button2 = React.forward((props, ref) =\u0026gt; { return \u0026lt;button className=\u0026quot;red\u0026quot; ref={ref} {…props} /\u0026gt; }) useImpreativeHandle useImpreativeHandle 可以以ref为参数返回一个自定义的ref对象\n自定义hooks 自定义hooks是 对已有的基础react hooks互相组合的封装\n","description":"","id":3,"section":"posts","tags":null,"title":"学习React_hooks_1","uri":"http://llane00.github.io/posts/react_hooks_1/"},{"content":" 这个系列是我看冴羽老师的博客的理解笔记\n博客原文\n 上篇说到，当javascript代码执行一段可执行代码(executable code)时，会创建对应的执行上下文(execution context)\n那对于每个执行上下文，都有三个重要属性：\n 变量对象(Variable object, VO) 作用域链(Scope chain) this  本文主要讲执行上下文中的作用域链，注意本章将会把之前的内容穿起来很重要\n在之前第2篇作用域和第4篇变量对象中有提到，\n当查到变量时首先从当前上下文的变量对象中查到，\n如果没有找到会从父级（词法静态层面上的）执行上下文的变量对象中查找，\n一直找到全局变量对象（全局对象）\n这样由多个执行上下文的变量对象构成的链表就叫做作用域链\n函数创建 在第2篇中提到js中函数的作用域在函数定义的时候就决定了\n这是因为函数有一个内部属性`[[scope]]``, 当函数创建的时候会把函数的父变量对象保存到其中，但不是完整的作用链\n如：\nfunction foo() { function bar() { ... } } 此时函数的各自作用域为：\nfoo.[[scope]] = [ globalContext.VO ]; bar.[[scope]] = [ fooContext.AO, globalContext.VO ]; 函数激活 当函数激活的时候，进入函数上下文，创建VO/AO后，就会将函数活动对象加到作用域的最前端，\nScope = [AO].concat([[scope]]) 此时作用域链创建完毕\n总结事例 例子：\nvar scope = 'global scope'; function checkscope() { var scope2 = 'local scope'; return scope2; } checkscope(); 函数执行上下文中作用域和变量对象创建过程如下：\n1.checkscope函数被创建，保存作用域到内部属性[[scope]]\ncheckscope.[[scope]] = [ globalContext.VO ] 2.执行checkscope函数，创建checkscope函数执行上下文，checkscope函数执行上下文压入执行上下栈\nECStack = [ checkscopeContext, globalContext ]; 3.checkscope函数进入准备阶段\n3.1 复制函数内部属性[[scope]]到函数执行上文中\ncheckscopeContext = { Scope: checkscope.[[scope]] } 3.2 用函数的arguments属性创建活动对象，随后初始化活动对象，加入形参、函数声明、变量声明\ncheckscopeContext = { AO: { arguments: { length: 0, }, scope2: undefined }, Scope: checkscope.[[scope]] } 3.3 将活动对象压入作用域顶端\ncheckscopeContext = { AO: { arguments: { length: 0, }, scope2: undefined }, Scope: [AO, [[scope]]] } 准备工作完毕\n4.开始执行checkscope函数，随着函数执行，修改AO的属性值\ncheckscopeContext = { AO: { arguments: { length: 0, }, scope2: 'local scope' }, Scope: [AO, [[scope]]] } 5.查找到scope2的值，返回后函数执行完毕，checkscope函数上下文从执行上下文中弹出\nECStack = [ globalContext ] ","description":"","id":4,"section":"restart-js","tags":["js基础","学习笔记"],"title":"从头学习js-5-作用域链","uri":"http://llane00.github.io/restart-js/5-%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE/"},{"content":" 这个系列是我看冴羽老师的博客的理解笔记\n博客原文\n 上篇说到，当javascript代码执行一段可执行代码(executable code)时，会创建对应的执行上下文(execution context)\n那对于每个执行上下文，都有三个重要属性：\n 变量对象(Variable object, VO) 作用域链(Scope chain) this  本文主要讲执行上下文中的变量对象\n变量对象 变量对象是与执行上下文相关的数据作用域，储存了在上下文中定义的变量和函数声明\n因为不同执行上下文的变量对象稍有不同，这里分全局上下文下的变量对象和函数上下文下的变量对象来讨论。\n全局上下文的变量对象就是全局对象，是全局变量的宿主。\n在浏览器中，全局中的this和window都指向全局变量\n函数上下文中的变量对象称为活动对象（activation object，AO）\n活动对象就是变量对象，只是函数上下文中的变量对象只有函数代码在执行到被激活时才能被访问到，\n活动对象就是在进入函数上下文时被创建的，它通过函数的arguments属性初始化。\n执行上下文生命周期：  创建执行上下文阶段\n创建变量对象，建立作用域，以及明确this的指向    变量对象包括：\n 函数所有形参   由名称和对应值组成的一个变量对象的属性被创建 没有实参，属性值设为undefined  函数声明（函数声明优先于变量声明）   由名称和对应值（函数对象（function-object））组成的一个变量对象的属性被创建 如果变量对象已经存在相同名称的属性，则完全替换这个属性  变量声明   由名称和对应值（undefined）组成的一个变量对象的属性被创建 如果变量名称和已经声明的形式参数或函数相同，则变量声明不会干扰已经存在的这类属性    执行代码阶段\n创建上下文后，开始执行代码，  例子：\nfunction foo(a) { var b = 2; function c() {} var d = function() {}; b = 3; } foo(1) 在进入执行上下文后，此时的AO为\nAO = { //AO通过函数的arguments初始化，是一个伪数组 arguments: { 0: 1, length: 1 }, //函数所有形参 由名称和对应值组成的一个变量对象的属性被创建 a: 1, //变量声明 名称和对应值（undefined）组成的一个变量对象的属性被创建 b: undefined, //函数声明 由名称和对应值（函数对象（function-object））组成的一个变量对象的属性被创建 c: reference to function c(){}, //同上变量声明 d: undefined } 函数执行后：\n按顺序执行代码，初始化变量和给变量赋值\nAO = { arguments: { 0: 1, length: 1 }, a: 1, b: 3, c: reference to function c() {}, d: reference to FunctionExpression \u0026quot;d\u0026quot; } 关于声明变量和函数时的补充: 这里认为声明变量和函数都有三个阶段：\n1.创建create\n2.初始化initialize（声明时首次初始化不同于第三步的assign）\n3.赋值assign\n关于声明语法的结论是：\nfunction 的「创建」「初始化」和「赋值」都被提升了。\nvar 的「创建」和「初始化」都被提升了。\nlet 的「创建」过程被提升了，但是初始化没有提升，拥有块级作用(暂时性死区)。\nconst 只有创建和初始化，没有「赋值」,「创建」过程被提升了，拥有块级作用(暂时性死区)\n通常认为const不可变是片面的，\n首先const必须初始化，且在栈中储存的值不可修改，\n但当const声明的是引用类型时，堆中的储存值可以改变\n如：\nconst obj = {name: 'Neo', age: 20} obj.age = 25 console.log(obj) //{name: 'Neo', age: 25} 如果不通过关键词var let等声明变量，AO中不会创建对应该变量的key-value\n但是当这个变量被赋值assign的时候会创建变量对象到VO中\nmore 参考资料：  关于let的变量提升？探究 https://zhuanlan.zhihu.com/p/28140450/  ","description":"","id":5,"section":"restart-js","tags":["js基础","学习笔记"],"title":"从头学习js-4-变量对象","uri":"http://llane00.github.io/restart-js/4-%E5%8F%98%E9%87%8F%E5%AF%B9%E8%B1%A1/"},{"content":" 这个系列是我看冴羽老师的博客的理解笔记\n博客原文\n 我们知道在js中有变量提升，\n所以js引擎在解析代码的时候不是一行一行去执行的，而是一段一段去分析\n（暂且以函数花括号来划分段）\n实际环境中的函数可能是一层套一层执行的，加上函数有各自的静态作用域\njavascript引擎创建了执行上下文栈（Execution context stack，ECS）来管理这些情况\n由于函数的执行是有顺序的，执行上下文栈是先进后出的栈结构\n我们这里用数组来模拟它\nECStack = [] 首先执行全局代码，此时在ECStack中压入一个 globalContext\nECStack = [ globalContext ] 然后我们执行下面的实例代码\nfunction a() { console.log(\u0026quot;run a\u0026quot;) b() } function b() { console.log(\u0026quot;run b\u0026quot;) } a() 首先执行a函数，在ECStack中压入函数a的执行上下文，\nECStack = [ \u0026lt;a\u0026gt; functionContext, globalContext ] 发现执行函数a中，需要执行b函数（此时a还没执行完，没有出栈），在ECStack中压入函数b的执行上下文\nECStack = [ \u0026lt;b\u0026gt; functionContext, \u0026lt;a\u0026gt; functionContext, globalContext ] 函数b执行完后，函数b的执行上下文出栈，ECStack.pop()\n然后函数a也执行完了，继续 ECStack.pop()\n就是这么一个执行栈\n另一个例子：\n代码A\nvar scope = \u0026quot;global scope\u0026quot;; function checkscope(){ var scope = \u0026quot;local scope\u0026quot;; function f(){ return scope; } return f(); } checkscope(); 代码B\nvar scope = \u0026quot;global scope\u0026quot;; function checkscope(){ var scope = \u0026quot;local scope\u0026quot;; function f(){ return scope; } return f; } checkscope()(); 首先代码A和代码B 都会打印 localscope，具体原因在上一篇作用域中有解释\n但不同的是A和B的执行上下文的顺序不同\n伪代码是这样的\n//代码A ECStack.push(\u0026lt;checkscope\u0026gt; functionContext) ECStack.push(\u0026lt;f\u0026gt; functionContext) ECStack.pop() //f 执行结束 ECStack.pop() //checkscope 执行结束 //代码B ECStack.push(\u0026lt;checkscope\u0026gt; functionContext) ECStack.pop() //checkcope 执行结束 ECStack.push(\u0026lt;f\u0026gt; functionContext) ECStack.pop() //f 执行结束 ","description":"","id":6,"section":"restart-js","tags":["js基础","学习笔记"],"title":"从头学习js-3-执行上下文栈","uri":"http://llane00.github.io/restart-js/3-%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E6%A0%88/"},{"content":" 这个系列是我看冴羽老师的博客的理解笔记\n博客原文\n 作用域是程序如何储存和获取变量的约定\njavascript采用了词法作用域（即静态作用域）\n静态作用域在函数创建的时候就记下了，会在函数代码的书写位置层级向上查找变量\n动态作用域在函数调用的时候才决定，会在函数调用栈中依次向上查找变量\nvar value = 1; function foo() { console.log(value); } function bar() { var value = 2; foo(); } bar(); 以上代码在静态作用域情况下会打印1\n在动态作用域情况下会打印2\n","description":"","id":7,"section":"restart-js","tags":["js基础","学习笔记"],"title":"从头学习js-2-作用域","uri":"http://llane00.github.io/restart-js/2-%E4%BD%9C%E7%94%A8%E5%9F%9F/"},{"content":"normal 模式\ninsert 模式\nvisual 模式\ncontrol + [ 从insert/visual回到normal\nesc 也是从insert/visual回到normal\nnormal 模式下 hjkl 移动光标左下上右\na 在光标后insert\ni 在光标前insert\nshift + a 在当前行结尾处insert\nshift + i 在当前行开头处insert\ngg 光标跳转到文档第一行\nshift + g 光标跳转到文档最后一行\n: + 行号 + 回车 光标跳转到文行特定的行\n数字 + j/k 光标上下移动指定行数\n数字 + w/b 光标左右移动指定的单词个数\n[[ 光标跳转到文档第一行\n]] 光标跳转到文档最后一行\nshift + { 光标跳转到下一个段落\nshift + } 光标跳转到上一个段落\ncontrol + u 向下翻页\ncontrol + d 向上翻页\n% 用于在 () {} 之间跳转\nzz 将当前行剧中到屏幕中\no 换行insert\nshift + o 在上一行空一行insert\n/ + 字符为搜索 （n 和 shift + n 可以继续上下选择）\nf + 字符 光标定位到字符上（;继续下一个 ,继续上一个）\nt + 字符 光标定位到字符前（;继续下一个 ,继续上一个）\nyy 复制当前行\ndd 剪切当前行（删除）\nshift + d 删除当前行光标后的内容\nshift + d 删除当前行光标后的内容 + insert\np 黏贴内容到当前行的下一行\nshift + p 黏贴内容到当前行的上一行\nu 撤销\nx 删除光标选中内容\ns 删除光标选中内容并insert\nshift + s 删除当前行并insert\ncw 等价于 dwi\nvisual 模式下 v 单个字选择模式\nshift + v 行选择模式\n需要选中缩进的时候，按v(或V)进入visual状态，选择多行，用\u0026gt;或\u0026lt;缩进或缩出\n使用v来选中删除\nv+d\nv+x\nv+s\nV+G 会选中当前行到最后一行的内容\ncontrol + v 可以进入visual block模式可以按块来选内容\n例子：\n批量删除每一行开头的-app-\ncontrol + v + GIf-d\n如果要批量插入，每一行开头加入-web-\ncontrol + v + GI-web-\n\u0026ndash;\n实用例子： part 1: dt) 删除)前的所有内容\nvf) 选中到)的所有内容包括右括号\nyt) 复制到)前的内容\nct; 删除到;前的所有内容并insert\nciw 删除当前光标所在的单词 change in word\nci\u0026quot; 删除当前光标最近的\u0026quot;\u0026ldquo;里的内容\npart 2: 四种删除if花括号内容的办法（初始光标在if下一行）：\nif { delete me haha wow ya } 1.shift + v 3j d\n2.d 4 d\n3.d i {\n4.d 2 i {\npart 3: \u0026ldquo;testdfat\u0026rdquo;\n假设光标停留在第一个t位置\ndi\u0026rdquo;：delete all content inside \u0026ldquo;，结果字符串为\u0026rdquo;\u0026quot;\ndta：delete all content to a，结果字符串为\u0026quot;at\u0026quot;\ndfa：delete all content from current location, until a is found，结果字符串为\u0026quot;t\u0026quot;\n在vim中的特殊处理（在vscode插件中无效）： 当在visual模式下选中内容按下:可以对选中的多个行做批处理\n比如选中后 :+normal A.png+回车\n会在每个选中行后加上.png的内容\n分享一下我的vimrc配置 https://github.com/Llane00/my-configs/blob/main/.vimrc\n在安装vim 插件时遇到的问题：\n1.you-complete-me无法安装，原因是其中一个依赖在google资源下，那么可以去官方github issue中查找，替换依赖路径\n2.还是ycm插件，首先需要去vim plugin目录下找到you-complete-me目录，找到install.py，手动去安装python3 install.py\n然后安装时发现缺少cmake，那么就另外brew install cmake\n3.完成安装后由于我的电脑上默认的vim版本太旧了，不支持最新的python3提示ycm有报错（没错还是这个插件），\n我重新用brew 安装了vim brew install vim, 下载完毕后需要在zshrc中加一个alias把vim和vi命令指向到brew新下载的vim下\n可以通过brew list vim去找vim下载的地址,这里只要vim和vi对应的地址\n在.zshrc中加入下面两行\nalias vim='/usr/local/xxx/xxx/vim' alias vi='/usr/local/xxx/xxx/vi' 保存并source zshrc后就可以生效使用新的vim了\nyou-complete-me不亏为最难安装的vim 插件\n","description":"","id":8,"section":"posts","tags":["学习笔记"],"title":"Vim使用笔记","uri":"http://llane00.github.io/posts/vim%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/"},{"content":" 这个系列是我看冴羽老师的博客的理解笔记\n博客原文\n function Person() {} let Neo = new Person() Person 是一个构造函数\nNeo是构造函数Person创建的一个实例\n首先所有的函数都有一个prototype属性\nPerson.prototype 代表的是调用Person构造函数创建的实例的原型\n（即Person.prototype是Neo的原型）\n而js中的对象也有指向原型的属性 __proto__\n所以 Person.prototype === Neo.__proto__\n另外原型也有属性constructor可以指向其对应的构造函数\nPerson.prototype.constructor === Person\n原型和原型链是js实现继承的基础\n原型也是一个js对象，所以原型也有__proto__属性\n原型对象其实是构造函数Object创建的一个实例，所以原型的__proto__指向的是Object.prototype\n当在调用一个对象的属性或方法时，如果该对象没有这个属性或方法，此时会去自动找他的原型是否有，如果还是没有则会继续向原型的原型去找，不断重复直到Object.prototype.__proto__，而Object.prototype.__proto__为null(即Object.prototype 没有原型)\n这个向上自动搜索父级原型的过程就是原型链的体现\n即如果Neo没有toString方法，通过原型链\nNeo.toString() 依然可以执行，因为Object有toString方法\n换言之通过原型链Neo可以“获得”Object的所有属性和方法\n我过去经常会困惑函数是个什么东西，它是怎么储存的\n从变量的类型看，分为基本类型和引用类型\n所以函数只能是以引用类型中的对象形式储存的\n那构造函数Person也是一个对象，\n它的__proto__指向了它的原型Function.prototype\n(所有构造函数的上一级原型都是Function.prototype)\n即：\nPerson.__proto__ === Function.prototype\nFunction.prototype.__proto__ === Object.prototype\n同时构造函数Object的上一级原型也是Function.prototype\n我们整理一下： 所有对象的最终原型都是 Object.prototype\n函数的原型是 -\u0026gt; Function.prototype 的原型是 -\u0026gt; Object.prototype 没有原型\n构造函数Object的原型是Function.prototype\nPerson.__proto__ === Function.prototype Function.prototype.__proto__ === Object.prototype Object.__proto__ === Function.prototype 之前看到过一个看上去很奇怪的事情，\nFunction.__proto__ === Function.prototype\n目前可以用上面的结论解释：所有（构造）函数的上一级原型都是Function.prototype\n","description":"","id":9,"section":"restart-js","tags":["js基础","学习笔记"],"title":"从头学习js-1-原型与原型链","uri":"http://llane00.github.io/restart-js/1-%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/"},{"content":"大招技能有冷却 == 节流（throttle） /** * 节流原理：在一定时间内，只能触发一次 * * @param {Function} func 要执行的回调函数 * @param {Number} wait 延时的时间 * @param {Boolean} immediate 是否立即执行 * @return null */ let timeout, flag; function throttle(func, wait = 500, immediate = true) { if (immediate) { if (!flag) { flag = true; // 如果是立即执行，则在wait毫秒内开始时执行 typeof func === 'function' \u0026amp;\u0026amp; func(); timeout = setTimeout(() =\u0026gt; { flag = false; }, wait); } } else { if (!flag) { flag = true // 如果是非立即执行，则在wait毫秒内的结束处执行 timeout = setTimeout(() =\u0026gt; { flag = false typeof func === 'function' \u0026amp;\u0026amp; func(); }, wait); } } }; export default throttle 吟唱技能防打断 == 防抖（debounce） /** * 防抖原理：一定时间内，只有最后一次操作，再过wait毫秒后才执行函数 * * @param {Function} func 要执行的回调函数 * @param {Number} wait 延时的时间 * @param {Boolean} immediate 是否立即执行 * @return null */ let timeout = null; function debounce(func, wait = 500, immediate = false) { // 清除定时器 if (timeout !== null) clearTimeout(timeout); // 立即执行，此类情况一般用不到 if (immediate) { var callNow = !timeout; timeout = setTimeout(() =\u0026gt; { timeout = null; }, wait); if (callNow) typeof func === 'function' \u0026amp;\u0026amp; func(); } else { // 设置定时器，当最后一次操作后，timeout不会再被清除，所以在延时wait毫秒后执行func回调方法 timeout = setTimeout(() =\u0026gt; { typeof func === 'function' \u0026amp;\u0026amp; func(); }, wait); } } export default debounce ","description":"","id":10,"section":"posts","tags":["js基础","学习笔记"],"title":"javascript实现节流和防抖","uri":"http://llane00.github.io/posts/js%E8%8A%82%E6%B5%81%E5%92%8C%E9%98%B2%E6%8A%96/"},{"content":"关于Js原型 // 例子 function Person() { } var person = new Person(); console.log(person.__proto__ == Person.prototype) // true console.log(Person.prototype.constructor == Person) // true // 顺便学习一个ES5的方法,可以获得对象的原型 console.log(Object.getPrototypeOf(person) === Person.prototype) // true 实例与原型 当读取实例的属性时，如果找不到，就会查找与对象关联的原型中的属性，如果还查不到，就去找原型的原型，一直找到最顶层为止。\n原型的原型 原型也是一个对象，原型对象就是通过 Object 构造函数生成的\n由于实例的 proto 指向构造函数的 prototype ，\n所以Person.prototype.proto == Object.prototype\n而再往上Object.prototype.proto == null\n补充   关于constructor: 当获取 person.constructor 时，其实 person 中并没有 constructor 属性,当不能读取到constructor 属性时，会从 person 的原型也就是 Person.prototype 中读取，正好原型中有该属性，所以：\nperson.constructor === Person.prototype.constructor\n  关于__proto__: 绝大部分浏览器都支持这个非标准的方法访问原型，然而它并不存在于 Person.prototype 中，实际上，它是来自于 Object.prototype ，与其说是一个属性，不如说是一个 getter/setter，当使用 obj.__proto__ 时，可以理解成返回了 Object.getPrototypeOf(obj)。\n  关于js的“继承”: 继承意味着复制操作，然而 JavaScript 默认并不会复制对象的属性，相反，JavaScript 只是在两个对象之间创建一个关联，这样，一个对象就可以通过委托访问另一个对象的属性和函数，所以与其叫继承，委托的说法反而更准确些。\n  所有的函数都是 Function 的实例\n  参考资料:  JavaScript深入之从原型到原型链  ","description":"","id":11,"section":"posts","tags":["js基础","学习笔记"],"title":"Js原型","uri":"http://llane00.github.io/posts/js%E5%8E%9F%E5%9E%8B/"},{"content":"常见的定位方案 普通流(normal flow) 在普通流中，元素按照其在HTML中的先后位置至上而下布局，在这个过程中，行内元素水平排列，直到一行被占满后换行，块级元素则会被渲染为完整的一个新行，除非另外指定，否则所有元素默认都是普通流定位。也可以说，普通流中元素的位置由该元素在HTML文档中的位置决定。\n浮动(float) 在浮动布局中，元素首先按照普通流的位置出现，然后根据浮动的方向尽可能的向左边或向右边偏移，其效果与印刷排版中的文本环绕相似。\n绝对定位(absolute position) 在绝对定位布局中，元素会整体脱离普通流，因此绝对定位元素不会对其兄弟元素造成影响，而元素具体的位置由绝对定位的坐标决定。\nBFC 概念 Formatting context（格式化上下文）是W3C CSS2.1 规范中的一个概念。它是页面中的一块渲染区域，并且有一套渲染规则，它决定了其子元素将如何定位，以及和其他元素的关系和相互作用。\nBFC 即 Block Formatting Contexts (块级格式化上下文)，它属于上述定位方案的普通流。\n具有 BFC 特性的元素可以看作是隔离了的独立容器，容器里面的元素不会在布局上影响到外面的元素，并且 BFC 具有普通容器所没有的一些特性。\n通俗一点来讲，可以把 BFC 理解为一个封闭的大箱子，箱子内部的元素无论如何翻江倒海，都不会影响到外部。\nBFC 的触发条件 只要元素满足下面任一条件即可触发 BFC 特性：\n body 根元素 浮动元素：float 除 none 以外的值 绝对定位元素：position (absolute、fixed) display 为 inline-block、table-cells、flex overflow 除了 visible 以外的值 (hidden、auto、scroll)  BFC 的应用  同一个 BFC 下外边距会发生折叠。如果想要避免外边距的重叠，可以将其放在不同的 BFC 容器中。 BFC 可以包含浮动的元素（清除浮动），防止浮动造成高度坍塌。 BFC 可以阻止元素被浮动元素覆盖  参考资料:  10 分钟理解 BFC 原理 CSS盒模型完整介绍  ","description":"","id":12,"section":"posts","tags":["css基础","学习笔记"],"title":"重新理解BFC","uri":"http://llane00.github.io/posts/%E9%87%8D%E6%96%B0%E7%90%86%E8%A7%A3bfc/"},{"content":"背景： 在 JavaScript 里面，数字均为双精度浮点类型，即一个介于±2−1023和±2+1024之间的数字，或约为±10−308到±10+308，数字精度为53位。整数数值仅在±(253 - 1)的范围内可以表示准确。\nJS 的最大和最小安全值可以这样获得:\nconsole.log(Number.MAX_SAFE_INTEGER); //9007199254740991 console.log(Number.MIN_SAFE_INTEGER); //-9007199254740991 通过下面的例子，你会明白为什么大于这个值的运算是不安全的:\nvar x = 9223372036854775807; console.log(x === x + 1);// output: true console.log(x === x + 1000); //output: true 用js实现正整数大数相加： //用字符串表示大数 let x = \u0026quot;9007199254740991\u0026quot;; //Number.MAX_SAFE_INTEGER let y = \u0026quot;99999999999999999999\u0026quot;; //20位大数 function bigNumberAdd(x, y) { //为了把两个数字从个位开始相加，需要补齐位数较小的数，让两个数的位数相等 let maxLength = Math.max(x.length, y.length); //用0补齐位数 x = x.padStart(maxLength, 0); y = y.padStart(maxLength, 0); let carryOver = 0; //进位 let resultStr = \u0026quot;\u0026quot;; //最终计算结果 for (let i = maxLength - 1; i \u0026gt;= 0; i--) { let digitSum = parseInt(x[i]) + parseInt(y[i]) + carryOver; let currentDigit = digitSum % 10; //取个位 carryOver = Math.floor(digitSum / 10); //取进位 resultStr = currentDigit + resultStr; } //如果进位还有1 if (carryOver == 1) { resultStr = \u0026quot;1\u0026quot; + resultStr; } return resultStr; } ","description":"","id":13,"section":"posts","tags":["js基础","学习笔记"],"title":"Js大数相加","uri":"http://llane00.github.io/posts/js%E5%A4%A7%E6%95%B0%E7%9B%B8%E5%8A%A0/"},{"content":"这次推荐的压缩工具是 optimizt\n稍微看了下，算是一个压缩图片的工具合集\n安装optimizt npm i -g @funboxteam/optimizt 也支持WebStorm, PhpStorm等插件\n also support External Tool in WebStorm, PhpStorm, etc\n DIY一下 optimizt 支持用find命令查找图片\noptimizt `find . -type f -name '*.jpg'` 于是我在.bash_profile（或者其他Shell配置文件）中添加别名 + 自定义的搜索方式\nalias yasuo='optimizt `find . -name \u0026quot;*.png\u0026quot; -o -name \u0026quot;*.jpg\u0026quot; -o -name \u0026quot;*.jpeg\u0026quot; -o -name \u0026quot;*.gif\u0026quot; -o -name \u0026quot;*.svg\u0026quot;`' 这个命令可以压缩当前目录下所有找到的jpg/jpeg/png/gif/svg后缀的图片（支持多层目录迭代查找）\n加入参数 -l 后lossless可无损压缩\nalias yasuo2='optimizt -l `find . -name \u0026quot;*.png\u0026quot; -o -name \u0026quot;*.jpg\u0026quot; -o -name \u0026quot;*.jpeg\u0026quot; -o -name \u0026quot;*.gif\u0026quot; -o -name \u0026quot;*.svg\u0026quot;`' more:\n最后推荐一波自制命令行查看天气工具 llane-weather\n效果如下：\n如果觉得有趣或者有帮助的可以点下github的star，觉得不好用的也可以直接留言告诉我。\n","description":"","id":14,"section":"posts","tags":["命令行"],"title":"使用命令行快速压缩图片","uri":"http://llane00.github.io/posts/%E4%BD%BF%E7%94%A8%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%BF%AB%E9%80%9F%E5%8E%8B%E7%BC%A9%E5%9B%BE%E7%89%87/"}]