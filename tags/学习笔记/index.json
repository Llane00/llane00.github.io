[{"content":"javascript 是一门单线程语言，但是其中涉及到了需要很多异步的场景\n比如所有的请求是异步的，读取资源是异步的，计时器也是异步的\n那么这究竟是怎么实现的？\nnodejs 的引擎是由 C++实现的，为了支持 js 运行时的异步，nodejs 引擎提供了 Eventloop 的事件循环机制\nEventloop 是指事件执行的阶段循环，Eventloop 在 nodejs 和浏览器里是不同\nEventloop 的阶段（简化） 官方文档（原文的翻译可以看这里）有 6 个阶段，\n现在简化为 3 个阶段来看，阶段的执行顺序是 1、2、3、1、2、3\u0026hellip;\n timers：执行 setTimeout 和 setInterval 的回调函数 poll：等待 time 到达某个点后触发 timers 中的回调函数 check：执行 setImmediate() 的回调函数  setTimeout(fn,0)和 setImmediate 谁先执行？ 这里先说一下 nodejs 中开启 Eventloop 时发生的事：\n 开启事件循环 开启 nodejs 的 Eventloop 进程 同时异步得开始开始执行 js，开启 v8 引擎进程  1 和 2 因为是异步发生的，所以不知道谁会先结束，他们的顺序可能是 1 开启完毕然后 2 开启完毕束，也可能是 2 先开启完毕再 1 开启完毕\n理想情况下 环境 1.Eventloop 先开启完毕\n环境 2.v8 引擎再开启完毕，然后开始分析和执行 js 代码（此时 Eventloop 已经到阶段 2.poll 了）\nsetTimeout 和 setInterval 在 阶段 1.timers 中按照执行顺序放到队列里\nsetImmediate 在 阶段 3.check 中按照执行顺序放到队列里\nEventlop 开始运行到 阶段 2.poll 中等待\n如果在阶段 2.poll 中发现 阶段 3.check 中的执行队列里有回调函数，就马上去 阶段 3.check 里执行 setImmediate 的回调函数\n如果在阶段 2.poll 中发现 阶段 3.check 中的执行队列里没有回调函数，等到阶段 1 中的时间到了之后从阶段 2 到 阶段 3 再到 阶段 1，执行 阶段 1.timers 队列中时间到了的回调函数\n之后依次往复\n所以此时 setImmediate 一定会在 setTimeout 和 setInterval 前执行，即便 setTimeout 和 setInterval 的等待时间是 0\n ps：process.nextTick() 不属于 Eventloop 的一部分，意思是在哪个阶段执行 nextTick，就在这个阶段结束后马上执行\n 但是实际情况可能是 环境 1.Eventloop 还没开启完毕\n环境 2.v8 引擎反而已经开启完毕了\n执行 js 时，先把 setTimeout 和 setInterval 放到阶段 1.timers 的队列里\n然后 Eventloop 开始阶段 1，就先去阶段 1 的执行队列里看有没有时间已经到的 setTimeout 和 setInterval，此时如果 setTimeout 和 setInterval 设置的时间是 0，就会直接执行，比 setImmediate 还早（因为还没到阶段 3）\n所以结论是 setTimeout(fn,0)和 setImmediate 谁先执行是不确定的\n微任务和宏任务 在 Node.js 环境：\nsetTimeout 会马上放到 timer 阶段的队列，属于宏任务\nsetImmediate 会马上放到 check 阶段的队列，属于宏任务\nnextTick 会马上放到当前阶段执行结束后，属于微任务\npromise.then(fn) (一般来说 Promise 是由 nextTick 实现的) then 后的 fn 是在 resolve 的时候再放到当前队列后执行，属于微任务\nawait 转化为 promise.then 再分析，也属于微任务\n在浏览器环境：\nsetTimeout 一会儿做，属于宏任务\npromise.then(fn) fn 在 resolve 时放到微任务队列，属于微任务\nawait + fn 是 promise 的语法糖，可以转换为 fn.then()，而且 await 之后的代码也会包括在 then 里了, 属于微任务\n（如果 fn 是一个 Promise 就是 fn().then(await 之后的代码)，如果 fn 不是 Promise 就把他变为 Promise.resolve(fn()).then(await 之后的代码)）\n （setImmediate 只有 IE 浏览器中有，其他浏览器没有实现， nextTick 在浏览器中也没有实现，但其实有 MutationObserver、Object.observe（已弃用） 来代替微任务效果）\n ","description":"","id":0,"section":"posts","tags":null,"title":"Eventloop的理解","uri":"http://llane00.github.io/posts/eventloop%E7%9A%84%E7%90%86%E8%A7%A3/"},{"content":"es6 中的 Promise 可以简化 callback hell“回调地狱，回调套回调”造成的代码结构上的多级缩进\n让代码看起来像同步的，消除多级缩进，从结构上简化代码（之后有 await 语法让代码看起来更“同步”）\n消灭 if error 代码\n消除回调地狱也可以用命名恰当的多个子函数化解\n先来看一下 Promise 的 API\nPromise 是一个类\n类参数：就一个函数\n类方法：all/allSettled/race/reject/resolve\n对象属性：then（重要）/finally/catch\n对象内部属性：state=pending（悬而未决）/fulfilled（成功）/rejected（失败）\n这次的实现需要满足 Promise/A+的标准\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133  class Promise2 { state = \u0026#39;pending\u0026#39; callbacks = [] resolve(result) { nextTick(() =\u0026gt; { if (this.state !== \u0026#39;pending\u0026#39;) return this.state = \u0026#39;fulfilled\u0026#39; for (let handle of this.callbacks) { if (typeof handle[0] === \u0026#39;function\u0026#39;) { let x try { x = handle[0].call(undefined, result) } catch (error) { return handle[2].reject(error) } handle[2].resolveWith(x) } } }) } reject(reason) { nextTick(() =\u0026gt; { if (this.state !== \u0026#39;pending\u0026#39;) return this.state = \u0026#39;rejected\u0026#39; for (let handle of this.callbacks) { if (typeof handle[1] === \u0026#39;function\u0026#39;) { let x try { x = handle[1].call(undefined, reason) } catch (error) { return handle[2].resolveWith(x) } handle[2].resolveWith(x) } } }) } constructor(fn) { if (typeof fn !== \u0026#39;function\u0026#39;) { throw new Error(\u0026#39;Promise的参数需要是一个函数\u0026#39;) } fn(this.resolve.bind(this), this.reject.bind(this)) } then(succeed?, fail?) { let handle = [] if (typeof succeed === \u0026#39;function\u0026#39;) { handle[0] = succeed } if (typeof fail === \u0026#39;function\u0026#39;) { handle[1] = fail } handle[2] = new Promise2(() =\u0026gt; {}) this.callbacks.push(handle) return handle[2] } resolveWithSelf() { this.reject(new TypeError(\u0026#39;x should not be this\u0026#39;)) } resolveWithPromise(x) { x.then( (result) =\u0026gt; { this.resolve(result) }, (reason) =\u0026gt; { this.reject(reason) } ) } getThen(x) { let then try { then = x.then } catch (error) { this.reject(error) } return then } resolveWithThenable(x) { try { x.then( (y) =\u0026gt; { this.resolveWith(y) }, (r) =\u0026gt; { this.reject(r) } ) } catch (error) { this.reject(error) } } resolveWithObject(x) { let then = this.getThen(x) if (then instanceof Function) { this.resolveWithThenable(x) } else { this.resolve(x) } } resolveWith(x) { if (this === x) { this.resolveWithSelf() } else if (x instanceof Promise2) { this.resolveWithPromise(x) } else if (x instanceof Object) { this.resolveWithObject(x) } else { this.resolve(x) } } } export default Promise2 function nextTick(fn) { if (process !== undefined \u0026amp;\u0026amp; typeof process.nextTick === \u0026#39;function\u0026#39;) { return process.nextTick(fn) } else { var counter = 1 var observer = new MutationObserver(fn) var textNode = document.createTextNode(String(counter)) observer.observe(textNode, { characterData: true, }) counter = counter + 1 textNode.data = String(counter) } }   ","description":"","id":1,"section":"posts","tags":null,"title":"Js实现Promise","uri":"http://llane00.github.io/posts/js%E5%AE%9E%E7%8E%B0promise/"},{"content":"API: 数组+初始 pid（一般为 0）\n实现思路：用递归或者轮询数组一步步创建一个新的数组对象\n要求拍平的原数据如下：\n1 2 3 4 5 6 7  let arr = [ { id: 1, name: \u0026#39;部门1\u0026#39;, pid: 0 }, { id: 2, name: \u0026#39;部门2\u0026#39;, pid: 1 }, { id: 3, name: \u0026#39;部门3\u0026#39;, pid: 1 }, { id: 4, name: \u0026#39;部门4\u0026#39;, pid: 3 }, { id: 5, name: \u0026#39;部门5\u0026#39;, pid: 4 }, ]   期望得到的数据格式：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  ;[ { id: 1, name: \u0026#39;部门1\u0026#39;, pid: 0, children: [ { id: 2, name: \u0026#39;部门2\u0026#39;, pid: 1, children: [], }, { id: 3, name: \u0026#39;部门3\u0026#39;, pid: 1, children: [ // 结果 ,,,  ], }, ], }, ]   版本 1 反手就是一个递归 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  function getChild(data, result, pid) { for (let item of data) { if (item.pid === pid) { const newItem = { ...item, child: [] } result.push(newItem) getChild(data, result, item.id) } } } function arrayToTree(data, pid) { const result = [] getChild(data, result, pid) return result } arrayToTree(arr, 0)   版本 1.2 最简递归 1 2 3 4 5 6 7 8 9 10 11 12  function arrayToTree(data = [], pid = 0) { let tempData = [] if (data \u0026amp;\u0026amp; data.length) { for (let item of data) { if (item.pid === pid) { item.child = arrayToTree(data, item.id) tempData.push(item) } } } return tempData }   版本 2 老子会 Map 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  function arrayToTree(arr) { const result = [] const itemMap = {} // arr数据专为key为item.id的map  for (const item of arr) { itemMap[item.id] = { ...item, child: [] } } for (const item of arr) { const id = item.id const pid = item.pid const treeItem = itemMap[id] if (pid === 0) { result.push(treeItem) } else { if (!itemMap[pid]) { itemMap[pid] = { child: [], } } itemMap[pid].child.push(treeItem) } } return result }   版本 3 map 终极学以致用 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33  function arrayToTree(items) { const result = [] const itemMap = {} for (const item of items) { const id = item.id const pid = item.pid if (!itemMap[id]) { itemMap[id] = { children: [], } } itemMap[id] = { ...item, child: itemMap[id][\u0026#39;children\u0026#39;], } const treeItem = itemMap[id] if (pid === 0) { result.push(treeItem) } else { if (!itemMap[pid]) { itemMap[pid] = { children: [], } } itemMap[pid].children.push(treeItem) } } return result }   ","description":"","id":2,"section":"posts","tags":["js基础","学习笔记"],"title":"Js实现数组拍平","uri":"http://llane00.github.io/posts/js%E5%AE%9E%E7%8E%B0%E6%95%B0%E7%BB%84%E6%8B%8D%E5%B9%B3/"},{"content":"深拷贝使用场景：\n 默认选项 部分修改  API: 接收一个对象或者基本类型，对象的类型包括 Array、function、普通 Object、RegExp 正则表达式、Date\n返回一个和接收对象一样的数据，但是两者之间没有任何节点有联系，修改 A 不会影响 B\n版本 0.1 最简单版本（直接一把梭） 直接使用 JSON 序列化\n1 2 3 4  let a = { a: 1, b: 2, c: 3 } let b = JSON.parse(JSON.stringify(a)) console.log(a) console.log(b)   缺点：\n1.不支持函数，比如对象里有有一个 key，value 的 value 是一个函数\n2.不支持 undefined\n3.JSON 只支持树状的结构不支持环状的结构，如果原对象有一个对自己的引用，JSON 的序列化会报错\n4.不支持 Date、正则表达式、Symbol、Set、Map（综上就是所有 JSON 不支持的数据类型都不支持）\n其他的浅拷贝办法：\n1.Object.assign({}, a)\n2.{\u0026hellip;a}\n版本 1 我能拷贝有不同对象的数据了 可以看到 JSON 序列化的深拷贝方式已经不满足了，\n那么现在我们得手动实现一个深拷贝了，我们用递归的形式来实现\n在递归的时候一定会遇到不同的数据类型，要按照不用的数据类型来分类讨论\njs 一共有 8 种数据类型，\n如果是 7 种基本类型之一就直接 return\nundefined\nnull\nboolean\nnumber\nstring\nsymbol\nbigint\n如果是 object 就再分类讨论，不同的类型用不同的构造方法去构造一个新的对象\n Array 就遍历复制属性到一个新的数组 new Array function 就在一个新的 function 内 source.apply(this, arguments) //source 是要拷贝的对象\n再遍历 source 的属性到这个新的 function Object 也 遍历复制 key value 到一个新对象 new Object RegExp 正则表达式 数据类型 Date 数据类型  其中所有的复制都用 deepClone 这个函数自己递归\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  function deepClone(source) { if (source instanceof Object) { let dist if (source instanceof Array) { dist = new Array() } else if (source instanceof Function) { dist = function () { return source.apply(this, arguments) } } else if (source instanceof RegExp) { dist = new RegExp(source.source, source.flags) } else if (source instanceof Date) { dist = new Date(source) } else { dist = new Object() } for (let key in source) { dist[key] = deepClone(source[key]) } return dist } return source }   版本 2 我能拷贝具有环结构的数据了 到目前为止一切顺利，也没有什么大问题\n因为要拷贝的对象的数据是有限的 deepClone 的递归会自动结束，不用特地给一个出口\n但是考虑到一种情况，在讨论 JSON 序列化深拷贝的时候第三种情况是拷贝环结构，\n即一个对象的某个属性引用了自身，比如：window.self === window\n我们目前构建的 deepClone 方法，在遇到有环结构的对象时会不断递归永远没有出口结束\n数组也可能存在环结构:\n1  a[0] = a   函数也可能存在环结构:\n1 2 3 4  function x() { return x() } x()   解决办法是使用缓存来标记已经复制过的对象\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46  let cache = [] function deepClone(source) { if (source instanceof Object) { let cacheDist = findCache(source) // 有缓存  if (cacheDist) { return cacheDist } else { //无缓存  let dist if (source instanceof Array) { dist = new Array() } else if (source instanceof Function) { dist = function () { return source.apply(this, arguments) } } else if (source instanceof RegExp) { dist = new RegExp(source.source, source.flags) } else if (source instanceof Date) { dist = new Date(source) } else { dist = new Object() } // 加入缓存  cache.push([source, dist]) for (let key in source) { dist[key] = deepClone(source[key]) } return dist } } // 如果是基本类型就直接return  return source } // 查看当前的对象是否已经在缓存中 function findCache(source) { for (let i = 0; i \u0026lt; cache.length; i++) { if (cache[i][0] === source) { return cache[i][1] } } return undefined }   版本 3 我需要跳过原型再拷贝 现在具有环结构的对象现在也可以复制了。\n此外还有一个坑，我们知道每一个对象都有自己的原型，__proto__属性\n目前还没考虑是否要拷贝对象的原型（这里原型很可能还有原型是很深的一个对象属性）\n一般来说我们不需要拷贝 proto 这个属性，因为原型里的所有方法和对象都有各自的原型，如果我们要决定拷贝原型\n就意味着要把 js 中的很多基本原型都拷贝一遍，所以这里一般不需要拷贝对象的原型，所以需要绕开它\n1 2 3 4 5 6  for (let key in source) { // 只复制对象自己的属性，跳过原型的属性  if (source.hasOwnProperty(key)) { dist[key] = deepClone(source[key]) } }   我们修改一下代码，下面是完整代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49  let cache = [] function deepClone(source) { if (source instanceof Object) { let cacheDist = findCache(source) // 有缓存  if (cacheDist) { return cacheDist } else { //无缓存  let dist if (source instanceof Array) { dist = new Array() } else if (source instanceof Function) { dist = function () { return source.apply(this, arguments) } } else if (source instanceof RegExp) { dist = new RegExp(source.source, source.flags) } else if (source instanceof Date) { dist = new Date(source) } else { dist = new Object() } // 加入缓存  cache.push([source, dist]) for (let key in source) { // 只复制对象自己的属性，跳过原型的属性  if (source.hasOwnProperty(key)) { dist[key] = deepClone(source[key]) } } return dist } } // 如果是基本类型就直接return  return source } // 查看当前的对象是否已经在缓存中 function findCache(source) { for (let i = 0; i \u0026lt; cache.length; i++) { if (cache[i][0] === source) { return cache[i][1] } } return undefined }   版本 4 强化拷贝函数，最后的力量！ 你或许有注意到，目前在函数外面有一个 cache 用于存放深拷贝时的缓存，我们在调用完后还得清空它这样很麻烦\n我们尝试写成一个 class，来包含 cache 变量和帮助函数 findCache\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62  class DeepClone { cache constructor() { this.cache = [] } clone(source) { if (source instanceof Object) { let cacheDist = this.findCache(source) // 有缓存  if (cacheDist) { return cacheDist } else { //无缓存  let dist if (source instanceof Array) { dist = new Array() } else if (source instanceof Function) { dist = function () { return source.apply(this, arguments) } } else if (source instanceof RegExp) { dist = new RegExp(source.source, source.flags) } else if (source instanceof Date) { dist = new Date(source) } else { dist = new Object() } // 加入缓存  this.cache.push([source, dist]) for (let key in source) { // 只复制对象自己的属性，跳过原型的属性  if (source.hasOwnProperty(key)) { dist[key] = this.clone(source[key]) } } return dist } } // 如果是基本类型就直接return  return source } // 查看当前的对象是否已经在缓存中  findCache(source) { for (let i = 0; i \u0026lt; this.cache.length; i++) { if (this.cache[i][0] === source) { return this.cache[i][1] } } return undefined } } const a = { self: a child: [ a: undefined, b: new Date() c: new RegExp(\u0026#34;hi\\\\d+\u0026#34;, \u0026#34;gi\u0026#34;) ] } const b = new DeepClone().clone(a)   什么？最后的魔王 有一种情况无论是在浏览器还是在 nodejs 环境中都会存在\n当对象有子属性，子属性还有子属性。。。对象的结构非常深的时候会导致递归调用很多次，会出现函数执行栈超出最大值的情况\n（爆栈：RangeError: Maximum call stack size exceeded）\n这里设想的办法是把对象的纵向的结构换成横向的结构（放在类似数组的结构里）这样用 for 循环来避免递归过于深的情况\n暂时不知道怎么解\n我选择真香 自己写的 deepClone 总会有考虑不周全的地方\n实际工作中可以借助第三方：\n// Lodash\nLodash.cloneDeep()\n// 干脆不用深拷贝了，使用部分修改\nimmutable.js 部分修改\nimmer.js\n","description":"","id":3,"section":"posts","tags":["js基础","学习笔记"],"title":"Js实现深拷贝","uri":"http://llane00.github.io/posts/js%E5%AE%9E%E7%8E%B0%E6%B7%B1%E6%8B%B7%E8%B4%9D/"},{"content":"这篇文章来自 StackOverFlow 的创始人 Joel 在 20 年前写下的一篇文章原文\n现在我翻译成中文\n你可以用 13 个问题来衡量你的技术团队 分数评估： \u0026gt;= 10 优秀 \u0026gt;= 7 还可以 \u0026gt;= 5 需要加强 \u0026lt; 5 糟糕  你们是否使用版本控制，比如 Git 或 SVN？ 你们是否能一键部署（或者一个命令）代码到线上？ 你们在合并代码到 master 前是否需要经过测试？ 你们是否有一个 BUG 管理仓库？ 你们在开始开发新的功能前是否先修复已知 BUG？ 你们是否有给每一个开发人员一个实时更新的任务表？（如果没有就很可能经常加班，因为发布需求的人不清楚开发人员的具体工作情况） 你们是否会在写代码前写规格文档（包含所有要完成的功能描述）？ 你们的开发环境是否是安静的不会被打扰的（比如：产品经理是否会频繁找你）？ 你们公司是否会给你们配备最好的开发设备、最好的开发软件（对，就是字面意思最好的，衡量公司的投入）？ 你们是否有专职的测试人员？ 你们是否有自动化测试？ 你们的新加入成员是否在招聘流程中要求现场写代码？ 你们是否会观察用户如何使用你们的软件？  可以看到即使是现在 2021 年，要全部完成这 13 个问题的条件都是很难的。\n这就是对软件质量意识的差距\n","description":"","id":4,"section":"posts","tags":null,"title":"如何评估你的技术团队","uri":"http://llane00.github.io/posts/%E5%A6%82%E4%BD%95%E8%AF%84%E4%BC%B0%E4%BD%A0%E7%9A%84%E6%8A%80%E6%9C%AF%E5%9B%A2%E9%98%9F/"},{"content":"HTTP HTTP 全称是 HyperText Transfer Protocol 超文本转移（传输）协议\n目前主流的 Http 版本是 1.1，于 1997 年 1 月发布\n通常使用的网络是在 Tcp/IP 协议的基础上运行的\nHTTP 协议是在 TCP/IP 协议的子集\nTCP/IP 协议族按层次分类可以分为：\n应用层：应用程序间通讯\n表达层（后加）：处理数据格式，数据加密\n会话层（后加）：建立、维护和管理会话\n传输层：提供处于网络连接中的两台计算机之间的数据传输，建立主机端到端连接\n网络层：处理网络上的数据包，选择到达对方计算机的传输路线，并把数据包传送给对方，即：寻址和路由选择\n数据链路层：处理连接网络的硬件部分\n层与层传输时，发送时每经过一层都会打上一个该层所属的首部信息。反之，接收时每经过一层就把对应的首部消去\n层次化的好处是，一个层如果需要改变设计可以尽量减少对其他层的影响（封装解藕的概念？）\n每个层只需要考虑自己的工作，不需要知道完整的网络流程\nDNS 的缓存 DNS 域名系统 解析域名为对应的服务器 ip，这个解析的结果会被缓存\n读取 DNS 缓存的顺序\n 先看浏览器的缓存，比如 Chrome 的缓存在chrome://net-internals/#dns 如果没有就再看操作系统的缓存， Host 文件是手动给操作系统添加 DNS 解析缓存 如果没有最后去看 ISP 端的缓存 ISP 是通信服务商  三次握手 DNS 找到 ip 后，浏览器开始建立 TCP 连接，建立 TCP 连接会进行三次握手\n为了准确无误地将数据送达目标处，TCP 协议采用了三次握手\n使用 TCP 标志（flag）：\nSYN(synchronize: 与 x 同步，同步完毕)、\nACK(acknowledgement：收到收到，确认收到)\n这有点像对讲机里的对话：\n 浏览器（发送端）发送 SYN(x) 给服务器（接收端）：这里是长江，请求同步信息，收到请回复 服务器（接收端）收到后发送 ACK(x+1)/SYN(y) 给浏览器（发送端）：这里是黄河，确认收到你的同步信息请求，收到请回复 浏览器（发送端）发送 ACK(y+1) 给服务器（接收端）：这里是长江，已收到你的回复确认，成功建立连接  因为可能同一时间都多个请求，故使用 x，y 来标记，x 和 y 一般是从 0 开始的\nSYN 是 synchronize（同步）的缩写\nACK 是 acknowledge（获悉，收到）的缩写\n三次握手确保：\n A 可以向 B 发信息 B 可以收到该信息，B 也可以向 A 发信息 A 可以收到该信息  此时双方都知道了对方准备好了，完全建立了通讯，A 就可以正式发送 HTTP 请求了\n当省略第三步的时候，服务器会认为 A 无法接收信息，A 或许已经断开连接了，建立就失败\n四次挥手  A 对 B 说 FIN(x) B 回复 A ACK(x+1) B 回复 A FIN(y) A 回复 B ACK(y+1)  之后就可以正式关闭 HTTP 连接了，避免资源的浪费\n在步骤 2 和步骤 3 中可能有其他 B 最后要发送给 A 的信息，所以没有像 3 次握手时合并\n关闭时 x 和 y 一般不是 0\nFIN finish\n一次简单的浏览 web 页 一次浏览 web 页面：\nHTTP 协议发送针对 web 服务器 jetdream.xyz 的 HTTP 请求报文，\nDNS 协议负责通过域名找到对应的 IP 地址\nTCP 协议把请求报文分割成报文段（按照序号分）\nIP 协议搜索对方地址一边中转一边传送\nTCP 协议从对方那里接收报文段按顺序重组\nHTTP 协议从对方那里对 web 服务器请求的内容进行处理\nURI | URL URI 统一资源标识符，用字符串标识某一互联网资源\nURL 统一资源定位符，表示资源的地址\nURL 是 URI 的子集\nURI: 协议方案名｜登陆信息认证｜服务器地址｜服务器端口号｜带层次的文件路径｜查询字段｜片段标识符\nHTTP 无状态 HTTP 是一种不保存状态，即无状态（stateless）协议。HTTP 协议自身不对请求和响应之间的通信状态进行保存。\n也就是说在 HTTP 这个级别，协议对发送过的请求或响应都不能做持久化处理\nHTTP 初始版本需要每进行一次 HTTP 连接就要断开 TCP 连接\n如果一个 HTML 文档中包含多个图片，就要进行多次 HTTP 和 TCP 的断开和连接\nHTTP1.1 和部分 1.0 使用持续连接，只要任意一段不提出 TCP 断开就保持连接状态\n管线化使得可以同时并行发送多个请求，不用一个接一个等\n因为 HTTP 不对之前发生过的请求和响应的状态进行管理，也就是无法根据之前的状态进行本次的请求处理\n目前主流的办法是用 cookie 来做状态（session 会话）管理\nCookie 会根据服务端发送的响应报文中的 Set-Cookie 通知客户端保存 Cookie，之后客户端的请求会自动加入 Cookie 的值\nHTTP 方法 GET 获取资源，请求访问已被 URI 识别的资源\nPOST 传输实体主体，虽然 GET 也可以传输实体的主题，但是一般不用 GET 方法传输\nPUT 传输文件，要求在报文主体中包含文件内容，保存到请求 URI 指定的位置，但不带验证机制有安全问题\nHEAD 获取报文首部，和 GET 方法类似但是不返回报文主体部分\nDELETE 删除文件，和 PUT 相反的方法，按照请求 URI 删除指定的资源，但不带验证机制有安全问题\nOPTIONS 查询针对请求 URI 指定资源支持的方法，类似返回 Allow: GET,POST,HEAD,OPTIONS\nTRACE 追踪路径，让 web 服务器端将之前的请求通信环回给客户端\nCONNECT 要求用隧道协议连接代理 要求与代理服务器通信时建立隧道，实现用隧道协议进行 TCP 通信。主要用 SSL(Secure Sockets Layer 安全套接层) 和 TLS(Transport Layer Security 传输层安全)协议把通信内容加密后经网络隧道传输\n提升编码效率 1.压缩编码\n常见的内容编码有：\ngzip（GNU zip）\ncompress（UNIX 系统的标准压缩）\ndeflate（zlib）\nidentity（不进行编码）\n2.分割发送的分块传输编码\n在传输大容量数据时，通过把数据分割成多块，能让浏览器逐步显示页面\n请求报文中的 Content-type 请求报文中发送的数据可能是多部分对象集合\nmultipart/form-data\nweb 表单上传时使用\nmultipart/byteranges\n状态码 206（Partial Content，部分内容）响应报文包含了多个范围的内容时使用\nHTTP 状态码 200 ok\n204 No content 请求成功但是没有信息返回\n206 Partial content 对资源一部分的请求，响应报文中有 Content-Range\n301 Moved Permanently 永久重定向，希望以后用新的 URI 访问\n302 Found 临时重定向 资源分配了新的 URI，希望（本次）用新的临时 URI 访问\n303 See other 资源有另一个 URI，应用 GET 方法定向（和 302 几乎一样，但指定了要用 GET 重定向）\n304 Not Modified 虽然是 3xx 但不是重定向，表示本次请求不符合某些条件\n307 Temporary Redirect 临时重定向 与 302 有相同的含义，禁止 POST 变 GET\n400 Bad Request 请求报文中有语法错误\n401 Unauthorized 请求需要有用户认证信息 WWW-Authenticate 信息\n403 Forbidden 请求的资源被服务器拒绝了\n404 Not Found 服务器上无法找到请求的资源\n500 Internal Server Error 服务器在执行时发生了错误\n503 Service Unavailable 服务器处于超负载或停机维护，现在无法处理请求\n一台服务器（对应一个 IP）可能托管了多个主机名和域名的 web 网站，不能只写 IP 需要在 Host 内指定完整的主机名或域名的 URI\n保护资源缓存 缓存是指代理服务器或客户端本地磁盘内保存的资源副本。利用缓存可减少对源服务器的访问，因此也就节省了通信流量和通信时间。\n缓存服务器是代理服务器的一种，当代理转发从服务器返回的响应时，代理服务器会保存一份资源的副本\n缓存服务器的优势在于利用缓存可以避免多次从源服务器转发资源。因此客户端可就近从缓存服务器上获取资源，而源服务器也不必多次处理相同的请求了\n缓存的有效期 当遇上源服务器上的资源更新时，如果还是使用不变的缓存，那就会演变成返回更新前的“旧”资源了\n所以需要确认资源的有效性\n缓存不仅可以在于缓存服务器内，还可以存在客户端浏览器中\n常见的 HTTP 请求首部 Cache-Control: no-cache 表示缓存服务器在确认有效性后不缓存过期的资源\nCache-Control: no-store 表示缓存服务器不进行任何缓存\nCache-Control: max-age 缓存服务器不再确认有效性，只关注 max-age（秒）的缓存最长时间\nConnect: close HTTP1.1 默认是持久连接的，服务器要断开时指定值为 close\nConnet: Keep-Alive HTTP1.1 之前默认是非持久连接，需要额外指定为 Keep-Alive\nAccept: text/html,application/xhtml+xml,application/xml;q=0.9,/;q=0.8 表示用户代理能处理的资源的媒体类型和 q 优先级\nAccept-Charset: iso-8859-5, unicode-1-1;q=0.8 表示用户代理支持的优先级和优先级\nAccept-Encoding: gzip, deflate 表示用户代理支持的内容编码方式和优先级\nAccept-Language: zh-cn, zh; q=0.7,en-us,en;q=0.3 表示用户代理能处理的自然语言集和优先级\nAuthorization Basic xxxxxxxxxx 用来告知用户代理的认证信息，用户在收到 401 状态码后会把首部字段 Authorization 加入请求\nExpect: 100-contine 告知服务器，期望出现某种特定行为\nHost: jetdream.xyz 虚拟主机运行在同一个 IP 上，因此需要用首部字段 Host 来区分\nIf-Match: \u0026ldquo;123456\u0026rdquo; 用来匹配资源所用的实体标记 ETag，一致时才会执行请求\nIf-None-Match: 如果资源在 ETag 不匹配时才会执行请求\nIf-Modified-Since 如果资源在 xxx 日期后更新，才会接受请求\nIf-Range: + 一个 Etag\nRange: bytes=500-10000 或 bytes=500-\n表示资源 ETag 匹配后资源请求的范围\nReferer 请求的 URI 是从哪个 web 页面发起的\nUser-Agent 创建请求的浏览器或用户代理的名称和信息等\n网络安全 Xss (跨站脚本攻击 Cross Site Scripting)\n被动攻击 通过巧妙的方法注入恶意指令代码到网页，使用户加载并执行攻击者恶意制造的网页程序\ncsrf(跨站请求伪造 Cross-site request forgery)\n被动攻击 一种挟制用户在当前已登录（利用 cookie 或者 session 会话）的 Web 应用程序上执行非本意的操作的攻击方法\n","description":"","id":5,"section":"posts","tags":null,"title":"读书笔记《图解HTTP》","uri":"http://llane00.github.io/posts/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E5%9B%BE%E8%A7%A3http/"},{"content":" 我想知道这是为什么 \u0026ndash;费曼\n 基数排序 基数排序就是按照数字的”位”来排序。\n“位“是进位的位，比如十进制的基数是 10，就可以按照个十百千万等位来排序\n整体的流程分为：初始、补位、排个位、排十位、排百位、\u0026hellip;\n先按个位从小到大排序，然后再按十位、百位排序\u0026hellip;\n只要排序算法是稳定的，那么最后整体就是有序的。\n为了方便看出数字每一位具体是多少，对位数少的数组进行了左边的补 0\n可见算法的核心在于选择的排序算法是否是稳定的，稳定的意思是相同的元素的相对顺序不会改变\n如果选择的排序算法是不稳定的，那么对一整列位数进行排序的时候很可能会影响之前已经排好序的位\n在开始写算法前看一些相关的 api:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  // 判断数字最长有几位，轮循数组 let array = [666, 520, 36, 49, 9, 600, 8, 502, 998, 32] let maxLength = 0 for (let v of array) { let length = String(v).length if (length \u0026gt; maxLength) { maxLength = length } } // 根据最长的数字进行左边的补位0 String(321).padStart(maxLength, \u0026#39;0\u0026#39;) // 获取制定位上的数字 \u0026#39;321\u0026#39;[0] // \u0026#39;3\u0026#39; \u0026#39;321\u0026#39;[1] // \u0026#39;2\u0026#39; \u0026#39;321\u0026#39;[2] // \u0026#39;1\u0026#39;   对数组排序 maxLength 次，每一次的输出作为下一次的输入，sort 算法只要是稳定的排序算法就可以了\n这里使用桶排序\n个位上的数字范围是 0-9，所以需要 10 个桶\n1 2 3 4  let buckets = [] for (let i = 0; i \u0026lt; 10; i++) { buckets.push([]) }   然后按个位上的数值把该元素放到不同的桶里\n1 2 3 4 5 6 7 8  for (let v of array) { let pad = String(v).padStart(maxLength, \u0026#39;0\u0026#39;) let bucketIndex = pad[maxLength - 1] //最后一位  buckets[bucketIndex].push(v) } console.log(buckets) // [ [ 520, 600 ], [], [ 502, 32 ], [], [], [], [ 666, 36 ], [], [ 8, 998 ], [ 49, 9 ] ]   因为桶的间隔是 1，所以不需要再排序了，直接按顺序输出每个桶的元素即可\n1 2 3 4  let result = [] for (let bucket of buckets) { result.push(...bucket) }   完整代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37  function radioSort(array) { // 获取最大长度  let maxLength = 0 for (let v of array) { let length = String(v).length if (length \u0026gt; maxLength) { maxLength = length } } // 从个位开始排序  for (let i = 0; i \u0026lt; maxLength; i++) { // 这一次的输出作为下一次的输入  array = sort(array, i) } function sort(array, index) { let buckets = [] // 0-9 10个数字分配10个桶放  for (let i = 0; i \u0026lt; 10; i++) { buckets.push([]) } for (let v of array) { let pad = String(v).padStart(maxLength, \u0026#39;0\u0026#39;) let num = pad[maxLength - 1 - index] // 配合index取数字  buckets[num].push(v) // 把数字放到对应的桶里  } let result = [] // 由于10个桶是有循序的所以轮询桶依次解构出来就行  for (let bucket of buckets) { result.push(...bucket) } return result } return array }   总结：\n基数排序的性能，取决于内部排序算法的选择。如果使用桶排序，时间复杂度为 O(k*n)，其中 k 为最大元素的位数。\n我创建了一个集合 jest 可以测试算法的靶场项目：\nhttps://github.com/Llane00/algorithm-range-tests\n将同步文章中的代码到这个项目下\n使用 vscode 的读者可以安装拓展插件 jest，这个插件可以自动检测 test 文件自动运行，非常方便。\n","description":"","id":6,"section":"algorithm","tags":["算法基础","学习笔记"],"title":"菜鸟学算法-9-基数排序","uri":"http://llane00.github.io/algorithm/9-%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F/"},{"content":" 我想知道这是为什么 \u0026ndash;费曼\n 桶排序：\n先分类，把数据放进相应的桶里，然后对每个桶进行局部排序，最后再把桶排序一下\n有四步:\n1.创建桶\n2.归类（把元素放到对应的桶里）\n3.排序\n4.合并\n创建桶 1 2 3 4 5 6 7 8 9 10  let array = [3, 8, 6, 1, 5, 7, 9, 2, 4] let min = Math.min(...array) let max = Math.max(...array) let size = 3 let count = Math.floor((max - min) / size) + 1 // count从1开始计算需要加1 let buckets = [] for (let i = 0; i \u0026lt; count; i++) { buckets.push([]) } console.log(buckets) // [ [], [], []]   归类 1 2 3 4 5 6  for (let value of array) { let bucketIndex = Math.floor((vlaue - min) / size) // bucketIndex从0开始计算不需要加1  buckets[bucketIndex].push(value) } console.log(buckets) // [ [ 3, 1, 2 ], [ 6, 5, 4 ], [ 8, 7, 9 ] ]   排序 \u0026amp;\u0026amp; 合并 排序用其他任一排序算法都可以，比如数据量不太大的时候，插入排序就比较适合\n因为区间本来就是有序的，合并的时候直接链接这些数组就可以了\n1 2 3 4 5 6  let result = [] for (let bucket of buckets) { result.push(...insertionSort(bucket)) } console.log(result) // [ 1, 2, 3, 4, 5, 6, 7, 8, 9 ]   完整代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35  // 桶排序 function bucketSort(array, size = 10) { let max = Math.max(...array) let min = Math.min(...array) let count = Math.floor((max - min) / size) + 1 let buckets = [] for (let i = 0; i \u0026lt; count; i++) { buckets.push([]) } for (let value of array) { let bucketIndex = Math.floor((value - min) / size) buckets[bucketIndex].push(value) } let result = [] for (let bucket of buckets) { result.push(...insertionSort(bucket)) } return result } // 插入排序 function insertionSort(array) { for (let i = 1; i \u0026lt; length; i++) { let j = i let target = array[j] while (j \u0026gt; 0 \u0026amp;\u0026amp; array[j - 1] \u0026gt; target) { array[j] = array[j - 1] j-- } array[j] = target } return array }   复杂度 \u0026amp;\u0026amp; 总结 桶排序是分布式排序，适合处理大批量数据。需要额外空间，是外部排序。\n桶排序是否稳定，取决于第二步排序算法的选择。\n时间复杂度是线性级 O(n)，可以简单理解：桶的范围大小是人为指定的，它不随数据规模变化，如果数据相对均匀分布，那么桶的个数就是核心影响因子了。\n我创建了一个集合 jest 可以测试算法的靶场项目：\nhttps://github.com/Llane00/algorithm-range-tests\n将同步文章中的代码到这个项目下\n使用 vscode 的读者可以安装拓展插件 jest，这个插件可以自动检测 test 文件自动运行，非常方便。\n","description":"","id":7,"section":"algorithm","tags":["算法基础","学习笔记"],"title":"菜鸟学算法-8-桶排序","uri":"http://llane00.github.io/algorithm/8-%E6%A1%B6%E6%8E%92%E5%BA%8F/"},{"content":" 我想知道这是为什么 \u0026ndash;费曼\n 计数：数一数每个元素重复出现的次数\n统计完后，从小到大按照统计的重复次数一个个填充到一个新数组\n从查和排两个部分讲\n查 记下每个元素出现的重复次数\n1 2 3 4 5 6 7  let array = [3, 2, 1, 2, 3, 2, 0, 4] let counts = [] for (let v of array) { counts[v] = (counts[v] || 0) + 1 } console.log(counts)   排 1 2 3 4 5 6 7 8 9 10  let result = [] for (let i = 0; i\u0026lt; counts; i++) { let count = counts[i] while(count\u0026gt;0) { result.push(i) count-- } } console.log(result)   优化-支持负整数排序 利用数组的key来表示元素，value来表示元素重复的次数，真是太棒了\n但也有局限，key只能是0或者正整数，这就意味着待排序的数组的元素也必须是0或者正整数\n在深入js的第16篇中曾提到过bias偏差值这个概念，在不方便存储负数的时候，把所有值都加上bias使得所有值都大于等于0，等要读取的时候再减去bias\n这里也可以这么优化，使得计数排序可以支持负数正数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  let array = [-3, -2, -1, -2, -3, -2, 0, -4] let counts = [], result = [] let min = Math.min(...array) // 这里min的正负不确定 for (let v of array) { // min的正负不确定 v-min可以保证都大于0  counts(v - min) = (counts[v - min] || 0) + 1 } for (let i = 0; i \u0026lt; counts.length; i++) { let count = counts[i] while (count \u0026gt; 0) { result.push(i + min) count-- } }   这里的result是新数组，需要额外占用空间，可以继续优化\n优化空间复杂度 想法是直接在原数组上替换\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  let array = [-3, -2, -1, -2, -3, -2, 0, -4] let counts = [], index = 0 let min = Math.min(...array) for (let v of array) { counts(v - min) = (counts[v - min] || 0) + 1 } for (let i = 0; i \u0026lt; counts.length; i++) { let count = counts[i] while (count \u0026gt; 0) { // 主要看这里  array[j] = i + min index++ count-- } }   复杂度 \u0026amp;\u0026amp; 总结 计数排序适合整数排序，时间复杂度为O(n+k)。\n简单说明一下为啥是O(n+k)。这里使用了两层循环，外层由counts的length——待排数组最值之差（记为k）——决定的，\n而while循环次数是count决定的，而所有count之和正好为array的length（记为n）。\n另外关于空间的使用，开篇实现方式的空间复杂度为O(n+k)，完整代码里的实现的空间复杂度为O(k)。\n可见当k特别大时，将会使用很多空间。\n我创建了一个集合jest可以测试算法的靶场项目：\nhttps://github.com/Llane00/algorithm-range-tests\n将同步文章中的代码到这个项目下\n使用vscode的读者可以安装拓展插件jest，这个插件可以自动检测test文件自动运行，非常方便。\n感谢老姚的文章：手写算法并记住它：计数排序\n","description":"","id":8,"section":"algorithm","tags":["算法基础","学习笔记"],"title":"菜鸟学算法-7-计数排序","uri":"http://llane00.github.io/algorithm/7-%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F/"},{"content":" 我想知道这是为什么 \u0026ndash;费曼\n 在菜鸟算法第一篇中我们学习了简易版的快速排序，本篇介绍的是完整版的快速排序，马上你就知道简易版的有多屑！\n相对于第五篇中的归并排序，快速排序完整版从原理是可以称为归分排序\n具体过程：\n选取最后一个元素为分界点，遍历数组每一次遍历都去找到小于等于分界点的元素再往数组前面交换\n此时完成了将数组一分为三\n因为是原地排序，所以不需要归并排序的合并操作\n分 先按照具体过程写出《如何将数组一分为三》的代码\n1 2 3 4 5 6 7 8 9 10  let array = [2, 4, 1, 9, 6, 3, 8, 5, 7] let j = 0 //这是左边部分最后一位的index let pivot = array[array.length - 1] for (let i = 0; i \u0026lt; array.length; i++) { if (array[i] \u0026lt;= pivot) { ;[array[j], array[i]] = [array[i], array[j]] //交换array[i] 到最前面  j++ } } console.log(array) //[2, 4, 1, 6, 3, 5, 7, 9, 8] 小于等于分界点所以分界点自己也交换位置到中间了   我们将其封装为函数\n1 2 3 4 5 6 7 8 9 10 11  function partition(array, start, end) { let j = start let pivot = array[end] for (let i = start; i \u0026lt;= pivot; i++) { if (array[i] \u0026lt;= pivot) { ;[array[j], array[i]] = [array[i], array[j]] j++ } } return j - 1 //减去for循环最后多加的一次，返回的是分界点交换到中间位置后的index }   递归 回忆一下在简易版里的递归步骤： 1.将数组分为三部分 2.递归处理左边的部分 3.递归处理右边的部分\n1 2 3 4 5 6  function quickSort(array, start = 0, end = array.length - 1) { let pivotIndex = partition(array, start, end) quickSort(array, start, pivotIndex - 1) quickSort(array, pivotIndex + 1, end) return array }   递归的出口是，当数组元素小于 2 就不用递归了\n即：\n1 2 3 4 5 6 7 8 9  function quickSort(array, start = 0, end = array.length - 1) { if (end - start \u0026lt; 2) { return array } let pivotIndex = partition(array, start, end) quickSort(array, start, pivotIndex - 1) quickSort(array, pivotIndex + 1, end) return array }   复杂度 快速排序的时间复杂度平均是 O(nlogn)，在最坏的情况下，去排序一个已经排好序的数组，时间复杂度会提升至 O(n^2)\n所以 partition 方法是可以优化的，常见策略有选中间、随机选、三选一等。假如这里我们随机选一个分区点，再与最后的元素交换，就能大概率避免最坏情形的出现。\n1 2 3 4  //获取随机分界点 let randomIndex = Math.floor(Math.random() * (end - start + 1) + start) swap(array, end, randomIndex) let pivot = array[end]   由于是原地排序，所以没有空间复杂度，但是递归需要调用栈，所以总体的空间复杂度为 O(logn)，这里相较于简单版的快速排序的空间复杂度 O(nlogn)是有优化的\n我创建了一个集合 jest 可以测试算法的靶场项目：\nhttps://github.com/Llane00/algorithm-range-tests\n将同步文章中的代码到这个项目下\n使用 vscode 的读者可以安装拓展插件 jest，这个插件可以自动检测 test 文件自动运行，非常方便。\n感谢老姚的文章 手写算法并记住它：快速排序（最易理解版）\n","description":"","id":9,"section":"algorithm","tags":["算法基础","学习笔记"],"title":"菜鸟学算法-6-快速排序完整版","uri":"http://llane00.github.io/algorithm/6-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E5%AE%8C%E6%95%B4%E7%89%88/"},{"content":" 这个系列是我读冴羽老师博客的感悟，\n加入了个人的解读和练习题的解答\n 关于浮点数精度导致 js 的计算错误问题，我之前在Js 大数相加有提到过，那这篇文章将再次深入研究导致错误的原因。\nECMAScript 中的 Number 类型使用 IEEE754 标准来表示整数和浮点数值。\nIEEE754 全称为 IEEE 二进制浮点数算数标准，这个标准定义了表示浮点数的格式等内容\n在 IEEE754 中，规定了四种表示浮点数值的方式：单精确度（32 位）、双精确度（64 位）、延伸单精确度与延伸双精确度。\nECMAScript 采用的是双精确度，用 64 位字节储存一个浮点数\n浮点数转二进制 1020 十进制：\n1020 = 1 _ 10^3 + 0 _ 10^2 + 2 _ 10^1 + 0 _ 10^0\n1020 二进制：\n1020 = 1 _ 2^9 + 1 _ 2^8 + 1 _ 2^7 + 1 _ 2^6 + 1 _ 2^5 + 1 _ 2^4 + 1 _ 2^3 + 1 _ 2^2 + 0 _ 2^1 + 0 _ 2^0\n我之前一直好奇用二进制表示小数是什么样的，因为计算器和网上的在线转二进制都不支持小数\n但细想一下一定还是类似的，比如：\n0.75 = a _ 2^-1 + b _ 2^-2 + c _ 2^-3 + d _ 2^-4 + \u0026hellip;\n在二进制里 abcd 只能是 0 或 1\n要继续算出上面的 abcd 是 0 还是 1，我们在等号两边同时乘以 2\n1 + 0.5 = a _ 2^0 + b _ 2^-1 + c _ 2^-2 + d _ 2^-3\u0026hellip;\na * 2^0 = a， 由于 a 只能是 1 或 0，这里 a 应该是组成 1.5 里的最大值，所以 a 为 1\n剩下的的是：\n0.5 = b _ 2^-1 + c _ 2^-2 + d * 2^-3\u0026hellip;\n再次两边都乘以 2\n1 + 0 = b _ 2^0 + c _ 2^-2 + d * 2^-3\u0026hellip;\n同上得出 b 也是 1，同时等号左边已经为 0 了，所以 0.75 的二进制就是 0.11\n然而不是所有的数都像 0.75 这么好算，我们来算下 0.1：\n1 2 3 4 5 6 7 8 9 10 11  0.1 = a * 2^-1 + b * 2^-2 + c * 2^-3 + d * 2^-4 + ... 0 + 0.2 = a * 2^0 + b * 2^-1 + c * 2^-2 + ... (a = 0) 0 + 0.4 = b * 2^0 + c * 2^-1 + d * 2^-2 + ... (b = 0) 0 + 0.8 = c * 2^0 + d * 2^-1 + e * 2^-2 + ... (c = 0) 1 + 0.6 = d * 2^0 + e * 2^-1 + f * 2^-2 + ... (d = 1) 1 + 0.2 = e * 2^0 + f * 2^-1 + g * 2^-2 + ... (e = 1) 0 + 0.4 = f * 2^0 + g * 2^-1 + h * 2^-2 + ... (f = 0) 0 + 0.8 = g * 2^0 + h * 2^-1 + i * 2^-2 + ... (g = 0) 1 + 0.6 = h * 2^0 + i * 2^-1 + j * 2^-2 + ... (h = 1) ....   然后你就会发现，这个计算在不停的循环，所以 0.1 用二进制表示就是 0.00011001100110011……\nIEEE754 中的储存规则 IEEE754 的储存规则其实就是科学计数法:\n 正负 _ 进制的指数 _ 有一位个位的小数(x.x)\n    sign Exponent Mantissa     1 Bit 11 Bits 52 Bits    我们知道-1020 十进制的科学计数法是 -1 _ 10^3 _ 1.02\n那在计算机里我们只关注二进制，\n0.1 的二进制是 0.00011001100110011……\n科学计数法是 1 _ 2^-4 _ 1.1001100110011……\n二进制的第三部分的个位一定是 1，在储存的时候能省位置就省，这个 1 就不存储了，只存小数点后的数字\n由于第二部分的 Exponent 是可以为负数的（小数），11 位可以储存的范围是 0 ～ 2046，\n但是要分正负，所有储存的范围是-1023 ～ 1023，\n但是存负数很麻烦，所以用了一个办法：把 0 当作 1023，把 1023 当作 2046，所有数都加上 1023 即 0 ～ 2048，\n当要用的时候再减去 1023（把 1023 记做 bias）\n在这个标准下：\n我们会用 1 位存储 S，0 表示正数，1 表示负数。\n用 11 位存储 E + bias，对于 11 位来说，bias 的值是 2^(11-1) - 1，也就是 1023。\n用 52 位存储 Fraction。\n举个例子，就拿 0.1 来看，对应二进制是 1 _ 1.1001100110011…… _ 2^-4，\nSign 是 0，\nE + bias 是 -4 + 1023 = 1019，1019 用二进制表示是 1111111011，\nFraction 是 1001100110011……\n0.1 对应 64 个字节位的完整表示就是：\n0 01111111011 1001100110011001100110011001100110011001100110011010\n同理, 0.2 表示的完整表示是：\n0 01111111100 1001100110011001100110011001100110011001100110011010\n所以当 0.1 存下来的时候，就已经发生了精度丢失，当我们用浮点数进行运算的时候，使用的其实是精度丢失后的数\n在运算时也会发生精度丢失，储存和运算都有可能发生超出位数精度丢失。\n","description":"","id":10,"section":"restart-js","tags":["js基础","学习笔记"],"title":"从头学习js-16-浮点数精度","uri":"http://llane00.github.io/restart-js/16-%E6%B5%AE%E7%82%B9%E6%95%B0%E7%B2%BE%E5%BA%A6/"},{"content":" 我想知道这是为什么 \u0026ndash;费曼\n 《归并》指的是递归+合并，是典型的分而治之算法\n把一个数组一分为二，递归地排序好每一部分，最后合并\n并 这个算法的核心点是如何合并两个各自已经排好序的数组，所以先从合并开始\n两权相较取其轻\n数组 A 有一个指针 i\n数组 B 有一个指针 j\n将他们从头一个个比较，较小的就放到结果数组里，然后对应的指针++\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  let left = [2, 4, 6, 9], i = 0 let right = [1, 3, 6, 10, 11], j = 0 let result = [] while (i \u0026lt; left.length \u0026amp;\u0026amp; j \u0026lt; right.length) { if (left[i] \u0026lt; right[j]) { result.push(left[i]) i++ } else { result.push(right[j]) j++ } } console.log(result) //1,2,3,4,6,6,9   仔细看 result 里还漏了 right 里的 10 和 11，因为 left 的数字都已经放到 result 里了，i==left.length，循环就跳出了\n所有还需要处理这种情况\n1 2 3 4 5 6  if (i \u0026lt; left.length) { result.push(...left.slice(i)) } if (j \u0026lt; right.length) { result.push(...right.slice(j)) }   为了清晰表达二者谁都可能剩余，这里没有直接使用 if\u0026hellip;else。事实上不会出现二者都有剩余情况的（while 循环保证的）。另外，这里使用了数组相关 API（concat 也可以），也可以直接使用循环来做。\n分 把一个数组一分为二\n1 2 3  let middlePoint = Math.floor(array.length / 2) //length可能为奇数，向下取整 let left = array.slice(0, middlePoint) let right = array.slice(middlePoint)   递归 递归的步骤： 1.数组分成两半 2.递归处理左边的部分 3.递归处理右边的部分 4.合并二者的结果\n1 2 3 4 5 6  function mergeSort(array) { let middlePoint = Math.floor(array.length / 2) let left = merageSort(array.slice(0, middle)) let right = mergeSort(array.slice(middle)) return merge(left, right) }   这里递归的出口是\n当数组元素个数小于 2 时，就已经是排好序的不用再分了\n1 2 3  if (array.length \u0026lt; 2) { return array }   下面是完整代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34  function merge(left, right) { let i = 0 let j = 0 let result = [] while (i \u0026lt; left.length \u0026amp;\u0026amp; j \u0026lt; right.length) { if (left[i] \u0026lt; right[j]) { result.push(left[i]) i++ } else { result.push(right[j]) j++ } } if (i \u0026lt; left.length) { result.push(...left.slice(i)) } if (j \u0026lt; right.length) { result.push(...right.slice(j)) } return result } function mergeSort(array) { if (array.length \u0026lt; 2) { return array } let middlePoint = Math.floor(array.length / 2) let left = mergeSort(array.slice(0, middlePoint)) let right = mergeSort(array.slice(middlePoint)) return merge(left, right) }   复杂度 归并排序需要额外空间，空间复杂度为 O(n)，不是本地排序，相等元素是不会交换前后顺序，因而是稳定排序。\n时间复杂度为 O(nlogn)，是比较优秀的算法\n我创建了一个集合 jest 可以测试算法的靶场项目：\nhttps://github.com/Llane00/algorithm-range-tests\n将同步文章中的代码到这个项目下\n使用 vscode 的读者可以安装拓展插件 jest，这个插件可以自动检测 test 文件自动运行，非常方便。\n感谢老姚的文章 手写算法并记住它：归并排序\n","description":"","id":11,"section":"algorithm","tags":["算法基础","学习笔记"],"title":"菜鸟学算法-5-归并排序","uri":"http://llane00.github.io/algorithm/5-%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"},{"content":" 这个系列是我读冴羽老师博客的感悟，\n加入了个人的解读和练习题的解答\n 本文讲解javascript的各种继承和优缺点\n1.原型链继承 1 2 3 4 5 6 7 8 9 10 11 12 13 14  function Parent() { this.name = \u0026#34;Neo\u0026#34; } Parent.prototype.getName = function() { console.log(this.name) } function Child() {} Child.prototype = new Parent() var child1 = new Child() child1.getName()   问题：\n1.引用类型的属性被所有实例共享，看例子：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  function Parent() { this.names = [\u0026#34;Anderson\u0026#34;, \u0026#34;Neo\u0026#34;]; } function Child(){} Child.prototype = new Parent() var child1 = new Child() var child2 = new Child() child1.names.push(\u0026#34;the one\u0026#34;) console.log(child1.names) //[\u0026#39;Anderson\u0026#39;, \u0026#39;Neo\u0026#39;, \u0026#39;the one\u0026#39;] console.log(child2.names) //[\u0026#39;Anderson\u0026#39;, \u0026#39;Neo\u0026#39;, \u0026#39;the one\u0026#39;] child2与child1共享了原型Parent上的属性names    2.在创建Child实例时，不能向Parent传参\n2.借用构造函数（经典继承） 1 2 3 4 5 6 7 8 9 10 11 12 13 14  function Parent() { this.names = [\u0026#34;Anderson\u0026#34;, \u0026#34;Neo\u0026#34;] } function Child() { Parent.call(this) } var child1 = new Child() child1.names.push(\u0026#34;the one\u0026#34;); console.log(child1.names) //[\u0026#34;Anderson\u0026#34;, \u0026#34;Neo\u0026#34;, \u0026#34;the one\u0026#34;]  var child2 = new Child() console.log(child2.names) //[\u0026#34;Anderson\u0026#34;, \u0026#34;Neo\u0026#34;]   优点：\n1.避免了引用类型的属性被所有实例共享\n2.可在在Child中向Parents传参\n例子：\n1 2 3 4 5 6 7 8 9 10 11 12 13  function Parent(name) { this.name = name } function Child(name) { Parent.call(this, name) } var child1 = new Child(\u0026#34;child_A\u0026#34;) var child2 = new Child(\u0026#34;child_B\u0026#34;) console.log(child1.name) //child_A console.log(child2.name) //child_B   缺点：\n方法都在构造函数中定义，每次创建实例都会调用一遍方法\n3.组合继承 1的原型和2的构造函数继承的结合\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  function Parent(name) { this.name = name; this.colors = [\u0026#39;red\u0026#39;, \u0026#39;blue\u0026#39;, \u0026#39;green\u0026#39;] } Parent.prototype.getName = function() { console.log(this.name) } function Child(name, age) { Parent.call(this, name) this.age = age } Child.prototype = new Parent(); Child.prototype.constructor = Child; var child1 = new Child(\u0026#34;Neo\u0026#34;, 20) child1.colors.push(\u0026#39;black\u0026#39;) console.log(child1.name) // Neo console.log(child1.age) // 20 console.log(child1.colors) // [\u0026#34;red\u0026#34;, \u0026#34;blue\u0026#34;, \u0026#34;green\u0026#34;, \u0026#34;black\u0026#34;]  var chlid2 = new Child(\u0026#34;Smith\u0026#34;， 28) console.log(child2.name); // Smith console.log(child2.age); // 28 console.log(child2.colors); // [\u0026#34;red\u0026#34;, \u0026#34;blue\u0026#34;, \u0026#34;green\u0026#34;]    优点：融合原型链继承和构造函数的优点，是 JavaScript 中最常用的继承模式\n缺点：缺少封装性\n4.原型式封装 1 2 3 4 5  function createObj(o) { function F(){}; F.prototype = o; return new F(); }   新创建一个构造函数，这个构造函数的原型设为父对象，返回这个构造函数创建的实例对象\n这就是ES5 Object.create的模拟实现，将传入的对象作为创建的对象的原型\n缺点：包含引用类型的属性值会在实例之间共享，这点和原型继承一样\n1 2 3 4 5 6 7 8 9 10 11 12 13  var person = { name: \u0026#34;Neo\u0026#34;, friends: [\u0026#34;Morpheus\u0026#34;, \u0026#34;Trinity\u0026#34;] } var person1 = createObj(person) var person2 = createObj(person) person1.name = \u0026#39;Agent\u0026#39;; console.log(person2.name) //Neo  person1.friends.push(\u0026#34;Smith\u0026#34;) console.log(person2.friends) //[\u0026#34;Morpheus\u0026#34;, \u0026#34;Trinity\u0026#34;, \u0026#34;Smith\u0026#34;]   这里修改person1.name的值，person2的值没有改变，并不是因为person1和person2有独立的name值，而是因为person1.name = \u0026ldquo;Agent\u0026rdquo;，给person1添加了name值\n5.寄生式继承 创建一个仅用于封装继承过程的函数，该函数在内部以某种形式来做增强对象，最后返回对象\n1 2 3 4 5 6 7  function createObj(o) { var clone = Object.create(o) clone.sayHi = function() { console.log(\u0026#34;Hi\u0026#34;) } return clone }   缺点和借用构造函数模式一样，每次生成一个新的对象都会创建一遍方法\n6.寄生组合式继承 再看一次组合继承式的代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  function Parent(name) { this.name = name this.colors = [\u0026#39;red\u0026#39;, \u0026#39;blue\u0026#39;, \u0026#39;green\u0026#39;] } Parent.prototype.getName = function () { console.log(this.name) } function Child(name, age) { Parent.call(this, name) this.age = age } Child.prototype = new Parent() var child1 = new Child(\u0026#34;Neo\u0026#34;, 20)   组合继承最大的缺点是会调用两次父构造函数\n一次是在设置Child.prototype = new Parent()的时候\n一次是在实例化Child新对象的时候 new Child(\u0026ldquo;Neo\u0026rdquo;, 20),\n在new的时候会执行Parent.call(this, name)\n所以此时\nChild.prototype\n和\nchild1\n都有一个color属性，值为[\u0026lsquo;red\u0026rsquo;, \u0026lsquo;blue\u0026rsquo;, \u0026lsquo;green\u0026rsquo;]\n我们可以继续改进方法来避免这一次的重复调用\n不使用Child.prototype = new Parent()，而是间接的让Child.prototype可以访问到Parent.prototype\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  function Parent(name) { this.name = name this.colors = [\u0026#39;red\u0026#39;, \u0026#39;blue\u0026#39;, \u0026#39;green\u0026#39;] } Parent.prototype.getName = function() { console.log(this.name) } function Child(name, age) { this.name = name this.age = age } //关健的3步 function F(){} F.prototype = Parent.prototype Child.prototype = new F() var child3 = new Child(\u0026#34;Neo\u0026#34;, 25)   最后我们来封装一下这个继承方法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  function object(o) { function F(){} F.prototype = o return new F() } function prototype(Child, Parent) { var prototype = object(Parent.prototype) prototype.constructor = Child Child.prototype = prototype } //使用时 prototype(Child, Parent)   这种方式的高效率体现在它只调用了一次Parent构造函数，因此避免了在Parent.prototype上创建了不必要的、多余的属性。与此同时原型链还能保持不变，可以正常使用instanceof和isPrototypeOf。\n开发人员普遍认为寄生组合式继承是引用类型最理想的继承范式。\n","description":"","id":12,"section":"restart-js","tags":["js基础","学习笔记"],"title":"从头学习js-15-继承","uri":"http://llane00.github.io/restart-js/15-%E7%BB%A7%E6%89%BF/"},{"content":" 我想知道这是为什么 \u0026ndash;费曼\n 从有序序列的尾部开始，逐个与目标元素比较，如果大于该元素，该元素需要后移\n核心是如何在有序序列里找到正确的插入位置\n有点像打牌开始的时候整理手牌，每次都把新发的牌从最右侧的手牌一张张往左看，把新牌插入已经排好顺序的手牌里。\n缓存目标元素，从有序序列尾部开始逐个比较，\n如果当前序列的数字大于目标元素则把当前序列的数字后移到目标元素的位置上（目标元素的值已经缓存了，同时后移后当前序列数字的位置变为空），\n继续逐个比较，如果目标元素大于当前序列数字，当前序列数字就后移\n如果小于等于当前序列数字就把目标元素插入 上一次移动序列数字后的空位里\n1 2 3 4 5 6 7 8 9 10 11 12  function insertionSort(array) { for (let i = 0; i \u0026lt; array.lenth; i++) { let j = i let target = array[j] while (j \u0026gt; 0 \u0026amp;\u0026amp; array[j - 1] \u0026gt; target) { array[j] = array[j - 1] j-- } array[j] = target } return array }   复杂度 \u0026amp;\u0026amp; 总结 插入排序不需要额外空间，是本地排序，相等元素是不会交换前后顺序，因而也是稳定排序，时间复杂度为 O(n^2)，适用于少量数据排序。相比冒泡排序和选择排序，插入排序的使用相对多一些。因为前两者是交换排序，本质上需要 3 次原子操作的。\n我创建了一个集合 jest 可以测试算法的靶场项目：\nhttps://github.com/Llane00/algorithm-range-tests\n后续的文章将同步代码到这个项目下\n使用 vscode 的读者可以安装拓展插件 jest，这个插件可以自动检测 test 文件自动运行，非常方便。\n感谢老姚的文章 手写算法并记住它：插入排序\n","description":"","id":13,"section":"algorithm","tags":["算法基础","学习笔记"],"title":"菜鸟学算法-4-插入排序","uri":"http://llane00.github.io/algorithm/4-%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/"},{"content":" 这个系列是我读冴羽老师博客的感悟，\n加入了个人的解读和练习题的解答\n 本文会介绍不同创建对象的方法，来探究不同解决方案的优缺点\n1.工厂模式 创建一个全新的对象，然后给它加上属性和方法，最后返回这个对象\n1 2 3 4 5 6 7 8  function createPerson(name){ var obj = new Object(); obj.name = name; obj.getName = function () { console.log(this.name) }; return obj }   优点：简单直接\n缺点：对象无法识别，所有实例的原型全都直接指向Object.prototype\n2.构造函数模式 创建一个构造函数，然后利用new来创建其实例\n1 2 3 4 5 6 7 8  function Person(name) { this.name = name; this.getName = function (){ console.log(this.name); } } let Neo2 = new Person(\u0026#34;Neo\u0026#34;);   优点：所有实例能归类为一个特定的原型了\n缺点：每次创建实例时，每个方法都要被创建一次，而实际上每个实例用的方法是一样的，这造成了不必要的数据重复\n2.1构造函数模式优化 我们尝试解决2中的缺点，很容易想到去把构造函数里的方法抽出来，然后只要把构造函数的方法指向抽出的方法就好了\n1 2 3 4 5 6 7 8 9 10  function getName() { console.log(this.name) } function Person(name) { this.name = name; this.getName = getName; } let Neo2 = new Person(\u0026#34;Neo\u0026#34;)   优点：不用额外生成重复的方法对象了，方法可以抽出去了\n缺点：因为方法被抽出去了，失去了封装性\n3.原型模式 尝试把属性和方法都加到构造函数的原型上去，再利用new 构造函数来批量创建对象\n1 2 3 4 5 6 7 8  function Person(name){} Person.prototype.name = \u0026#34;Neo\u0026#34;; Person.prototype.getName = function(){ console.log(this.name) // } let Neo3 = new Person()   优点：解决了在创建多个对象的时候不会创建重复的方法对象\n缺点：构造函数不能接受实例初始化参数name，且所有在原型上的属性和方法都会被共享（没有封装性）\n3.1原型模式优化 1 2 3 4 5 6 7 8 9 10  function Person(name){} Person.prototype = { name: \u0026#34;Neo\u0026#34;, getName: function(){ console.log(this.name) } } let Neo3 = new Person()   优点：把对原型的赋值过程封装化了\n缺点：直接赋值构造函数的原型，使得原型的constructor属性丢失\n3.2原型模式再优化 1 2 3 4 5 6 7 8 9 10 11  function Person(name) {} Person.prototype = { constructor: Person, name: \u0026#34;Neo\u0026#34;, getName: function() { console.log(this.name) } } let Neo3 = new Person()   优点：这次可以补全丢失了constructor属性了\n缺点：依旧不能初始化参数，对new出来的实例也没有解决必须共享所有属性和方法问题\n4.组合模式 结合构造模式和原型模式的优点\n1 2 3 4 5 6 7 8 9 10 11 12  function Person(name) { this.name = name; } Person.prototype = { constructor: Person, getName: function() { console.log(this.name) } } let Neo4 = new Person(\u0026#34;Neo\u0026#34;)   优点：可以初始化，不用重复生成相同的函数对象\n缺点：结构上必须分为两个部分\n4.1动态原型模式 1 2 3 4 5 6 7 8 9 10  function Person(name){ this.name = name; if(typeof this.getName != \u0026#34;function\u0026#34;) { Person.prototype.getName = fucntion() { console.log(this.name) } } } var person1 = new Person(\u0026#34;Neo\u0026#34;);   注意：使用动态原型模式时，不能用对象字面量重写原型\n如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  function Person(name) { this.name = name; if (typeof this.getName != \u0026#34;function\u0026#34;) { //此处直接用用对象字面量重写原型，将会引发错误  Person.prototype = { constructor: Person, getName: function () { console.log(this.name); } } } } var person1 = new Person(\u0026#39;kevin\u0026#39;); var person2 = new Person(\u0026#39;daisy\u0026#39;); // 报错 并没有该方法 person1.getName(); // 注释掉上面的代码，这句是可以执行的。 person2.getName();   我们来一步步分析原因，\nnew Person(\u0026lsquo;kevin\u0026rsquo;)后发生的事：\n1.创建一个新对象\n2.把对象的原型指向Person.prototype\n3.执行 Person.apply(obj)\n4.返回对象\n其中第3步，Person.apply(obj),\n将会执行obj.Person\n由于首次时obj.getName不是function，于是执行if语句 此时obj.prototype存的是Person.prototype的地址指针x（第2步的执行结果） 把Person.prototype重新赋值意味着Person.prototype重新赋值了一个新对象的地址y\n动态原型模式为什么不能直接赋值\u0026ndash;示例demo：\n1 2 3 4 5 6 7 8 9 10 11 12 13  let obj = { name: \u0026#34;obj\u0026#34; }; let per = obj; //这里per存的是对象obj的地址  //obj重新赋值为一个新对象的地址 obj = { age: 20 }; // obj { age:20 } //新对象的地址 // per { name:\u0026#34;obj\u0026#34; } //还是指向旧obj的地址   结果：\nobj.prototype 还是指向旧原型的地址，没有getName\nPerson.prototype 指向新的对象，有getName方法\n// 报错 person1的原型指向旧原型，并没有getName方法\nperson1.getName();\n// person2的原型指向新原型对象，有getName方法\nperson2.getName();\n那可以修改代码为\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  function Person(name) { this.name = name; if (typeof this.getName != \u0026#34;function\u0026#34;) { Person.prototype = { constructor: Person, getName: function() { console.log(this.name) } } } //用最新的Person.property再次生成对象返回，构造函数如果返回到是对象，直接返回这个对象  return new Person(name); }   5.1 寄生构造函数模式 先看代码\n1 2 3 4 5 6 7 8 9 10 11 12 13  function Person(name) { var o = new object(); o.name = name; o.getName = function() { console.log(this.name) }; return o; //构造函数如果返回到是对象，直接返回这个对象，o是object的一个实例和Person类没有关系，https://www.cnblogs.com/kenanyah/p/13246934.html } var person1 = new Person(\u0026#34;Neo\u0026#34;) console.log(person1 instanceOf Person) // false 实例无法指向构造函数 console.log(Person1 instanceOf Object) //true   创建出来的实例对象无法指向构造函数，只是寄生在构造函数里的工厂模式，和工厂模式不同的是它可以调用new来创建实例\n5.2 稳妥构造函数模式 1 2 3 4 5 6 7 8 9 10 11 12 13  function person(name) { var o = new Object(); o.getName = function() { console.log(name); } return o; } var person1 = person(\u0026#34;Neo\u0026#34;) person1.getName(); //Neo person1.name = \u0026#34;Llane\u0026#34;; person1.getName(); //Neo console.log(person1.name); //Llane   所谓稳妥对象，指的是没有公共属性，其方法也不引用this的对象\n与寄生构造函数模式有两点不同：\n1.新创建的实例方法不引用this\n2.不使用new操作符调用构造函数\n稳妥对象适合在一些安全的环境中，\n稳妥构造函数和工厂模式一样，无法识别实例对象所属类型\n","description":"","id":14,"section":"restart-js","tags":["js基础","学习笔记"],"title":"从头学习js-14-创建对象","uri":"http://llane00.github.io/restart-js/14-%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1/"},{"content":"我们可以在React官网-React哲学这里找到React对自己的定义：\n 我们认为，React 是用 JavaScript 构建快速响应的大型 Web 应用程序的首选方式。\n 关键词：快速、大型，\n阻碍快速响应的主要是：CPU的瓶颈与IO的瓶颈\nReact想到的解决办法是用并发的更新(视图)模式来代替现在的同步更新模式\nReact Fiber 架构推出，因为旧的架构没法实现并发更新\n","description":"","id":15,"section":"Reactjs","tags":["React"],"title":"3-React-哲学","uri":"http://llane00.github.io/reactjs/3-react-%E5%93%B2%E5%AD%A6/"},{"content":"从函数的角度来理解hooks的概念 React理念：UI = f(data)\n视图UI会根据自变量变化\n自变量： useState 定义自变量\nuseReducer(复杂版的useState，为了方便操作更多自变量)\nuseContext 为了跨组件操作自变量\n因变量： 定义无副作用的因变量（因变量依赖自变量变化）\nuseMemo 缓存一个因变量(由自变量计算得到的变量)+定义依赖\nuseCallBack 缓存一个函数类型的因变量(实际情况下可能是一个点击响应事件，事件触发后由自变量计算得到因变量)+定义依赖\n定义有副作用的因变量（副作用指的是会导致视图在相同自变量的情况下却出现了不同视图的操作）\nuseEffect 因变量\n标记变量： useRef 标记变量 为了让组件的逻辑更灵活\nmore：\n9分钟掌握React Hooks正确认知\n","description":"","id":16,"section":"Reactjs","tags":["React"],"title":"学习React_hooks_2","uri":"http://llane00.github.io/reactjs/2-react-hooks/"},{"content":" 我想知道这是为什么 \u0026ndash;费曼\n 选择排序，是每次遍历都选最小的一个数交换到已经排好的序列的后面\n有点像从小到大，依次找到每个位置上正确的数\n5 4 3 2 1\n第一次遍历发现最小的是 1\n把 5 和 1 交换\n1 4 3 2 5\n第二次遍历从 4 开始（1 已经是排好的序列了）开始发现在（4 3 2 5）里最小的是 2\n把 4 和 2 交换\n1 2 3 4 5\n第三次遍历从 3 开始在（3 4 5）里 3 已经是最小的了，这次不交换\n第四次遍历从 4 开始，同上发现 4 也已经是最小的了\n第五次最后这次遍历不用做了，在前面都是从小到大排好序的，最后这个数字就是最大的\n我们开始写代码：\n1 2 3 4 5 6 7 8  //先看在一次遍历里做了什么  let minNumberIndex = 0 for (let i = 0; i \u0026lt; array.length; i++) { if (array[i] \u0026lt; array[minNumberIndex]) { minNumberIndex = i } }   1 2 3 4 5 6 7 8 9 10 11 12 13 14  function selectionSort(array) { for (var j = 0; j \u0026lt; array.length - 1; j++) { let minNumberIndex = j for (let i = j; i \u0026lt; array.length; i++) { if (array[i] \u0026lt; array[minNumberIndex]) { minNumberIndex = i } } if (minNumberIndex !== j) { ;[array[i], array[minNumberIndex]] = [array[minNumberIndex], array[i]] } } return array }   选择排序和冒泡排序很类似都是在每一次遍历的时候去找最大或者最小的值，然后把找到的值去（通过交换）排好序列，\n下一次的遍历从余下的数字里进行\n总结：\n选择排序不需要额外空间，是本地排序，相等元素是不会交换前后顺序，因而也是稳定排序，时间复杂度为 O(n^2)，适用于少量数据排序，但实际中用得不多\n非常感谢老姚的文章：\n手写算法并记住它：选择排序\n","description":"","id":17,"section":"algorithm","tags":["算法基础","学习笔记"],"title":"菜鸟学算法-3-选择排序","uri":"http://llane00.github.io/algorithm/3-%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/"},{"content":"由于我目前还是用vscode居多，vscode的插件和环境配置对前端开发更加友好，我打算还是在vscode上开发，辅助用vscode+vim的快捷键来搭配使用\n这里推荐一些vscode上的插件：\n1.Vim 记得按照插件文档输入命令然后在vscode的settings中加入默认的一些按键配置，\n不得不说这个jj退出insert模式的快捷键比ESC或者command+c或者command+[ 都要好用\n2.TabOut 可以在insert模式下用tab按键来跳出括号和花括号，实测好用，我居然才知道\nvim对中文输入其实是不太友好的，normal模式下如果此时是拼音输入会很麻烦\ninsert模式下想按jj到normal结果发现现在是拼音模式又得删除jj\n尽管我已经尝试安装了im-select依然还是觉得不便, 可以参考这个知乎上的问题 https://www.zhihu.com/question/303850876\n后续我会尝试把.vimrc 的一些实用快捷键配置结合到vscode中的settings.json\nto be continued \u0026hellip;\n","description":"","id":18,"section":"posts","tags":["学习笔记"],"title":"Vim使用笔记2","uri":"http://llane00.github.io/posts/vim%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B02/"},{"content":" 这个系列是我读冴羽老师博客的感悟，\n加入了个人的解读和练习题的解答\n 类数组 在之前模拟实现apply和bind时我们其实已经遇见过arguments这样的类数组文件了\n1 2 3 4 5 6 7  var array = [\u0026#39;A\u0026#39;, \u0026#39;B\u0026#39;, \u0026#39;C\u0026#39;] var arrayLike = { 0: \u0026#39;A\u0026#39;, 1: \u0026#39;B\u0026#39;, 2: \u0026#39;C\u0026#39;, lenght: 3 }   类数组文件的读取，遍历方式和数组一样\n1 2 3 4 5 6 7 8  array[0] arrayLike[0] array.length arrayLike.length for(var i=0; i\u0026lt;array.length; i++){} for(var i=0; i\u0026lt;arrayLike.length; i++){}   但是类数组终究不是数组不能调用数组的原型方法，比如push、splice、slice\n常用的做法是Array.prototype.splice.call(arrayLike, 2)\n利用call在直接调用Array原型方法的时候把this指向arrayLike对象\n另外经常需要把类数组对象转为数组，方法如下：\n1 2 3 4 5  Array.prototype.slice.call(arrayLike) //slice 用于截取数组从start到end，省略end时默认到数组末尾 Array.prototype.splice.call(arrayLike, 0) //splice 可以插入删除，参数index, deleteNumber, item1,...,itemX Array.prototype.concat.call([], arrayLike) Array.from(arrayLike) //es6 Array.from [...arguments] //es6 拓展运算符   Aruguments对象 在函数体中arguments指代函数的Arguments对象\nAruguments的length，指的是实参的长度\nArguments的callee通过它可以调用函数本身\n1 2 3 4 5 6 7 8 9 10 11 12 13  //用callee来解决之前第8篇中的for循环无法保存i到函数内部的问题  var data = [] for (var i = 0; i\u0026lt; 3; i++) { (data[i] = function(){ console.log(arguments.callee.i) ).i = i } data[0](); //0 data[1](); //1 data[2](); //2   乍一看在for循环中的那部分有点奇怪，我们拆开看\nxxx.i = i 是在xxx的属性i赋值为i\n括号内:\ndata[i] = 某个东西\n(data[i] = 赋值内容).i = i 其实就是\ndata[i].i = i\n接下来看赋值的内容\n是一个函数对象，函数对象在创建的时候不会执行内部的代码\nargument.callee 指的就是 data[i]\nargument.callee.i 自然就是data[i].i\n那因为纯的赋值 = xx 会在for循环里立即执行，所有i的每个状态都会存在对应的data[x]里\narguments 和对应参数的绑定\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  function foo(name, age, sex, hobbit) { console.log(name, arguments[0]); // name name  // 改变形参  name = \u0026#39;new name\u0026#39;; console.log(name, arguments[0]); // new name new name  // 改变arguments  arguments[1] = \u0026#39;new age\u0026#39;; console.log(age, arguments[1]); // new age new age  // 测试未传入的是否会绑定  console.log(sex); // undefined  sex = \u0026#39;new sex\u0026#39;; console.log(sex, arguments[2]); // new sex undefined  arguments[3] = \u0026#39;new hobbit\u0026#39;; console.log(hobbit, arguments[3]); // undefined new hobbit  } foo(\u0026#39;name\u0026#39;, \u0026#39;age\u0026#39;)   传入参数时，实参和arguments的值会共享，没有传入参数时，实参和arguments的值不会共享\n在严格模式下都不会共享\n传递参数\n将参数从一个函数传递到另一个函数\n1 2 3 4 5 6 7 8 9  //利用apply的第二个参数可以直接传一个数组 function foo(){ bar.apply(this, [...arguments]) } function bar(){ console.log(a, b, c) } foo(1, 2, 3)   ","description":"","id":19,"section":"restart-js","tags":["js基础","学习笔记"],"title":"从头学习js-13-类数组对象与arguments","uri":"http://llane00.github.io/restart-js/13-%E7%B1%BB%E6%95%B0%E7%BB%84%E5%AF%B9%E8%B1%A1%E4%B8%8Earguments/"},{"content":" 我想知道这是为什么 \u0026ndash;费曼\n 冒泡排序我想是大部分人接触的第一个排序算法，原理也很形象，\n每一次轮询都会将这一轮里能找到的最大（小）的数字通过一个个相邻比较和交换位置，最后归到数组的后面\n先来看一次轮询的操作，把最大值放到最后\n1 2 3 4 5 6  let array = [5, 4, 3, 2, 1] for (let i = 0; i \u0026lt; array.length - 1; i++) { if (array[i] \u0026gt; array[i + 1]) { ;[array[i + 1], array[i]] = [array[i], array[i + 1]] //swap  } }   array 有 n 个元素，就要做 n 次轮询的操作\n1 2 3 4 5 6 7 8  let array = [5, 4, 3, 2, 1] for (let j = 0; j \u0026lt; array.length; j++) { for (let i = 0; i \u0026lt; array.length - 1; i++) { if (array[i] \u0026gt; array[i + 1]) { ;[array[i + 1], array[i]] = [array[i], array[i + 1]] //swap  } } }   这里还能优化一下，我们可以发现：\n第一次 j==0 时\ni==3 时就把最大值交换到最后了\n第二次 j==1 时\ni==2 时就把最大值交换到最后了\n第三次 j==2 时\ni==1 时就把最大值交换到最后了\n第四次 j==3 时\ni==0 时就把最大值交换到最后了\n也就是每次开始新的轮询时，length 都比上一次少 1\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  let array = [5, 4, 3, 2, 1] function bubbleSort(array) { for (let j = 0; j \u0026lt; array.length; j++) { for (let i = 0; i \u0026lt; array.length - 1 - j; i++) { if (array[i] \u0026gt; array[i + 1]) { ;[array[i + 1], array[i]] = [array[i], array[i + 1]] //swap  } } } return array } console.log(bubbleSort(array))   总结：\n冒泡排序不需要额外空间，是本地排序，相等元素是不会交换前后顺序，因而也是稳定排序，时间复杂度为 O(n^2)，适用于少量数据排序，但实际中用得不多\n非常感谢老姚的文章：\n手写算法并记住它：冒泡排序\n","description":"","id":20,"section":"algorithm","tags":["算法基础","学习笔记"],"title":"菜鸟学算法-2-冒泡排序","uri":"http://llane00.github.io/algorithm/2-%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/"},{"content":" 这个系列是我读冴羽老师博客的感悟，\n加入了个人的解读和练习题的解答\n 我们先分析一下new做了什么，\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  function Person(name, age) { this.name = name; this.age = age; } Person.prototype.runSpeed = 10; // 10km/h  Person.prototype.run = function() { console.log(\u0026#34;running\u0026#34;); } var theOne = new Person(\u0026#39;Neo\u0026#39;, 20); console.log(theOne.name) //Neo console.log(theOne.age) //20 console.log(theOne.runSpeed) //10  theOne.run() //running    js中的关键词new 可以创建一个新对象，这个新对象的原型是new后面跟的构造函数的原型，\n在上面这个例子中，实例theOne的原型是Person，实例theOne可以：\n1.访问到构造函数Person的属性\n2.访问到构造函数Person的原型的属性\n尝试模拟：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  function objectFactory() { // 创造一个空对象  var obj = Object({}); //函数的第一个参数是obj的构造函数，使得obj可以访问构造函数的原型的属性  Constructor = [].shift.call(arguments); //空对象的原型是构造函数的原型  obj.__proto__ = Constructor.prototype; //重新指向this为obj后，执行构造函数，使得obj可以访问构造函数的内部属性  Constructor.apply(obj, arguments); return obj; }   还有一种情况需要考虑，就是构造函数有返回值时，\nobj访问构造函数内部的属性就有了限制，为了实现封装\n比如：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  function Person(name, age) { this.name = name; this.age = age; return { name: name, sex: \u0026#39;male\u0026#39; } } var theOne = new Person(\u0026#39;Neo\u0026#39;, 20); //实例theOne只能返回构造函数返回的对象中的属性 console.log(theOne.name) //Neo console.log(theOne.age) //undefined console.log(theOne.sex) //male   而如果构造函数返回的不是对象\n1 2 3 4 5 6 7 8 9 10 11 12  function Person(name, age) { this.name = name; this.age = age; return \u0026#34;warning: no access\u0026#34; } var theOne = new Person(\u0026#39;Neo\u0026#39;, 20); //相当于没有返回值进行处理 console.log(theOne.name) //undefined console.log(theOne.age) //undefined   好的，我们来完善一下objectFactory方法：\n1 2 3 4 5 6 7  function objectFactory() { var obj = Object({}) Constructor = [].shift.call(arguments) obj.__proto__ = Constructor.prototype var result = Constructor.apply(obj, arguments) return typeof result === \u0026#39;object\u0026#39;? result : obj; }   ","description":"","id":21,"section":"restart-js","tags":["js基础","学习笔记"],"title":"从头学习js-12-模拟实现new","uri":"http://llane00.github.io/restart-js/12-%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0new/"},{"content":" 这个系列是我读冴羽老师博客的感悟，\n加入了个人的解读和练习题的解答\n MDN对bing的定义 bind()方法会创建一个新函数。当这个函数被调用时，bind()的第一个参数将作为它运行时的this，之后的一序列参数将会在传递的实参前传入作为它的参数\nbind 函数的两个特点：\n1.返回一个函数\n2.可以传入参数\n例子1:\n1 2 3 4 5 6 7 8 9 10  var foo = { value: 1 } function bar(){ console.log(this.value) } var bindFoo = bar.bind(foo) bindFoo() //1   第一版 1 2 3 4 5 6  function myBind(context) { var self = this; return function() { return self.apply(context) } }   刚才的定义中提到bind还支持传参数来看个例子：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  var foo = { value: 1 }; function bar(name, age) { console.log(this.value); console.log(name); console.log(age); } var bindFoo = bar.bind(foo, \u0026#39;daisy\u0026#39;); bindFoo(\u0026#39;18\u0026#39;); // 1 // daisy // 18   第二版 1 2 3 4 5 6 7 8 9  function myBind(context) { var self = this; var args = Array.prototype.slice.call(arguments, 1) return function() { var bindArgs = Array.prototype.slice.call(arguments) return self.apply(context, args.concat(bindArgs)) } }   此时到了最难的部分，bind还有一个特性：\n一个绑定函数也能使用new操作符创建对象：这种行为就像把原函数当成构造器。提供的 this 值被忽略，同时调用时的参数被提供给模拟函数。\n来看例子：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  var value = 2; var foo = { value: 1 }; function bar(name, age) { this.habit = \u0026#39;shopping\u0026#39;; console.log(this.value); console.log(name); console.log(age); } bar.prototype.friend = \u0026#39;kevin\u0026#39;; var bindFoo = bar.bind(foo, \u0026#39;daisy\u0026#39;); var obj = new bindFoo(\u0026#39;18\u0026#39;); // undefined 提供的this值被忽略 // daisy 调用bind时的参数被一起提供了 // 18 console.log(obj.habit); console.log(obj.friend); // shopping // kevin   第三版 1 2 3 4 5 6 7 8 9 10  function myBind(context) { var self = this; var args = Array.prototype.slice.call(arguments, 1) var fBound = function(){ var bindArgs = Array.prototype.slice.call(arguments) return self.apply(this instanceOf fBound? this : context, args.concat(bindArgs)) } fBound.prototype = this.prototype; return fBound; }   但是在这个写法中，我们直接将 fBound.prototype = this.prototype，\n我们直接修改 fBound.prototype 的时候，也会直接修改绑定函数的 prototype。\n这个时候，我们可以通过一个空函数来进行中转：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  function myBind(context) { var self = this; var args = Array.prototype.slice.call(arguments, 1) var fNop = function(){} var fBound = function(){ var bindArgs = Array.prototype.slice.call(arguments) return self.apply(this instanceOf fNop? this : context, args.concat(bindArgs)) } fNop.prototype = this.prototype; fBound.prototype = new fNop() return fBound; }   以后要在生产环境中使用时，我们再补上对参数和函数名字的判断\n第四版 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  Function.prototype.bind = Function.prototype.bind || function(context) { if (typeof this !== \u0026#34;function\u0026#34;) { throw new Error(this + \u0026#34;.bind is not a function!\u0026#34;) } var self = this; var args = Array.prototype.slice.call(arguments, 1); var fNop = function(){} var fBound = function() { var bindArgs = Array.prototype.slice.call(arguments) return self.apply(this instanceOf fNop? this : context, args.concat(bindArgs)) } fNop.prototype = this.prototype; fBound.prototype = new fNop(); return fBound; }   ","description":"","id":22,"section":"restart-js","tags":["js基础","学习笔记"],"title":"从头学习js-11-模拟实现bind","uri":"http://llane00.github.io/restart-js/11-%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0bind/"},{"content":" 这个系列是我读冴羽老师博客的感悟，\n加入了个人的解读和练习题的解答\n call使用的例子：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  var foo = { value: 1 }; function bar(name, age) { console.log(name) console.log(age) console.log(this.value); } bar.call(foo, \u0026#39;kevin\u0026#39;, 18); // kevin // 18 // 1   用js模拟call：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  Function.prototype.myCall = function (newContext) { var context = Object(newContext) || window; //如果传的对象是null，默认指向window  context.fn = this; //将当前方法作为对象的一个属性  //梳理一下参数，从第二个参数开始(下标为1)  var args = []; for(var i = 1, len = arguments.length; i \u0026lt; len; i++) { args.push(\u0026#39;arguments[\u0026#39; + i + \u0026#39;]\u0026#39;); } //执行方法  var result = eval(\u0026#39;context.fn(\u0026#39; + args + \u0026#39;)\u0026#39;); delete context.fn; //删除临时属性方法  return result; }   apply和call非常类似，两者的区别只是接受的参数形式不同：\nbar.call(foo, \u0026lsquo;kevin\u0026rsquo;, 18)\nbar.apply(foo, [\u0026lsquo;kevin\u0026rsquo;, 18])\n用js模拟apply:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  Function.prototype.myApply = function (newContext, arr) { var context = Object(newContext) || window; //如果传的对象是null，默认指向window  context.fn = this; //将当前方法作为对象的一个属性  //梳理参数，这次从下标0开始，并执行方法  var result; if (!arr) { result = context.fn() } else { var args = []; for(var i = 0, len = arr.length; i \u0026lt; len; i++) { args.push(\u0026#39;arr[\u0026#39; + i + \u0026#39;]\u0026#39;) } result = eval(\u0026#39;context.fn(\u0026#39; + args + \u0026#39;)\u0026#39;); } delete context.fn; //删除临时属性方法  return result; }   ","description":"","id":23,"section":"restart-js","tags":["js基础","学习笔记"],"title":"从头学习js-10-模拟实现call和apply","uri":"http://llane00.github.io/restart-js/10-%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0call%E5%92%8Capply/"},{"content":" 我想知道这是为什么 \u0026ndash;费曼\n 快速排序从形式上为归分算法 1.分 核心是把数组按分界点一分为三\n1 2 3  let pivot = array[array.length-1] let left = array.filter((item, index) =\u0026gt; item \u0026lt;= pivot \u0026amp;\u0026amp; index != array.length-1) let right = array.filter((item, index) =\u0026gt; item \u0026gt; pivot)   2.归 需要合并三个部分为一个数组\n1  let result = [...left, pivot, ...right]   3.最后利用递归的思想，完成算法\n递归步骤：\n1.数组分为3部分，left pivot right，left\u0026lt;=pivot\u0026lt;right\n2.递归处理左边的部分\n3.递归处理右边的部分\n4.合并三者的结果\n1 2 3 4 5 6  function quickSort(array) { let pivot = array[array.length - 1] let left = array.filter((item, index) =\u0026gt; item \u0026lt;= pivot \u0026amp;\u0026amp; index != array.length-1) let right = array.filter((item, index) =\u0026gt; item \u0026gt; pivot) return [...left, pivot, ...right] }   递归是调用自身，不能无限次调用下去，因此需要有递归的出口（初始条件）\n当数组元素长度小于2时，就已经是排好序了，不用再递归了，我们完善下代码\n1 2 3 4 5 6 7  function quickSort(array) { if (array.length \u0026lt; 2) return array let pivot = array[array.length-1] let left = array.filter((item, index) =\u0026gt; item \u0026lt;= pivot \u0026amp;\u0026amp; index != array.length -1) let right = array.filter((item, index) =\u0026gt; item \u0026gt;pivot) return [...qucikSort(left), pivot, ...quickSort(right)] }   时间复杂度 我之前一直对时间复杂度的log感觉很模糊，看了下面这句话才恍然大悟\n 时间复杂度，2的64次方个有序数据二分查找也顶多循环64次\n 此版本的快速排序每一次递归调用，需要额外空间，复杂度为O(n)，不是本地排序。\n说起空间复杂度，递归也需要空间（相当于手动维护一个调用栈），因此总体空间复杂度是O(nlogn)。相等元素是不会交换前后顺序，因而是稳定排序（这与我们选择最后一个元素为分界点有关）。\n时间复杂度为O(nlogn)。\n非常感谢老姚的文章：\n手写算法并记住它：快速排序（5行代码简单版）\n","description":"","id":24,"section":"algorithm","tags":["算法基础","学习笔记"],"title":"菜鸟学算法-1-简单版快速排序","uri":"http://llane00.github.io/algorithm/1-%E7%AE%80%E5%8D%95%E7%89%88%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"},{"content":" 这个系列是我读冴羽老师博客的感悟，\n加入了个人的解读和练习题的解答\n 在《JavaScript高级程序设计》第三版 4.1.3，讲到传递参数：\n ECMAScript中所有函数的参数都是按值传递的。\n 那么js中的参数分为基本类型和引用类型\n在内存中有栈和堆两个区域，栈用于储存基本类型的数据，而堆用于存放引用类型的数据\n（后续还有常量区先不讲）\n1 2  let a = 1; let b = {name: \u0026#39;Neo\u0026#39;, age: 25};   以上的代码会在内存中储存数据形式大致如下：\n在栈中有：\na(值为1)\nb(值为一个指针，一个指向堆中对象数据的地址假设为1000)\n在堆中有：\n{name: \u0026lsquo;Neo\u0026rsquo;, age: 25}\n其中指针1000指向{name: \u0026lsquo;Neo\u0026rsquo;, age: 25}\n  栈内存堆内存   a1   b指针地址1000{name: 'Neo', age: 25}    例子1：\n1 2 3 4 5 6 7  var value = 1; function foo(v) { v = 2; console.log(v); //2 } foo(value); console.log(value) // 1   例子1会打印\n2\n1\nfoo(value) 函数开始执行时，初始化AO，然后加入形参\n执行了像var v = value这样的一个操作，把value赋值给了函数内的参数v\n  栈内存堆内存   value1   v1    再执行v = 2，重新赋值v\n  栈内存堆内存   value1   v2    例子2:\n1 2 3 4 5 6 7 8 9  var obj = { value: 1 }; function foo(o) { o.value = 2; console.log(o.value); //2 } foo(obj); console.log(obj.value) // 2   foo(obj) 函数开始执行时，初始化AO，然后加入形参\nvar o = obj，把obj值的引用赋值给了o\n 栈内存堆内存   obj，o指针地址{value: 1}   此时o.value = 2会沿着引用找到obj指向的值并修改\n 栈内存堆内存   obj，o指针地址{value: 2}   例子3:\n1 2 3 4 5 6 7 8 9  var obj = { value: 1 }; function foo(o) { o = 2; console.log(o); //2 } foo(obj); console.log(obj.value) // 1   foo(o) 函数开始执行时，初始化AO，然后加入形参\nvar o = obj，把obj值的引用赋值给了o\n 栈内存堆内存   obj，o指针地址{value: 1}   此时o = 2会赋值o把指针的值覆盖修改为2\n 栈内存堆内存   obj指针地址{value: 1}   o2  ","description":"","id":25,"section":"restart-js","tags":["js基础","学习笔记"],"title":"从头学习js-9-函数的参数传递","uri":"http://llane00.github.io/restart-js/9-%E5%87%BD%E6%95%B0%E7%9A%84%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92/"},{"content":" 这个系列是我读冴羽老师博客的感悟，\n加入了个人的解读和练习题的解答\n 在MDN广泛定义中闭包指的是能访问自由变量的函数（自由变量指的是即不是这个函数的参数也不是这个函数的内部变量）\n由于函数都有作用域链，所有函数都可以访问到全局上下文中的变量那所有函数其实都是闭包\n在实际场景中，对闭包的定义更加具体，在第7篇的第二个例子中其实遇到了闭包的经典例子\n闭包需要满足：\n1.即使创建它的上下文已经销毁，它仍然存在（比如，内部函数从父函数中返回）\n2.在代码中引用了自由变量\n分析一个例子：\n1 2 3 4 5 6 7 8 9 10 11  var scope = \u0026#34;global scope\u0026#34;; function checkscope(){ var scope = \u0026#34;local scope\u0026#34;; function f(){ return scope; } return f; } var foo = checkscope(); foo(); //这里会打印local scope   例子中的函数f在父函数checkScope中，\n由于父函数会return f且在之后赋值给foo调用了，所以即使父函数checkScope执行结束，函数f也存在\n函数f中引用了父函数中的变量scope所以函数f符合闭包的定义\n通过之前的文章，我们其实知道更深的原因了，就是函数f在创建的时候就根据上下文保存了一个作用域链\n在函数f初始化执行上下文的时候复制了这个作用域链\n1 2 3 4  f.[[scope]] = [checkscopeContext.AO, globalContext.VO] fContext = { scope: [AO, checkscopeContext.AO, globalContext.VO] }   在沿着作用域链查找scope变量时，AO中没有，而继续查checkscopeContext.AO时找到了scope变量（值为local scope）\n例子2:\n1 2 3 4 5 6 7 8 9 10 11  var data = []; for (var i = 0; i \u0026lt; 3; i++) { data[i] = function () { console.log(i); }; } data[0](); data[1](); data[2]();   这道题是非常经典的闭包问题，当时作为初学者的我无法理解真正的原因最后只能硬记下结论\n现在我们用作用域链和执行上下文的知识点就可以拨开云雾了\n首先for不是函数for 中var声明的i其实是全局变量，\nfor循环执行完后的情况是这样的\n1 2 3 4 5 6 7 8 9 10  globalContext = { VO: { data: [ 0: reference to function(){console.log(i)}, //这个匿名函数的内部属性[[scope]]=[globalContext.VO]  1: reference to function(){console.log(i)}, //这个匿名函数的内部属性[[scope]]=[globalContext.VO]  2: reference to function(){console.log(i)}, //这个匿名函数的内部属性[[scope]]=[globalContext.VO]  ], i: 3 } }   函数的内部代码如果只是创建是不会去执行的，匿名函数内部还是变量i的指向状态，\n在之后真正开始执行的时候data0,开始创建AO，完善执行上下文的作用域链scope=[AO, globalContext.VO]\nAO中没有i，就找到了globalContext中的i，而此时globalContext中的i已经是3了，\n所以三个匿名函数最后都会打印3\n通常要解决这个问题会用一个新的匿名函数形成闭包或者用let\n我们想在data[0]的执行上下文作用域链接里塞上真正期望的i，scope=[AO, xContext.AO, globalContext.VO]\nxContext.AO中存有不同的i\n1 2 3 4 5 6 7 8 9 10 11 12 13  var data = [] for (var i = 0; i \u0026lt; 3; i++) { data[i] = (function(i){ return function(){ console.log(i) } })(i); } data[0](); data[1](); data[2]();   (functionx(i){})(i)相当于\nfunction x(i){}\nx(i)\n这个匿名函数会在data[0]的执行上下文的作用域中插入，\n此时data[0]在执行时，作用域变为\n1 2 3 4 5 6 7 8 9 10 11 12 13  data[0]Context = { scope: [AO, 匿名函数Context.AO, globalContext.VO] } 匿名函数Context = { AO: { arguments: { 0:0, length: 1 }, i: 0 } }   data[0]Context.AO中没有i值，沿着作用域找到了匿名函数Context中的i\n在for循环的时候匿名函数立即执行了才在AO中保留了不同的i，如果没有立即执行也只是保留了一个指向i的值\n","description":"","id":26,"section":"restart-js","tags":["js基础","学习笔记"],"title":"从头学习js-8-闭包","uri":"http://llane00.github.io/restart-js/8-%E9%97%AD%E5%8C%85/"},{"content":" 这个系列是我读冴羽老师博客的感悟，\n加入了个人的解读和练习题的解答\n 本篇是3、4、5、6篇的汇总，会用两个例子来详细说明执行上下文的运行流程\n例子1 1 2 3 4 5 6 7 8 9  var scope = \u0026#34;global scope\u0026#34;; function checkscope(){ var scope = \u0026#34;local scope\u0026#34;; function f(){ return scope; } return f(); } checkscope();   1.执行全局代码，创建全局上下文，全局上下文压入执行上下栈\n1 2 3  ECStack = [ globalContext ]   2.初始化全局上下文\n1 2 3 4 5  globalContext = { VO: [global], scope: [globalContext.VO], this: globalContext.VO }   2.初始化的同时，创建checkScope函数，checkscope函数保存作用域链到函数内部属性\n1  checkscope.[[scope]] = [globalContext.VO];   3.执行checkscope函数，创建checkScope执行上下文，压入执行上下文栈\n1 2 3 4  ECStack = [ checkscopeContext, globalContext ]   4.初始化checkScope执行上下文，\n4.1复制checkscope函数的内部属性[[scope]]创建作用域链\n4.2用arguments创建AO活动对象，\n4.3初始化活动对象，即加入函数形参，函数声明，变量声明\n4.4将活动对象压入checkscope的作用域顶端\n1 2 3 4 5 6 7 8 9 10 11  checkscopeContext = { AO: { arguments: { length: 0 }, scope: undefined, f: reference to fucntion f(){} }, scope: [AO, globalContext.VO], this: undefined }   同时f函数被创建，保存作用域链到f函数内部属性[[scope]]\n1  f.[[scope]] = [checkscopeContext.AO, globalContext.VO];   5.执行f函数，创建f函数执行上下文，将其压入执行上下文栈\n1 2 3 4 5  ECStack = [ fContext, checkscopeContext, globalContext ]   6.f函数执行上下文初始化，\n6.1复制函数[[scope]]属性创建作用域链\n6.2用arguments创建活动对象\n6.3舒适化活动对象，即加入形参，函数声明，变量声明\n6.4将活动对象压入f作用域顶端\n1 2 3 4 5 6 7 8 9  fContext = { AO: { arguments: { length: 0 }, }, scope: [AO, checkScopeContext.AO, globalContext.VO], this: undefined }   7.执行函数f，沿着作用域链找到scope的值，返回scope的值\n8.函数f执行完毕后，在ECStack中出栈\n1 2 3 4 5  ECStack.pop() ECStack = [ checkscopeContext, globalContext ]   9.函数checkScope执行完毕后在ECStack出栈，\n1 2 3 4  ECStack.pop() ECStack = [ globalContext ]   例子2 例子2和例子很相似\n1 2 3 4 5 6 7 8 9  var scope = \u0026#34;global scope\u0026#34;; function checkscope(){ var scope = \u0026#34;local scope\u0026#34;; function f(){ return scope; } return f; } checkscope()();   1.开始执行全局代码，创建全局上下文，并将其压入上下文执行栈\n1 2 3  ECStack = [ globalContext ]   2.初始化全局上下文\n1 2 3 4 5  globalContext = { VO: [global], scope: globalContext.VO, this: globalContext.VO }   2.初始化的同时创建函数checkscope，函数checkScope保存作用域链到其内部属性[[scope]]\n1  checkscope.[[scope]] = [globalContext.VO];   3.执行函数checkScope，创建checkScope函数的执行上下文，并将其压入上下文执行栈\n1 2 3 4  ECStack = [ checkScopeContext, globalContext ]   4.初始化checkScope执行上下文，\n4.1保存函数的内部属性[[scope]]到执行上下文的作用域链\n4.2根据函数的arguments创建活动对象AO\n4.3初始化活动对象，即加入函数形参，函数声明，变量声明\n4.4将活动对象压入checkscope作用域的顶端\n1 2 3 4 5 6 7 8 9 10 11  checkScopeContext = { AO: { arguments: { length: 0 }, scope: undefined, f: reference to fucntion f(){} }, scope: [AO, globalContext], this: undefined }   4.同时创建函数f，保存作用域链到f函数内部属性[[scope]]\n1  f.[[scope]] = [checkscopeContext.AO, globalContext.VO];   5.沿着作用域找到函数f的指向，返回函数f的指向，函数checkScope执行完毕后在ECStack出栈\n1 2 3 4  ECStack.pop() ECStack = [ globalContext ]   6.执行checkScope返回的函数f，创建函数f的执行上下文，将其压入执行上下文栈\n1 2 3 4  ECStack = [ fContext, globalContext ]   7.初始化f的执行上下文fContext\n7.1复制函数内部属性scope到函数上下文的作用域链\n7.2根据函数的arguments创建活动对象AO\n7.3初始化活动对象，即加入函数形参，函数声明，变量声明\n7.4将活动对象压入函数上下文作用域链的顶端\n1 2 3 4 5 6 7 8 9  fContext = { AO: { arguments: { length: 0 } } scope: [AO, checkScopeContext.AO, globalContext] this: undefined }   8.执行函数f，沿着作用域链找到scope的值（这里是在checkScopeContext.AO里找到scope的，即便checkScopeContext.AO已经在ECStack中出栈，这就是闭包的原理），返回scope的值\n7.函数f执行完毕后，f的执行上下文从执行上下文栈中弹出\n1 2 3 4  ECStack.pop() ECStack = [ globalContext ]   ","description":"","id":27,"section":"restart-js","tags":["js基础","学习笔记"],"title":"从头学习js-7-执行上下文汇总篇","uri":"http://llane00.github.io/restart-js/7-%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E6%B1%87%E6%80%BB%E7%AF%87/"},{"content":" 这个系列是我读冴羽老师博客的感悟，\n加入了个人的解读和练习题的解答\n this一直都是学习js的时候很头疼的东西，\n继续接着上篇说，当javascript代码执行一段可执行代码(executable code)时，会创建对应的执行上下文(execution context)\n那对于每个执行上下文，都有三个重要属性：\n 变量对象(Variable object, VO) 作用域链(Scope chain) this  本文主要讲执行上下文中的this\n首先了解ECMAScript规范 我们根据ECMAScript规范来解读this\nECMAScript 5.1 规范地址：\n英文版：http://es5.github.io/#x15.1\n中文版：http://yanhaijing.com/es5/#115\njavascript 有8种数据类型，Undefined,Null,Boolean,Number,String,Object,Symbol,Bigint\n这是我们在编程时可以直接操作使用的数据类型，\n在javascript的底层逻辑中还有一些只存在于规范里的抽象类型：\nReference，\nList，\nCompletion，\nProperty，\nDescriptor，\nProperty Identifier，\nLexical Environment，\nEnvironment Record\n这些规范类型是用算法描述ECMAScript语言结构和语言类型的，\n其中与this的指向有关的是Reference类型\nReference由三个部分组成：\n1.base value (属性所在的对象或者是EnvironmentRecord，所以它的值只能是undefined, an Object, a Boolean, a String, a, Number or an environment record)\n2.reference name (属性名称)\n3.strict reference\n举个例子：\n1 2 3 4 5 6 7 8  var foo = 1; //foo对应的Reference是 var fooReference = { base: EnvironmentRecoed, name: \u0026#39;foo\u0026#39;, strict: false }   1 2 3 4 5 6 7 8 9 10 11 12 13 14  var foo = { bar: function() { return this; } } foo.bar(); //bar对应的Reference是 var barReference = { base: foo, propertyName: \u0026#39;bar\u0026#39;, strict: false };   Reference涉及到的方法有：\n1.GetBase 返回base value\n2.isProperty 判断base value是不是一个对象\n3.GetVlaue 从Reference处返回一个真正的值（具体的值，不是Reference）\n按步骤确定this的指向 规范中确定this的值，有明确的步骤判断：\n1.计算MemberExpression的结果赋值给ref\n2.判断ref是不是一个Reference类型\n2.1 如果ref是Reference，并且base value值是一个对象（isProperty(ref)为true），那么this的值就是base value（用getBase获得）\n2.2 如果ref是Reference，并且base value值是Environment Record，那么this的值是ImplicitThisValue(ref)\n2.3 如果ref不是Reference，那么this的值是undefined\n步骤1中 MemberExpression分别有：\nPrimaryExpression //原始表达式\nFunctionExpression //函数表达式\nMemberExpression [Expression] //属性[]访问表达式\nMemberExpression.IdentifierName //属性.访问表达式\nnew MemberExpression Arguments //对象创建表达式\n例子：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  function foo() { console.log(this) } foo(); //MemberExpression是foo  function foo() { return function () { console.log(this) } } foo()(); //MemberExpression是foo()  var foo = { bar: function() { return this } } foo.bar(); //MemberExpression是foo.bar   可以简单判断MemberExpression是()左边的部分\n步骤2中判断ref是不是一个Reference类型\n例子：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  var value = 1; var foo = { value: 2, bar: function() { return this.value; } } //example1 console.log(foo.bar()) //example2 console.log((foo.bar)()) //example3 console.log((foo.bar = foo.bar)()) //example4 console.log((false || foo.bar)()) //example5 console.log((foo.bar, foo.bar)())   example1\nMemberExpression为foo.bar属于规范11.2中提到的属性访问，他会返回一个值类型的引用\n所以foo.bar会返回一个Reference类型\n1 2 3 4 5  var Reference = { base: foo, name: \u0026#39;bar\u0026#39;, strict: false }   符合确定this的步骤中2.1，IsPropertyReference(ref) 为 true，且base value为foo\n所以this指向foo\nconsole.log打印1\nexample2\n(foo.bar)是规范11.1.6中提到的分组表达式，会返回一个Reference类型，\n后面的步骤和example1一样所以this指向foo\nconsole.log打印1\nexample3\n(foo.bar = foo.bar)是规范11.13.1中提到的简单赋值会返回一个rval不是一个Reference，\n对照this判断步骤的2.3，this的值就是undefined（非严格模式下会隐式转换为全局变量，浏览器中就是window）\nconsole.log打印2\nexample4\n(false || foo.bar)是规范11.11中提到的二元逻辑运算符会返回GetValue(rref)不是一个Reference，\n对照this判断步骤2.3，this的值就是undefined\nconsole.log打印2\nexample5\n(foo.bar, foo.bar)是规范11.14中提到的逗号运算符会返回GetValue(rref)不是一个Reference，\n对照this判断步骤2.3，this的值是undefined\nconsole.log打印2\n看一个最常见的情况\n1 2 3 4 5 6  //example6 function foo() { console.log(this) } foo()   MemberExpression是foo，是规范10.3.1中提到的标识符解析会返回一个引用对象Reference，\n1 2 3 4 5  var fooReference = { base: Environment, name: \u0026#39;foo\u0026#39;, strict: false }   对照this判断步骤2.2, this的值为 ImplicitThisValue(ref)\n在规范10.2.1.1.6中对ImplicitThisValue的解释他始终返回undefined\n所以this指向undefined\n不管怎么样按照规范去解读this指向从步骤和逻辑上是更为清晰的\n","description":"","id":28,"section":"restart-js","tags":["js基础","学习笔记"],"title":"从头学习js-6-This","uri":"http://llane00.github.io/restart-js/6-this/"},{"content":"React理念：UI = f(data)\n纯函数在加载不同数据后产生了不同的UI\nuseState 1 2 3 4  const [n, setN] = useState(0); console.log(n) //读 onClick = () =\u0026gt; (setN(n+1)) //写 onClick2 = () =\u0026gt; (setN(i =\u0026gt; i + 1)) //也支持传入一个匿名函数   随着组件更新render，useState会产生多个n，但每次get的n是最新的n\n组件每次重新渲染，组件里的函数都会重新执行，\n对应的所有state都会出现重复分身\n如果你不希望出现重复分身的变量\n可以用useRef/useContext等\n如：\n1 2 3  const nRef = useRef(0); console.log(nRef.current); onClick = () =\u0026gt; (nRef.current += 1)   useState 不能局部更新\nuseState 如果数据地址没变那么react就不会重新render更新\n如果useState的对象生成复杂建议把初始值写成一个匿名函数，不然每次重新渲染时都要做多余的计算开销\nuseState(() =\u0026gt; ({ name: ’neo' }))\nsetState会合并多个同级别的对n的操作，\n如：\n1 2 3 4  setN(n+1) setN(n+1) setN(n+1) //这段代码只会执行会后一行的setN(n+1)   1 2 3 4  setN(n+1) setN(n+2) setN(n+3) //同上也只会执行最后的setN(n+3)   所以setState 建议传入一个匿名函数方法，可以防止上面的合并操作，也可以防止代码出现过时的闭包，\n比如: setN(i =\u0026gt; i + 1)\nuseReducer useReducer 是一个把对state的所有操作都聚拢在内的useState\n用来践行flux思想，具体过程如下：\n1.创建初始值 initialState\n2.创建所有操作 reducer(state, action)\n3.传给useReducer，得到读和写api\n4.调用时写 ({ type: ‘操作类型' })\nredux主要做到了：\n1.集中管理全局状态和对状态的操作\n2.提供所有子组件可以在上下文中读写全局状态\nuseContext 现在可以用useState/useReducer和useContext来代替redux\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31  const AppContext = React.createContext(null) //可以用useState生成读写 const [name, setName] = useState(\u0026#39;the_one\u0026#39;); //也可以用useReducer来生成读写 const initialState = {age:0, sex:\u0026#39;male\u0026#39;} const reducer = (prevState, action) =\u0026gt; { swicth (action.type) { case \u0026#39;age\u0026#39;: return { ...prevState, age: action.payload } case \u0026#39;sex\u0026#39;: return { ...prevState, sex: action.payload } default: throw new Error(\u0026#39;error action type\u0026#39;) break; } } const [ personInfo, dispatch ] = useReducer(reducer, initialState) //用AppContext.Provider来包裹，在value中传入要全局使用的读写name操作 \u0026lt;AppContext.Provider value={{name, setName, personInfo, dispatch}}\u0026gt; \u0026lt;CompontentA/\u0026gt; \u0026lt;CompontentB/\u0026gt; \u0026lt;/AppContext.Provider\u0026gt;   1 2 3 4 5 6  //在组件A和组件B中就可以获取context中的vaule //const {name, setName, personInfo, dispatch} = useContext(AppContext)  setName(\u0026#39;Neo\u0026#39;) dispatch({ type: \u0026#39;age\u0026#39;, payload: \u0026#39;25\u0026#39; }) console.log(name, personInfo)   useEffect useEffect（定义：执行在render后的副作用）\n依赖参数中数组里的值的变化来决定是否要执行函数\nApp() -\u0026gt; 执行 -\u0026gt; VDOM(VNode)\n-\u0026gt; DOM -\u0026gt;useLayoutEffect -\u0026gt; 浏览器改变外观 -\u0026gt; useEffect\nuseEffect在浏览器渲染完成后执行\nuseLayoutEffect 在浏览器渲染前执行\nuseLayoutEffect总是比useEffect先执行，\nuseLayoutEffect里的任务最好是影响了useEffect\nuseMemo \u0026amp;\u0026amp; useCallBack useMemo 可以实现函数的重用，防止在多次render的时候做不必要的重复创建和执行函数\n第一个参数是 ()=\u0026gt;value\n第二个参数是依赖 [m,n]\n只有当依赖不变时，才会计算新的value，\n如果依赖不变，那么就重用之前的value\n（vue2 computed？）\n如果value是一个函数，那么要写成\n()=\u0026gt; ((x)=\u0026gt; console.log(x))\n可以用useCallBack简化\nuseCallback(x=\u0026gt;log(x), [m]) 等价于\nuseMemo(() =\u0026gt; x =\u0026gt; log(x), [m])\nuseRef useRef的目的：在组件不断render时，需要一个值保持不变，比如可以累积计算之类的\nuseRef 原理：用对象的形式来存变量，在对象里可以做到改变对象的值，而不变对象的地址\n为了保证值不变，所以使用引用\n初始化：const count = useRef(0)\n读取：count.current\n汇总 App() 重复 rendering…\n每次变 useState/useRender，setN会触发重新render\n有条件时变 useMemo/useCallBack，防止函数有多余的render\n不变 useRef ，改变值不会触发重新render\n（vue3 ref值有变化会自动render）\nReact.forwardRef 我们可以给一个函数组件一个ref来方便引用一个组件（就可以不用getElementById了），\n但是函数式组件不能直接用useRef产生的ref（class组件可以直接用），因为函数式组件的props里不包含ref\n此时需要用React.forwardRef包裹一下函数组件来获得ref\n1 2 3 4 5 6 7 8 9 10 11 12  function App() { const buttonRef = useRef(null); return ( \u0026lt;div className=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;Button2 ref={buttonRef}\u0026gt;按钮\u0026lt;/Button2\u0026gt; \u0026lt;/div\u0026gt; ) } const Button2 = React.forward((props, ref) =\u0026gt; { return \u0026lt;button className=\u0026#34;red\u0026#34; ref={ref} {…props} /\u0026gt; })   useImpreativeHandle useImpreativeHandle 可以以ref为参数返回一个自定义的ref对象\n自定义hooks 自定义hooks是 对已有的基础react hooks互相组合的封装\n记录日常遇到的问题：\n1.表单像input是用useState还是useRef，有什么区别？\n如果将表单值保持在状态（即受控组件），一个好处是可以在更改时立即访问值，例如，如果你希望在用户在输入框中键入某些内容时禁用某些按钮。\n如果采用ref方法（也称为非受控组件），一个好处是不必每次用户键入时都重新呈现组件（因为调用state update会重新呈现）\n","description":"","id":29,"section":"Reactjs","tags":["React"],"title":"学习React_hooks_1","uri":"http://llane00.github.io/reactjs/1-react-hooks/"},{"content":" 这个系列是我读冴羽老师博客的感悟，\n加入了个人的解读和练习题的解答\n 上篇说到，当javascript代码执行一段可执行代码(executable code)时，会创建对应的执行上下文(execution context)\n那对于每个执行上下文，都有三个重要属性：\n 变量对象(Variable object, VO) 作用域链(Scope chain) this  本文主要讲执行上下文中的作用域链，注意本章将会把之前的内容穿起来很重要\n在之前第2篇作用域和第4篇变量对象中有提到，\n当查到变量时首先从当前上下文的变量对象中查到，\n如果没有找到会从父级（词法静态层面上的）执行上下文的变量对象中查找，\n一直找到全局变量对象（全局对象）\n这样由多个执行上下文的变量对象构成的链表就叫做作用域链\n函数创建 在第2篇中提到js中函数的作用域在函数定义的时候就决定了\n这是因为函数有一个内部属性`[[scope]]``, 当函数创建的时候会把函数的父变量对象保存到其中，但不是完整的作用链\n如：\n1 2 3 4 5  function foo() { function bar() { ... } }   此时函数的各自作用域为：\n1 2 3 4 5 6 7  foo.[[scope]] = [ globalContext.VO ]; bar.[[scope]] = [ fooContext.AO, globalContext.VO ];   函数激活 当函数激活的时候，进入函数上下文，创建VO/AO后，就会将函数活动对象加到作用域的最前端，\n1  Scope = [AO].concat([[scope]])   此时作用域链创建完毕\n总结事例 例子：\n1 2 3 4 5 6  var scope = \u0026#39;global scope\u0026#39;; function checkscope() { var scope2 = \u0026#39;local scope\u0026#39;; return scope2; } checkscope();   函数执行上下文中作用域和变量对象创建过程如下：\n1.checkscope函数被创建，保存作用域到内部属性[[scope]]\n1 2 3  checkscope.[[scope]] = [ globalContext.VO ]   2.执行checkscope函数，创建checkscope函数执行上下文，checkscope函数执行上下文压入执行上下栈\n1 2 3 4  ECStack = [ checkscopeContext, globalContext ];   3.checkscope函数进入准备阶段\n3.1 复制函数内部属性[[scope]]到函数执行上文中\n1 2 3  checkscopeContext = { Scope: checkscope.[[scope]] }   3.2 用函数的arguments属性创建活动对象，随后初始化活动对象，加入形参、函数声明、变量声明\n1 2 3 4 5 6 7 8 9  checkscopeContext = { AO: { arguments: { length: 0, }, scope2: undefined }, Scope: checkscope.[[scope]] }   3.3 将活动对象压入作用域顶端\n1 2 3 4 5 6 7 8 9  checkscopeContext = { AO: { arguments: { length: 0, }, scope2: undefined }, Scope: [AO, [[scope]]] }   准备工作完毕\n4.开始执行checkscope函数，随着函数执行，修改AO的属性值\n1 2 3 4 5 6 7 8 9  checkscopeContext = { AO: { arguments: { length: 0, }, scope2: \u0026#39;local scope\u0026#39; }, Scope: [AO, [[scope]]] }   5.查找到scope2的值，返回后函数执行完毕，checkscope函数上下文从执行上下文中弹出\n1 2 3  ECStack = [ globalContext ]   ","description":"","id":30,"section":"restart-js","tags":["js基础","学习笔记"],"title":"从头学习js-5-作用域链","uri":"http://llane00.github.io/restart-js/5-%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE/"},{"content":" 这个系列是我读冴羽老师博客的感悟，\n加入了个人的解读和练习题的解答\n 上篇说到，当javascript代码执行一段可执行代码(executable code)时，会创建对应的执行上下文(execution context)\n那对于每个执行上下文，都有三个重要属性：\n 变量对象(Variable object, VO) 作用域链(Scope chain) this  本文主要讲执行上下文中的变量对象\n变量对象 变量对象是与执行上下文相关的数据作用域，储存了在上下文中定义的变量和函数声明\n因为不同执行上下文的变量对象稍有不同，这里分全局上下文下的变量对象和函数上下文下的变量对象来讨论。\n全局上下文的变量对象就是全局对象，是全局变量的宿主。\n在浏览器中，全局中的this和window都指向全局变量\n函数上下文中的变量对象称为活动对象（activation object，AO）\n活动对象就是变量对象，只是函数上下文中的变量对象只有函数代码在执行到被激活时才能被访问到，\n活动对象就是在进入函数上下文时被创建的，它通过函数的arguments属性初始化。\n执行上下文生命周期：  创建执行上下文阶段\n创建变量对象，建立作用域，以及明确this的指向    变量对象包括：\n 函数所有形参   由名称和对应值组成的一个变量对象的属性被创建 没有实参，属性值设为undefined  函数声明（函数声明优先于变量声明）   由名称和对应值（函数对象（function-object））组成的一个变量对象的属性被创建 如果变量对象已经存在相同名称的属性，则完全替换这个属性  变量声明   由名称和对应值（undefined）组成的一个变量对象的属性被创建 如果变量名称和已经声明的形式参数或函数相同，则变量声明不会干扰已经存在的这类属性    执行代码阶段\n创建上下文后，开始执行代码，  例子：\n1 2 3 4 5 6 7 8 9  function foo(a) { var b = 2; function c() {} var d = function() {}; b = 3; } foo(1)   在进入执行上下文后，此时的AO为\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  AO = { //AO通过函数的arguments初始化，是一个伪数组  arguments: { 0: 1, length: 1 }, //函数所有形参 由名称和对应值组成的一个变量对象的属性被创建  a: 1, //变量声明 名称和对应值（undefined）组成的一个变量对象的属性被创建  b: undefined, //函数声明 由名称和对应值（函数对象（function-object））组成的一个变量对象的属性被创建  c: reference to function c(){}, //同上变量声明  d: undefined }   函数执行后：\n按顺序执行代码，初始化变量和给变量赋值\n1 2 3 4 5 6 7 8 9 10  AO = { arguments: { 0: 1, length: 1 }, a: 1, b: 3, c: reference to function c() {}, d: reference to FunctionExpression \u0026#34;d\u0026#34; }   关于声明变量和函数时的补充: 这里认为声明变量和函数都有三个阶段：\n1.创建create\n2.初始化initialize（声明时首次初始化不同于第三步的assign）\n3.赋值assign\n关于声明语法的结论是：\nfunction 的「创建」「初始化」和「赋值」都被提升了。\nvar 的「创建」和「初始化」都被提升了。\nlet 的「创建」过程被提升了，但是初始化没有提升，拥有块级作用(暂时性死区)。\nconst 只有创建和初始化，没有「赋值」,「创建」过程被提升了，拥有块级作用(暂时性死区)\n通常认为const不可变是片面的，\n首先const必须初始化，且在栈中储存的值不可修改，\n但当const声明的是引用类型时，堆中的储存值可以改变\n如：\n1 2 3  const obj = {name: \u0026#39;Neo\u0026#39;, age: 20} obj.age = 25 console.log(obj) //{name: \u0026#39;Neo\u0026#39;, age: 25}   如果不通过关键词var let等声明变量，AO中不会创建对应该变量的key-value\n但是当这个变量被赋值assign的时候会创建变量对象到VO中\nmore 参考资料：  关于let的变量提升？探究 https://zhuanlan.zhihu.com/p/28140450/  ","description":"","id":31,"section":"restart-js","tags":["js基础","学习笔记"],"title":"从头学习js-4-变量对象","uri":"http://llane00.github.io/restart-js/4-%E5%8F%98%E9%87%8F%E5%AF%B9%E8%B1%A1/"},{"content":" 这个系列是我读冴羽老师博客的感悟，\n加入了个人的解读和练习题的解答\n 我们知道在js中有变量提升，\n所以js引擎在解析代码的时候不是一行一行去执行的，而是一段一段去分析\n（暂且以函数花括号来划分段）\n实际环境中的函数可能是一层套一层执行的，加上函数有各自的静态作用域\njavascript引擎创建了执行上下文栈（Execution context stack，ECS）来管理这些情况\n由于函数的执行是有顺序的，执行上下文栈是先进后出的栈结构\n我们这里用数组来模拟它\n1  ECStack = []   首先执行全局代码，此时在ECStack中压入一个 globalContext\n1 2 3  ECStack = [ globalContext ]   然后我们执行下面的实例代码\n1 2 3 4 5 6 7 8 9 10  function a() { console.log(\u0026#34;run a\u0026#34;) b() } function b() { console.log(\u0026#34;run b\u0026#34;) } a()   首先执行a函数，在ECStack中压入函数a的执行上下文，\n1 2 3 4  ECStack = [ \u0026lt;a\u0026gt; functionContext, globalContext ]   发现执行函数a中，需要执行b函数（此时a还没执行完，没有出栈），在ECStack中压入函数b的执行上下文\n1 2 3 4 5  ECStack = [ \u0026lt;b\u0026gt; functionContext, \u0026lt;a\u0026gt; functionContext, globalContext ]   函数b执行完后，函数b的执行上下文出栈，ECStack.pop()\n然后函数a也执行完了，继续 ECStack.pop()\n就是这么一个执行栈\n另一个例子：\n代码A\n1 2 3 4 5 6 7 8 9  var scope = \u0026#34;global scope\u0026#34;; function checkscope(){ var scope = \u0026#34;local scope\u0026#34;; function f(){ return scope; } return f(); } checkscope();   代码B\n1 2 3 4 5 6 7 8 9  var scope = \u0026#34;global scope\u0026#34;; function checkscope(){ var scope = \u0026#34;local scope\u0026#34;; function f(){ return scope; } return f; } checkscope()();   首先代码A和代码B 都会打印 localscope，具体原因在上一篇作用域中有解释\n但不同的是A和B的执行上下文的顺序不同\n伪代码是这样的\n1 2 3 4 5  //代码A ECStack.push(\u0026lt;checkscope\u0026gt; functionContext) ECStack.push(\u0026lt;f\u0026gt; functionContext) ECStack.pop() //f 执行结束 ECStack.pop() //checkscope 执行结束   1 2 3 4 5  //代码B ECStack.push(\u0026lt;checkscope\u0026gt; functionContext) ECStack.pop() //checkcope 执行结束 ECStack.push(\u0026lt;f\u0026gt; functionContext) ECStack.pop() //f 执行结束   ","description":"","id":32,"section":"restart-js","tags":["js基础","学习笔记"],"title":"从头学习js-3-执行上下文栈","uri":"http://llane00.github.io/restart-js/3-%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E6%A0%88/"},{"content":" 这个系列是我读冴羽老师博客的感悟，\n加入了个人的解读和练习题的解答\n 作用域是程序如何储存和获取变量的约定\njavascript采用了词法作用域（即静态作用域）\n静态作用域在函数创建的时候就记下了，会在函数代码的书写位置层级向上查找变量\n动态作用域在函数调用的时候才决定，会在函数调用栈中依次向上查找变量\n1 2 3 4 5 6 7 8 9 10 11 12 13  var value = 1; function foo() { console.log(value); } function bar() { var value = 2; foo(); } bar();   以上代码在静态作用域情况下会打印1\n在动态作用域情况下会打印2\n","description":"","id":33,"section":"restart-js","tags":["js基础","学习笔记"],"title":"从头学习js-2-作用域","uri":"http://llane00.github.io/restart-js/2-%E4%BD%9C%E7%94%A8%E5%9F%9F/"},{"content":"normal 模式\ninsert 模式\nvisual 模式\ncontrol + [ 从insert/visual回到normal\nesc 也是从insert/visual回到normal\nnormal 模式下 hjkl 移动光标左下上右\na 在光标后insert\ni 在光标前insert\nshift + a 在当前行结尾处insert\nshift + i 在当前行开头处insert\ngg 光标跳转到文档第一行\nshift + g 光标跳转到文档最后一行\n: + 行号 + 回车 光标跳转到文行特定的行\n数字 + j/k 光标上下移动指定行数\n数字 + w/b 光标左右移动指定的单词个数\n[[ 光标跳转到文档第一行\n]] 光标跳转到文档最后一行\nshift + { 光标跳转到下一个段落\nshift + } 光标跳转到上一个段落\ncontrol + u 向下翻页\ncontrol + d 向上翻页\n% 用于在 () {} 之间跳转\nzz 将当前行剧中到屏幕中\no 换行insert\nshift + o 在上一行空一行insert\n/ + 字符为搜索 （n 和 shift + n 可以继续上下选择）\nf + 字符 光标定位到字符上（;继续下一个 ,继续上一个）\nt + 字符 光标定位到字符前（;继续下一个 ,继续上一个）\nyy 复制当前行\ndd 剪切当前行（删除）\nshift + d 删除当前行光标后的内容\nshift + d 删除当前行光标后的内容 + insert\np 黏贴内容到当前行的下一行\nshift + p 黏贴内容到当前行的上一行\nu 撤销\nx 删除光标选中内容\ns 删除光标选中内容并insert\nshift + s 删除当前行并insert\ncw 等价于 dwi\nvisual 模式下 v 单个字选择模式\nshift + v 行选择模式\n需要选中缩进的时候，按v(或V)进入visual状态，选择多行，用\u0026gt;或\u0026lt;缩进或缩出\n使用v来选中删除\nv+d\nv+x\nv+s\nV+G 会选中当前行到最后一行的内容\ncontrol + v 可以进入visual block模式可以按块来选内容\n例子：\n批量删除每一行开头的-app-\ncontrol + v + GIf-d\n如果要批量插入，每一行开头加入-web-\ncontrol + v + GI-web-\n\u0026ndash;\n实用例子： part 1: dt) 删除)前的所有内容\nvf) 选中到)的所有内容包括右括号\nyt) 复制到)前的内容\nct; 删除到;前的所有内容并insert\nciw 删除当前光标所在的单词 change in word\nci\u0026quot; 删除当前光标最近的\u0026quot;\u0026ldquo;里的内容\npart 2: 四种删除if花括号内容的办法（初始光标在if下一行）：\nif { delete me haha wow ya } 1.shift + v 3j d\n2.d 4 d\n3.d i {\n4.d 2 i {\npart 3: \u0026ldquo;testdfat\u0026rdquo;\n假设光标停留在第一个t位置\ndi\u0026rdquo;：delete all content inside \u0026ldquo;，结果字符串为\u0026rdquo;\u0026quot;\ndta：delete all content to a，结果字符串为\u0026quot;at\u0026quot;\ndfa：delete all content from current location, until a is found，结果字符串为\u0026quot;t\u0026quot;\n在vim中的特殊处理（在vscode插件中无效）： 当在visual模式下选中内容按下:可以对选中的多个行做批处理\n比如选中后 :+normal A.png+回车\n会在每个选中行后加上.png的内容\n分享一下我的vimrc配置 https://github.com/Llane00/my-configs/blob/main/.vimrc\n在安装vim 插件时遇到的问题：\n1.you-complete-me无法安装，原因是其中一个依赖在google资源下，那么可以去官方github issue中查找，替换依赖路径\n2.还是ycm插件，首先需要去vim plugin目录下找到you-complete-me目录，找到install.py，手动去安装python3 install.py\n然后安装时发现缺少cmake，那么就另外brew install cmake\n3.完成安装后由于我的电脑上默认的vim版本太旧了，不支持最新的python3提示ycm有报错（没错还是这个插件），\n我重新用brew 安装了vim brew install vim, 下载完毕后需要在zshrc中加一个alias把vim和vi命令指向到brew新下载的vim下\n可以通过brew list vim去找vim下载的地址,这里只要vim和vi对应的地址\n在.zshrc中加入下面两行\nalias vim='/usr/local/xxx/xxx/vim' alias vi='/usr/local/xxx/xxx/vi' 保存并source zshrc后就可以生效使用新的vim了\nyou-complete-me不亏为最难安装的vim 插件\n","description":"","id":34,"section":"posts","tags":["学习笔记"],"title":"Vim使用笔记","uri":"http://llane00.github.io/posts/vim%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/"},{"content":" 这个系列是我读冴羽老师博客的感悟，\n加入了个人的解读和练习题的解答\n 1 2  function Person() {} let Neo = new Person()   Person 是一个构造函数\nNeo是构造函数Person创建的一个实例\n首先所有的函数都有一个prototype属性\nPerson.prototype 代表的是调用Person构造函数创建的实例的原型\n（即Person.prototype是Neo的原型）\n而js中的对象也有指向原型的属性 __proto__\n所以 Person.prototype === Neo.__proto__\n另外原型也有属性constructor可以指向其对应的构造函数\nPerson.prototype.constructor === Person\n原型和原型链是js实现继承的基础\n原型也是一个js对象，所以原型也有__proto__属性\n原型对象其实是构造函数Object创建的一个实例，所以原型的__proto__指向的是Object.prototype\n当在调用一个对象的属性或方法时，如果该对象没有这个属性或方法，此时会去自动找他的原型是否有，如果还是没有则会继续向原型的原型去找，不断重复直到Object.prototype.__proto__，而Object.prototype.__proto__为null(即Object.prototype 没有原型)\n这个向上自动搜索父级原型的过程就是原型链的体现\n即如果Neo没有toString方法，通过原型链\nNeo.toString() 依然可以执行，因为Object有toString方法\n换言之通过原型链Neo可以“获得”Object的所有属性和方法\n我过去经常会困惑函数是个什么东西，它是怎么储存的\n从变量的类型看，分为基本类型和引用类型\n所以函数只能是以引用类型中的对象形式储存的\n那构造函数Person也是一个对象，\n它的__proto__指向了它的原型Function.prototype\n(所有构造函数的上一级原型都是Function.prototype)\n即：\nPerson.__proto__ === Function.prototype\nFunction.prototype.__proto__ === Object.prototype\n同时构造函数Object的上一级原型也是Function.prototype\n我们整理一下： 所有对象的最终原型都是 Object.prototype\n函数的原型是 -\u0026gt; Function.prototype 的原型是 -\u0026gt; Object.prototype 没有原型\n构造函数Object的原型是Function.prototype\n1 2 3  Person.__proto__ === Function.prototype Function.prototype.__proto__ === Object.prototype Object.__proto__ === Function.prototype   之前看到过一个看上去很奇怪的事情，\nFunction.__proto__ === Function.prototype\n目前可以用上面的结论解释：所有（构造）函数的上一级原型都是Function.prototype\n","description":"","id":35,"section":"restart-js","tags":["js基础","学习笔记"],"title":"从头学习js-1-原型与原型链","uri":"http://llane00.github.io/restart-js/1-%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/"},{"content":"大招技能有冷却 == 节流（throttle） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32  /** * 节流原理：在一定时间内，只能触发一次 * * @param {Function} func 要执行的回调函数 * @param {Number} wait 延时的时间 * @param {Boolean} immediate 是否立即执行 * @return null */ let timeout, flag function throttle(func, wait = 500, immediate = true) { if (immediate) { if (!flag) { flag = true // 如果是立即执行，则在wait毫秒内开始时执行  typeof func === \u0026#39;function\u0026#39; \u0026amp;\u0026amp; func() timeout = setTimeout(() =\u0026gt; { flag = false }, wait) } } else { if (!flag) { flag = true // 如果是非立即执行，则在wait毫秒内的结束处执行  timeout = setTimeout(() =\u0026gt; { flag = false typeof func === \u0026#39;function\u0026#39; \u0026amp;\u0026amp; func() }, wait) } } } export default throttle   吟唱技能防打断 == 防抖（debounce） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  /** * 防抖原理：一定时间内，只有最后一次操作，再过wait毫秒后才执行函数 * * @param {Function} func 要执行的回调函数 * @param {Number} wait 延时的时间 * @param {Boolean} immediate 是否立即执行 * @return null */ let timeout = null function debounce(func, wait = 500, immediate = false) { // 清除定时器  if (timeout !== null) clearTimeout(timeout) // 立即执行，此类情况一般用不到  if (immediate) { var callNow = !timeout timeout = setTimeout(() =\u0026gt; { timeout = null }, wait) if (callNow) typeof func === \u0026#39;function\u0026#39; \u0026amp;\u0026amp; func() } else { // 设置定时器，当最后一次操作后，timeout不会再被清除，所以在延时wait毫秒后执行func回调方法  timeout = setTimeout(() =\u0026gt; { typeof func === \u0026#39;function\u0026#39; \u0026amp;\u0026amp; func() }, wait) } } export default debounce   ","description":"","id":36,"section":"posts","tags":["js基础","学习笔记"],"title":"Js实现节流和防抖","uri":"http://llane00.github.io/posts/js%E5%AE%9E%E7%8E%B0%E8%8A%82%E6%B5%81%E5%92%8C%E9%98%B2%E6%8A%96/"},{"content":"关于Js原型 1 2 3 4 5 6 7 8 9 10 11  // 例子 function Person() { } var person = new Person(); console.log(person.__proto__ == Person.prototype) // true console.log(Person.prototype.constructor == Person) // true // 顺便学习一个ES5的方法,可以获得对象的原型 console.log(Object.getPrototypeOf(person) === Person.prototype) // true   实例与原型 当读取实例的属性时，如果找不到，就会查找与对象关联的原型中的属性，如果还查不到，就去找原型的原型，一直找到最顶层为止。\n原型的原型 原型也是一个对象，原型对象就是通过 Object 构造函数生成的\n由于实例的 proto 指向构造函数的 prototype ，\n所以Person.prototype.proto == Object.prototype\n而再往上Object.prototype.proto == null\n补充   关于constructor: 当获取 person.constructor 时，其实 person 中并没有 constructor 属性,当不能读取到constructor 属性时，会从 person 的原型也就是 Person.prototype 中读取，正好原型中有该属性，所以：\nperson.constructor === Person.prototype.constructor\n  关于__proto__: 绝大部分浏览器都支持这个非标准的方法访问原型，然而它并不存在于 Person.prototype 中，实际上，它是来自于 Object.prototype ，与其说是一个属性，不如说是一个 getter/setter，当使用 obj.proto 时，可以理解成返回了 Object.getPrototypeOf(obj)。\n  关于js的“继承”: 继承意味着复制操作，然而 JavaScript 默认并不会复制对象的属性，相反，JavaScript 只是在两个对象之间创建一个关联，这样，一个对象就可以通过委托访问另一个对象的属性和函数，所以与其叫继承，委托的说法反而更准确些。\n  所有的函数都是 Function 的实例\n  参考资料:  JavaScript深入之从原型到原型链  ","description":"","id":37,"section":"posts","tags":["js基础","学习笔记"],"title":"Js原型","uri":"http://llane00.github.io/posts/js%E5%8E%9F%E5%9E%8B/"},{"content":"常见的定位方案 普通流(normal flow) 在普通流中，元素按照其在HTML中的先后位置至上而下布局，在这个过程中，行内元素水平排列，直到一行被占满后换行，块级元素则会被渲染为完整的一个新行，除非另外指定，否则所有元素默认都是普通流定位。也可以说，普通流中元素的位置由该元素在HTML文档中的位置决定。\n浮动(float) 在浮动布局中，元素首先按照普通流的位置出现，然后根据浮动的方向尽可能的向左边或向右边偏移，其效果与印刷排版中的文本环绕相似。\n绝对定位(absolute position) 在绝对定位布局中，元素会整体脱离普通流，因此绝对定位元素不会对其兄弟元素造成影响，而元素具体的位置由绝对定位的坐标决定。\nBFC 概念 Formatting context（格式化上下文）是W3C CSS2.1 规范中的一个概念。它是页面中的一块渲染区域，并且有一套渲染规则，它决定了其子元素将如何定位，以及和其他元素的关系和相互作用。\nBFC 即 Block Formatting Contexts (块级格式化上下文)，它属于上述定位方案的普通流。\n具有 BFC 特性的元素可以看作是隔离了的独立容器，容器里面的元素不会在布局上影响到外面的元素，并且 BFC 具有普通容器所没有的一些特性。\n通俗一点来讲，可以把 BFC 理解为一个封闭的大箱子，箱子内部的元素无论如何翻江倒海，都不会影响到外部。\nBFC 的触发条件 只要元素满足下面任一条件即可触发 BFC 特性：\n body 根元素 浮动元素：float 除 none 以外的值 绝对定位元素：position (absolute、fixed) display 为 inline-block、table-cells、flex overflow 除了 visible 以外的值 (hidden、auto、scroll)  BFC 的应用  同一个 BFC 下外边距会发生折叠。如果想要避免外边距的重叠，可以将其放在不同的 BFC 容器中。 BFC 可以包含浮动的元素（清除浮动），防止浮动造成高度坍塌。 BFC 可以阻止元素被浮动元素覆盖  参考资料:  10 分钟理解 BFC 原理 CSS盒模型完整介绍  ","description":"","id":38,"section":"posts","tags":["css基础","学习笔记"],"title":"重新理解BFC","uri":"http://llane00.github.io/posts/%E9%87%8D%E6%96%B0%E7%90%86%E8%A7%A3bfc/"},{"content":"背景： 在 JavaScript 里面，数字均为双精度浮点类型，即一个介于 ±2−1023和 ±2+1024之间的数字，或约为 ±10−308到 ±10+308，数字精度为 53 位。整数数值仅在 ±(253 - 1)的范围内可以表示准确。\nJS 的最大和最小安全值可以这样获得:\n1 2  console.log(Number.MAX_SAFE_INTEGER) //9007199254740991 console.log(Number.MIN_SAFE_INTEGER) //-9007199254740991   通过下面的例子，你会明白为什么大于这个值的运算是不安全的:\n1 2 3  var x = 9223372036854775807 console.log(x === x + 1) // output: true console.log(x === x + 1000) //output: true   用 js 实现正整数大数相加： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  //用字符串表示大数 let x = \u0026#39;9007199254740991\u0026#39; //Number.MAX_SAFE_INTEGER let y = \u0026#39;99999999999999999999\u0026#39; //20位大数  function bigNumberAdd(x, y) { //为了把两个数字从个位开始相加，需要补齐位数较小的数，让两个数的位数相等  let maxLength = Math.max(x.length, y.length) //用0补齐位数  x = x.padStart(maxLength, 0) y = y.padStart(maxLength, 0) let carryOver = 0 //进位  let resultStr = \u0026#39;\u0026#39; //最终计算结果  for (let i = maxLength - 1; i \u0026gt;= 0; i--) { let digitSum = parseInt(x[i]) + parseInt(y[i]) + carryOver let currentDigit = digitSum % 10 //取个位  carryOver = Math.floor(digitSum / 10) //取进位  resultStr = currentDigit + resultStr } //如果进位还有1  if (carryOver == 1) { resultStr = \u0026#39;1\u0026#39; + resultStr } return resultStr }   ","description":"","id":39,"section":"posts","tags":["js基础","学习笔记"],"title":"Js实现大数相加","uri":"http://llane00.github.io/posts/js%E5%AE%9E%E7%8E%B0%E5%A4%A7%E6%95%B0%E7%9B%B8%E5%8A%A0/"},{"content":"这次推荐的压缩工具是 optimizt\n稍微看了下，算是一个压缩图片的工具合集\n安装optimizt 1  npm i -g @funboxteam/optimizt   也支持WebStorm, PhpStorm等插件\n also support External Tool in WebStorm, PhpStorm, etc\n DIY一下 optimizt 支持用find命令查找图片\n1  optimizt `find . -type f -name \u0026#39;*.jpg\u0026#39;`   于是我在.bash_profile（或者其他Shell配置文件）中添加别名 + 自定义的搜索方式\n1  alias yasuo=\u0026#39;optimizt `find . -name \u0026#34;*.png\u0026#34; -o -name \u0026#34;*.jpg\u0026#34; -o -name \u0026#34;*.jpeg\u0026#34; -o -name \u0026#34;*.gif\u0026#34; -o -name \u0026#34;*.svg\u0026#34;`\u0026#39;   这个命令可以压缩当前目录下所有找到的jpg/jpeg/png/gif/svg后缀的图片（支持多层目录迭代查找）\n加入参数 -l 后lossless可无损压缩\n1  alias yasuo2=\u0026#39;optimizt -l `find . -name \u0026#34;*.png\u0026#34; -o -name \u0026#34;*.jpg\u0026#34; -o -name \u0026#34;*.jpeg\u0026#34; -o -name \u0026#34;*.gif\u0026#34; -o -name \u0026#34;*.svg\u0026#34;`\u0026#39;   more:\n最后推荐一波自制命令行查看天气工具 llane-weather\n效果如下：\n如果觉得有趣或者有帮助的可以点下github的star，觉得不好用的也可以直接留言告诉我。\n","description":"","id":40,"section":"posts","tags":["命令行"],"title":"使用命令行快速压缩图片","uri":"http://llane00.github.io/posts/%E4%BD%BF%E7%94%A8%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%BF%AB%E9%80%9F%E5%8E%8B%E7%BC%A9%E5%9B%BE%E7%89%87/"}]